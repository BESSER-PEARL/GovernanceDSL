# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,77,541,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,1,0,1,0,1,0,1,0,1,0,
        1,0,1,1,1,1,3,1,137,8,1,1,2,1,2,1,2,1,2,1,2,1,2,3,2,145,8,2,1,2,
        3,2,148,8,2,1,2,3,2,151,8,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,3,3,160,
        8,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,4,3,4,170,8,4,1,4,3,4,173,8,4,
        1,4,3,4,176,8,4,1,4,1,4,1,5,1,5,1,5,1,5,3,5,184,8,5,1,5,1,5,1,5,
        1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,
        1,9,3,9,206,8,9,1,9,1,9,1,9,1,9,4,9,212,8,9,11,9,12,9,213,1,9,1,
        9,3,9,218,8,9,1,10,1,10,1,11,1,11,1,11,3,11,225,8,11,1,12,1,12,1,
        12,1,12,1,12,4,12,232,8,12,11,12,12,12,233,1,12,1,12,3,12,238,8,
        12,1,13,1,13,1,13,3,13,243,8,13,1,13,1,13,1,13,1,13,1,14,1,14,1,
        15,1,15,1,15,3,15,254,8,15,1,16,1,16,1,16,1,17,1,17,1,17,1,17,1,
        18,1,18,1,19,1,19,1,19,1,19,1,20,1,20,1,21,1,21,1,21,1,21,1,21,5,
        21,276,8,21,10,21,12,21,279,9,21,1,22,1,22,1,22,1,22,1,22,3,22,286,
        8,22,1,23,1,23,1,24,1,24,1,24,1,24,1,24,5,24,295,8,24,10,24,12,24,
        298,9,24,1,25,1,25,1,25,1,25,1,25,5,25,305,8,25,10,25,12,25,308,
        9,25,1,26,1,26,1,26,1,26,3,26,314,8,26,1,26,1,26,3,26,318,8,26,3,
        26,320,8,26,1,27,1,27,1,27,1,27,1,27,5,27,327,8,27,10,27,12,27,330,
        9,27,1,28,1,28,3,28,334,8,28,1,29,1,29,1,29,1,29,1,29,5,29,341,8,
        29,10,29,12,29,344,9,29,1,30,1,30,1,30,1,30,1,30,1,30,5,30,352,8,
        30,10,30,12,30,355,9,30,3,30,357,8,30,1,31,1,31,1,32,1,32,1,32,1,
        32,1,32,3,32,366,8,32,1,32,5,32,369,8,32,10,32,12,32,372,9,32,1,
        33,1,33,1,34,1,34,3,34,378,8,34,1,35,1,35,3,35,382,8,35,1,36,1,36,
        1,36,1,37,1,37,1,37,1,38,1,38,1,38,3,38,393,8,38,1,38,3,38,396,8,
        38,1,39,1,39,1,39,1,40,1,40,1,40,3,40,404,8,40,1,40,3,40,407,8,40,
        1,40,3,40,410,8,40,1,40,3,40,413,8,40,1,40,3,40,416,8,40,1,41,1,
        41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,427,8,41,1,42,1,42,1,
        42,1,43,1,43,1,44,1,44,1,45,1,45,1,45,1,45,1,45,1,45,1,46,1,46,1,
        46,1,46,1,46,5,46,447,8,46,10,46,12,46,450,9,46,1,47,1,47,1,47,1,
        47,1,48,1,48,1,48,1,48,1,48,5,48,461,8,48,10,48,12,48,464,9,48,1,
        49,1,49,3,49,468,8,49,1,49,1,49,1,49,1,50,1,50,1,51,1,51,3,51,477,
        8,51,1,51,3,51,480,8,51,1,51,1,51,1,51,1,51,5,51,486,8,51,10,51,
        12,51,489,9,51,1,52,1,52,1,52,1,52,3,52,495,8,52,1,53,1,53,1,54,
        1,54,1,54,1,55,1,55,1,55,1,56,1,56,1,56,1,56,1,56,3,56,510,8,56,
        1,57,1,57,1,57,1,57,1,58,1,58,1,59,1,59,1,59,1,59,1,60,1,60,1,60,
        1,60,1,61,1,61,1,62,1,62,1,62,4,62,531,8,62,11,62,12,62,532,1,62,
        1,62,1,63,1,63,3,63,539,8,63,1,63,0,0,64,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
        64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
        106,108,110,112,114,116,118,120,122,124,126,0,9,1,0,4,9,1,0,19,21,
        1,0,23,25,1,0,27,29,1,0,43,44,1,0,50,53,1,0,58,60,1,0,67,68,1,0,
        71,72,530,0,128,1,0,0,0,2,136,1,0,0,0,4,138,1,0,0,0,6,154,1,0,0,
        0,8,164,1,0,0,0,10,179,1,0,0,0,12,188,1,0,0,0,14,190,1,0,0,0,16,
        194,1,0,0,0,18,198,1,0,0,0,20,219,1,0,0,0,22,221,1,0,0,0,24,226,
        1,0,0,0,26,239,1,0,0,0,28,248,1,0,0,0,30,253,1,0,0,0,32,255,1,0,
        0,0,34,258,1,0,0,0,36,262,1,0,0,0,38,264,1,0,0,0,40,268,1,0,0,0,
        42,270,1,0,0,0,44,280,1,0,0,0,46,287,1,0,0,0,48,289,1,0,0,0,50,299,
        1,0,0,0,52,309,1,0,0,0,54,321,1,0,0,0,56,331,1,0,0,0,58,335,1,0,
        0,0,60,345,1,0,0,0,62,358,1,0,0,0,64,360,1,0,0,0,66,373,1,0,0,0,
        68,377,1,0,0,0,70,379,1,0,0,0,72,383,1,0,0,0,74,386,1,0,0,0,76,389,
        1,0,0,0,78,397,1,0,0,0,80,400,1,0,0,0,82,417,1,0,0,0,84,428,1,0,
        0,0,86,431,1,0,0,0,88,433,1,0,0,0,90,435,1,0,0,0,92,441,1,0,0,0,
        94,451,1,0,0,0,96,455,1,0,0,0,98,465,1,0,0,0,100,472,1,0,0,0,102,
        474,1,0,0,0,104,490,1,0,0,0,106,496,1,0,0,0,108,498,1,0,0,0,110,
        501,1,0,0,0,112,504,1,0,0,0,114,511,1,0,0,0,116,515,1,0,0,0,118,
        517,1,0,0,0,120,521,1,0,0,0,122,525,1,0,0,0,124,527,1,0,0,0,126,
        538,1,0,0,0,128,129,3,14,7,0,129,130,3,52,26,0,130,131,3,2,1,0,131,
        132,1,0,0,0,132,133,5,0,0,1,133,1,1,0,0,0,134,137,3,4,2,0,135,137,
        3,6,3,0,136,134,1,0,0,0,136,135,1,0,0,0,137,3,1,0,0,0,138,139,3,
        12,6,0,139,140,5,74,0,0,140,141,5,1,0,0,141,142,3,16,8,0,142,144,
        3,44,22,0,143,145,3,54,27,0,144,143,1,0,0,0,144,145,1,0,0,0,145,
        147,1,0,0,0,146,148,3,80,40,0,147,146,1,0,0,0,147,148,1,0,0,0,148,
        150,1,0,0,0,149,151,3,104,52,0,150,149,1,0,0,0,150,151,1,0,0,0,151,
        152,1,0,0,0,152,153,5,2,0,0,153,5,1,0,0,0,154,155,5,3,0,0,155,156,
        5,74,0,0,156,157,5,1,0,0,157,159,3,16,8,0,158,160,3,112,56,0,159,
        158,1,0,0,0,159,160,1,0,0,0,160,161,1,0,0,0,161,162,3,124,62,0,162,
        163,5,2,0,0,163,7,1,0,0,0,164,165,3,12,6,0,165,166,5,74,0,0,166,
        167,5,1,0,0,167,169,3,44,22,0,168,170,3,54,27,0,169,168,1,0,0,0,
        169,170,1,0,0,0,170,172,1,0,0,0,171,173,3,80,40,0,172,171,1,0,0,
        0,172,173,1,0,0,0,173,175,1,0,0,0,174,176,3,104,52,0,175,174,1,0,
        0,0,175,176,1,0,0,0,176,177,1,0,0,0,177,178,5,2,0,0,178,9,1,0,0,
        0,179,180,5,3,0,0,180,181,5,74,0,0,181,183,5,1,0,0,182,184,3,112,
        56,0,183,182,1,0,0,0,183,184,1,0,0,0,184,185,1,0,0,0,185,186,3,124,
        62,0,186,187,5,2,0,0,187,11,1,0,0,0,188,189,7,0,0,0,189,13,1,0,0,
        0,190,191,5,10,0,0,191,192,5,11,0,0,192,193,3,18,9,0,193,15,1,0,
        0,0,194,195,5,12,0,0,195,196,5,11,0,0,196,197,5,74,0,0,197,17,1,
        0,0,0,198,199,5,13,0,0,199,205,5,74,0,0,200,201,5,14,0,0,201,202,
        3,20,10,0,202,203,5,11,0,0,203,204,3,22,11,0,204,206,1,0,0,0,205,
        200,1,0,0,0,205,206,1,0,0,0,206,217,1,0,0,0,207,208,5,1,0,0,208,
        209,5,15,0,0,209,211,5,11,0,0,210,212,3,24,12,0,211,210,1,0,0,0,
        212,213,1,0,0,0,213,211,1,0,0,0,213,214,1,0,0,0,214,215,1,0,0,0,
        215,216,5,2,0,0,216,218,1,0,0,0,217,207,1,0,0,0,217,218,1,0,0,0,
        218,19,1,0,0,0,219,220,5,16,0,0,220,21,1,0,0,0,221,224,5,74,0,0,
        222,223,5,17,0,0,223,225,5,74,0,0,224,222,1,0,0,0,224,225,1,0,0,
        0,225,23,1,0,0,0,226,237,5,74,0,0,227,228,5,1,0,0,228,229,5,18,0,
        0,229,231,5,11,0,0,230,232,3,26,13,0,231,230,1,0,0,0,232,233,1,0,
        0,0,233,231,1,0,0,0,233,234,1,0,0,0,234,235,1,0,0,0,235,236,5,2,
        0,0,236,238,1,0,0,0,237,227,1,0,0,0,237,238,1,0,0,0,238,25,1,0,0,
        0,239,242,5,74,0,0,240,241,5,11,0,0,241,243,3,28,14,0,242,240,1,
        0,0,0,242,243,1,0,0,0,243,244,1,0,0,0,244,245,5,1,0,0,245,246,3,
        30,15,0,246,247,5,2,0,0,247,27,1,0,0,0,248,249,7,1,0,0,249,29,1,
        0,0,0,250,254,3,34,17,0,251,254,3,38,19,0,252,254,3,32,16,0,253,
        250,1,0,0,0,253,251,1,0,0,0,253,252,1,0,0,0,254,31,1,0,0,0,255,256,
        3,38,19,0,256,257,3,42,21,0,257,33,1,0,0,0,258,259,5,22,0,0,259,
        260,5,11,0,0,260,261,3,36,18,0,261,35,1,0,0,0,262,263,7,2,0,0,263,
        37,1,0,0,0,264,265,5,26,0,0,265,266,5,11,0,0,266,267,3,40,20,0,267,
        39,1,0,0,0,268,269,7,3,0,0,269,41,1,0,0,0,270,271,5,30,0,0,271,272,
        5,11,0,0,272,277,5,74,0,0,273,274,5,31,0,0,274,276,5,74,0,0,275,
        273,1,0,0,0,276,279,1,0,0,0,277,275,1,0,0,0,277,278,1,0,0,0,278,
        43,1,0,0,0,279,277,1,0,0,0,280,281,5,32,0,0,281,285,5,33,0,0,282,
        286,3,46,23,0,283,286,3,48,24,0,284,286,3,50,25,0,285,282,1,0,0,
        0,285,283,1,0,0,0,285,284,1,0,0,0,286,45,1,0,0,0,287,288,5,34,0,
        0,288,47,1,0,0,0,289,290,5,35,0,0,290,291,5,11,0,0,291,296,5,74,
        0,0,292,293,5,31,0,0,293,295,5,74,0,0,294,292,1,0,0,0,295,298,1,
        0,0,0,296,294,1,0,0,0,296,297,1,0,0,0,297,49,1,0,0,0,298,296,1,0,
        0,0,299,300,5,36,0,0,300,301,5,11,0,0,301,306,5,74,0,0,302,303,5,
        31,0,0,303,305,5,74,0,0,304,302,1,0,0,0,305,308,1,0,0,0,306,304,
        1,0,0,0,306,307,1,0,0,0,307,51,1,0,0,0,308,306,1,0,0,0,309,310,5,
        37,0,0,310,319,5,11,0,0,311,313,3,58,29,0,312,314,3,64,32,0,313,
        312,1,0,0,0,313,314,1,0,0,0,314,320,1,0,0,0,315,317,3,64,32,0,316,
        318,3,58,29,0,317,316,1,0,0,0,317,318,1,0,0,0,318,320,1,0,0,0,319,
        311,1,0,0,0,319,315,1,0,0,0,320,53,1,0,0,0,321,322,5,38,0,0,322,
        323,5,11,0,0,323,328,3,56,28,0,324,325,5,31,0,0,325,327,3,56,28,
        0,326,324,1,0,0,0,327,330,1,0,0,0,328,326,1,0,0,0,328,329,1,0,0,
        0,329,55,1,0,0,0,330,328,1,0,0,0,331,333,5,74,0,0,332,334,3,72,36,
        0,333,332,1,0,0,0,333,334,1,0,0,0,334,57,1,0,0,0,335,336,5,39,0,
        0,336,337,5,11,0,0,337,342,3,60,30,0,338,339,5,40,0,0,339,341,3,
        60,30,0,340,338,1,0,0,0,341,344,1,0,0,0,342,340,1,0,0,0,342,343,
        1,0,0,0,343,59,1,0,0,0,344,342,1,0,0,0,345,356,5,74,0,0,346,347,
        5,41,0,0,347,348,5,11,0,0,348,353,3,62,31,0,349,350,5,31,0,0,350,
        352,3,62,31,0,351,349,1,0,0,0,352,355,1,0,0,0,353,351,1,0,0,0,353,
        354,1,0,0,0,354,357,1,0,0,0,355,353,1,0,0,0,356,346,1,0,0,0,356,
        357,1,0,0,0,357,61,1,0,0,0,358,359,5,74,0,0,359,63,1,0,0,0,360,361,
        5,42,0,0,361,362,5,11,0,0,362,370,3,68,34,0,363,365,5,31,0,0,364,
        366,3,66,33,0,365,364,1,0,0,0,365,366,1,0,0,0,366,367,1,0,0,0,367,
        369,3,68,34,0,368,363,1,0,0,0,369,372,1,0,0,0,370,368,1,0,0,0,370,
        371,1,0,0,0,371,65,1,0,0,0,372,370,1,0,0,0,373,374,7,4,0,0,374,67,
        1,0,0,0,375,378,3,70,35,0,376,378,3,76,38,0,377,375,1,0,0,0,377,
        376,1,0,0,0,378,69,1,0,0,0,379,381,3,62,31,0,380,382,3,74,37,0,381,
        380,1,0,0,0,381,382,1,0,0,0,382,71,1,0,0,0,383,384,5,33,0,0,384,
        385,3,62,31,0,385,73,1,0,0,0,386,387,5,45,0,0,387,388,5,76,0,0,388,
        75,1,0,0,0,389,390,5,46,0,0,390,392,3,62,31,0,391,393,3,74,37,0,
        392,391,1,0,0,0,392,393,1,0,0,0,393,395,1,0,0,0,394,396,3,78,39,
        0,395,394,1,0,0,0,395,396,1,0,0,0,396,77,1,0,0,0,397,398,5,47,0,
        0,398,399,5,76,0,0,399,79,1,0,0,0,400,401,5,48,0,0,401,403,5,11,
        0,0,402,404,3,82,41,0,403,402,1,0,0,0,403,404,1,0,0,0,404,406,1,
        0,0,0,405,407,3,92,46,0,406,405,1,0,0,0,406,407,1,0,0,0,407,409,
        1,0,0,0,408,410,3,94,47,0,409,408,1,0,0,0,409,410,1,0,0,0,410,412,
        1,0,0,0,411,413,3,96,48,0,412,411,1,0,0,0,412,413,1,0,0,0,413,415,
        1,0,0,0,414,416,3,98,49,0,415,414,1,0,0,0,415,416,1,0,0,0,416,81,
        1,0,0,0,417,418,5,49,0,0,418,419,3,86,43,0,419,426,5,11,0,0,420,
        427,3,84,42,0,421,427,3,90,45,0,422,423,3,84,42,0,423,424,5,31,0,
        0,424,425,3,90,45,0,425,427,1,0,0,0,426,420,1,0,0,0,426,421,1,0,
        0,0,426,422,1,0,0,0,427,83,1,0,0,0,428,429,5,75,0,0,429,430,3,88,
        44,0,430,85,1,0,0,0,431,432,5,74,0,0,432,87,1,0,0,0,433,434,7,5,
        0,0,434,89,1,0,0,0,435,436,5,75,0,0,436,437,5,17,0,0,437,438,5,75,
        0,0,438,439,5,17,0,0,439,440,5,75,0,0,440,91,1,0,0,0,441,442,5,54,
        0,0,442,443,5,11,0,0,443,448,3,62,31,0,444,445,5,31,0,0,445,447,
        3,62,31,0,446,444,1,0,0,0,447,450,1,0,0,0,448,446,1,0,0,0,448,449,
        1,0,0,0,449,93,1,0,0,0,450,448,1,0,0,0,451,452,5,55,0,0,452,453,
        5,11,0,0,453,454,5,75,0,0,454,95,1,0,0,0,455,456,5,56,0,0,456,457,
        5,11,0,0,457,462,3,62,31,0,458,459,5,31,0,0,459,461,3,62,31,0,460,
        458,1,0,0,0,461,464,1,0,0,0,462,460,1,0,0,0,462,463,1,0,0,0,463,
        97,1,0,0,0,464,462,1,0,0,0,465,467,5,57,0,0,466,468,3,100,50,0,467,
        466,1,0,0,0,467,468,1,0,0,0,468,469,1,0,0,0,469,470,5,11,0,0,470,
        471,3,122,61,0,471,99,1,0,0,0,472,473,7,6,0,0,473,101,1,0,0,0,474,
        476,5,61,0,0,475,477,3,100,50,0,476,475,1,0,0,0,476,477,1,0,0,0,
        477,479,1,0,0,0,478,480,3,66,33,0,479,478,1,0,0,0,479,480,1,0,0,
        0,480,481,1,0,0,0,481,482,5,11,0,0,482,487,5,74,0,0,483,484,5,31,
        0,0,484,486,5,74,0,0,485,483,1,0,0,0,486,489,1,0,0,0,487,485,1,0,
        0,0,487,488,1,0,0,0,488,103,1,0,0,0,489,487,1,0,0,0,490,491,5,62,
        0,0,491,494,5,11,0,0,492,495,3,106,53,0,493,495,3,110,55,0,494,492,
        1,0,0,0,494,493,1,0,0,0,495,105,1,0,0,0,496,497,3,108,54,0,497,107,
        1,0,0,0,498,499,5,63,0,0,499,500,5,76,0,0,500,109,1,0,0,0,501,502,
        5,64,0,0,502,503,3,126,63,0,503,111,1,0,0,0,504,505,5,65,0,0,505,
        506,5,11,0,0,506,507,3,114,57,0,507,509,3,118,59,0,508,510,3,120,
        60,0,509,508,1,0,0,0,509,510,1,0,0,0,510,113,1,0,0,0,511,512,5,66,
        0,0,512,513,5,11,0,0,513,514,3,116,58,0,514,115,1,0,0,0,515,516,
        7,7,0,0,516,117,1,0,0,0,517,518,5,69,0,0,518,519,5,11,0,0,519,520,
        3,122,61,0,520,119,1,0,0,0,521,522,5,70,0,0,522,523,5,11,0,0,523,
        524,3,122,61,0,524,121,1,0,0,0,525,526,7,8,0,0,526,123,1,0,0,0,527,
        528,5,73,0,0,528,530,5,1,0,0,529,531,3,126,63,0,530,529,1,0,0,0,
        531,532,1,0,0,0,532,530,1,0,0,0,532,533,1,0,0,0,533,534,1,0,0,0,
        534,535,5,2,0,0,535,125,1,0,0,0,536,539,3,8,4,0,537,539,3,10,5,0,
        538,536,1,0,0,0,538,537,1,0,0,0,539,127,1,0,0,0,51,136,144,147,150,
        159,169,172,175,183,205,213,217,224,233,237,242,253,277,285,296,
        306,313,317,319,328,333,342,353,356,365,370,377,381,392,395,403,
        406,409,412,415,426,448,462,467,476,479,487,494,509,532,538
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'ComposedPolicy'", "'MajorityPolicy'", 
                     "'LeaderDrivenPolicy'", "'AbsoluteMajorityPolicy'", 
                     "'ConsensusPolicy'", "'LazyConsensusPolicy'", "'VotingPolicy'", 
                     "'Scopes'", "':'", "'Scope'", "'Project'", "'from'", 
                     "'activities'", "'GitHub'", "'/'", "'tasks'", "'Issue'", 
                     "'Pull request'", "'All'", "'Status'", "'completed'", 
                     "'accepted'", "'partial'", "'Action'", "'merge'", "'review'", 
                     "'release'", "'Labels'", "','", "'DecisionType'", "'as'", 
                     "'BooleanDecision'", "'StringList'", "'ElementList'", 
                     "'Participants'", "'Participant list'", "'Roles'", 
                     "';'", "'composed of'", "'Individuals'", "'include'", 
                     "'not'", "'with vote value'", "'(Agent)'", "'with confidence'", 
                     "'Conditions'", "'Deadline'", "'days'", "'weeks'", 
                     "'months'", "'years'", "'ParticipantExclusion'", "'MinParticipants'", 
                     "'VetoRight'", "'PassedTests'", "'pre'", "'post'", 
                     "'concurrent'", "'LabelCondition'", "'Parameters'", 
                     "'ratio'", "'default'", "'Order'", "'Execution'", "'sequential'", 
                     "'parallel'", "'RequireAll'", "'CarryOver'", "'true'", 
                     "'false'", "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "ID", "SIGNED_INT", "FLOAT", 
                      "WS" ]

    RULE_governance = 0
    RULE_policy = 1
    RULE_topLevelSinglePolicy = 2
    RULE_topLevelComposedPolicy = 3
    RULE_nestedSinglePolicy = 4
    RULE_nestedComposedPolicy = 5
    RULE_policyType = 6
    RULE_scopes = 7
    RULE_scope = 8
    RULE_project = 9
    RULE_platform = 10
    RULE_repoID = 11
    RULE_activity = 12
    RULE_task = 13
    RULE_taskType = 14
    RULE_taskContent = 15
    RULE_actionWithLabels = 16
    RULE_status = 17
    RULE_statusEnum = 18
    RULE_action = 19
    RULE_actionEnum = 20
    RULE_labels = 21
    RULE_decisionType = 22
    RULE_booleanDecision = 23
    RULE_stringList = 24
    RULE_elementList = 25
    RULE_participants = 26
    RULE_policyParticipants = 27
    RULE_partID = 28
    RULE_roles = 29
    RULE_roleID = 30
    RULE_participantID = 31
    RULE_individuals = 32
    RULE_include = 33
    RULE_individualEntry = 34
    RULE_individual = 35
    RULE_hasRole = 36
    RULE_voteValue = 37
    RULE_agent = 38
    RULE_confidence = 39
    RULE_conditions = 40
    RULE_deadline = 41
    RULE_offset = 42
    RULE_deadlineID = 43
    RULE_timeUnit = 44
    RULE_date = 45
    RULE_participantExclusion = 46
    RULE_minParticipant = 47
    RULE_vetoRight = 48
    RULE_passedTests = 49
    RULE_evaluationMode = 50
    RULE_labelsCondition = 51
    RULE_parameters = 52
    RULE_votParams = 53
    RULE_ratio = 54
    RULE_default = 55
    RULE_order = 56
    RULE_orderType = 57
    RULE_orderTypeValue = 58
    RULE_orderMode = 59
    RULE_carryOver = 60
    RULE_booleanValue = 61
    RULE_phases = 62
    RULE_nestedPolicy = 63

    ruleNames =  [ "governance", "policy", "topLevelSinglePolicy", "topLevelComposedPolicy", 
                   "nestedSinglePolicy", "nestedComposedPolicy", "policyType", 
                   "scopes", "scope", "project", "platform", "repoID", "activity", 
                   "task", "taskType", "taskContent", "actionWithLabels", 
                   "status", "statusEnum", "action", "actionEnum", "labels", 
                   "decisionType", "booleanDecision", "stringList", "elementList", 
                   "participants", "policyParticipants", "partID", "roles", 
                   "roleID", "participantID", "individuals", "include", 
                   "individualEntry", "individual", "hasRole", "voteValue", 
                   "agent", "confidence", "conditions", "deadline", "offset", 
                   "deadlineID", "timeUnit", "date", "participantExclusion", 
                   "minParticipant", "vetoRight", "passedTests", "evaluationMode", 
                   "labelsCondition", "parameters", "votParams", "ratio", 
                   "default", "order", "orderType", "orderTypeValue", "orderMode", 
                   "carryOver", "booleanValue", "phases", "nestedPolicy" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    ID=74
    SIGNED_INT=75
    FLOAT=76
    WS=77

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class GovernanceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def scopes(self):
            return self.getTypedRuleContext(govdslParser.ScopesContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def policy(self):
            return self.getTypedRuleContext(govdslParser.PolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_governance

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGovernance" ):
                listener.enterGovernance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGovernance" ):
                listener.exitGovernance(self)




    def governance(self):

        localctx = govdslParser.GovernanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_governance)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.scopes()
            self.state = 129
            self.participants()
            self.state = 130
            self.policy()
            self.state = 132
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def topLevelSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelSinglePolicyContext,0)


        def topLevelComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 136
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.state = 134
                self.topLevelSinglePolicy()
                pass
            elif token in [3]:
                self.state = 135
                self.topLevelComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSinglePolicy" ):
                listener.enterTopLevelSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSinglePolicy" ):
                listener.exitTopLevelSinglePolicy(self)




    def topLevelSinglePolicy(self):

        localctx = govdslParser.TopLevelSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topLevelSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self.policyType()
            self.state = 139
            self.match(govdslParser.ID)
            self.state = 140
            self.match(govdslParser.T__0)
            self.state = 141
            self.scope()
            self.state = 142
            self.decisionType()
            self.state = 144
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38:
                self.state = 143
                self.policyParticipants()


            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 146
                self.conditions()


            self.state = 150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==62:
                self.state = 149
                self.parameters()


            self.state = 152
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelComposedPolicy" ):
                listener.enterTopLevelComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelComposedPolicy" ):
                listener.exitTopLevelComposedPolicy(self)




    def topLevelComposedPolicy(self):

        localctx = govdslParser.TopLevelComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_topLevelComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(govdslParser.T__2)
            self.state = 155
            self.match(govdslParser.ID)
            self.state = 156
            self.match(govdslParser.T__0)
            self.state = 157
            self.scope()
            self.state = 159
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 158
                self.order()


            self.state = 161
            self.phases()
            self.state = 162
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedSinglePolicy" ):
                listener.enterNestedSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedSinglePolicy" ):
                listener.exitNestedSinglePolicy(self)




    def nestedSinglePolicy(self):

        localctx = govdslParser.NestedSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_nestedSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.policyType()
            self.state = 165
            self.match(govdslParser.ID)
            self.state = 166
            self.match(govdslParser.T__0)
            self.state = 167
            self.decisionType()
            self.state = 169
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38:
                self.state = 168
                self.policyParticipants()


            self.state = 172
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 171
                self.conditions()


            self.state = 175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==62:
                self.state = 174
                self.parameters()


            self.state = 177
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedComposedPolicy" ):
                listener.enterNestedComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedComposedPolicy" ):
                listener.exitNestedComposedPolicy(self)




    def nestedComposedPolicy(self):

        localctx = govdslParser.NestedComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_nestedComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self.match(govdslParser.T__2)
            self.state = 180
            self.match(govdslParser.ID)
            self.state = 181
            self.match(govdslParser.T__0)
            self.state = 183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 182
                self.order()


            self.state = 185
            self.phases()
            self.state = 186
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 188
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1008) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self):
            return self.getTypedRuleContext(govdslParser.ProjectContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_scopes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopes" ):
                listener.enterScopes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopes" ):
                listener.exitScopes(self)




    def scopes(self):

        localctx = govdslParser.ScopesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_scopes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(govdslParser.T__9)
            self.state = 191
            self.match(govdslParser.T__10)
            self.state = 192
            self.project()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            self.match(govdslParser.T__11)
            self.state = 195
            self.match(govdslParser.T__10)
            self.state = 196
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(govdslParser.T__12)
            self.state = 199
            self.match(govdslParser.ID)
            self.state = 205
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 200
                self.match(govdslParser.T__13)
                self.state = 201
                self.platform()
                self.state = 202
                self.match(govdslParser.T__10)
                self.state = 203
                self.repoID()


            self.state = 217
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 207
                self.match(govdslParser.T__0)
                self.state = 208
                self.match(govdslParser.T__14)
                self.state = 209
                self.match(govdslParser.T__10)
                self.state = 211 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 210
                    self.activity()
                    self.state = 213 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==74):
                        break

                self.state = 215
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self.match(govdslParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self.match(govdslParser.ID)
            self.state = 224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 222
                self.match(govdslParser.T__16)
                self.state = 223
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_activity)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self.match(govdslParser.ID)
            self.state = 237
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 227
                self.match(govdslParser.T__0)
                self.state = 228
                self.match(govdslParser.T__17)
                self.state = 229
                self.match(govdslParser.T__10)
                self.state = 231 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 230
                    self.task()
                    self.state = 233 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==74):
                        break

                self.state = 235
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self.match(govdslParser.ID)
            self.state = 242
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 240
                self.match(govdslParser.T__10)
                self.state = 241
                self.taskType()


            self.state = 244
            self.match(govdslParser.T__0)
            self.state = 245
            self.taskContent()
            self.state = 246
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_taskContent)
        try:
            self.state = 253
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 250
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 251
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 252
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 255
            self.action()
            self.state = 256
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self.match(govdslParser.T__21)
            self.state = 259
            self.match(govdslParser.T__10)
            self.state = 260
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 58720256) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(govdslParser.T__25)
            self.state = 265
            self.match(govdslParser.T__10)
            self.state = 266
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 939524096) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.match(govdslParser.T__29)
            self.state = 271
            self.match(govdslParser.T__10)
            self.state = 272
            self.match(govdslParser.ID)
            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 273
                self.match(govdslParser.T__30)
                self.state = 274
                self.match(govdslParser.ID)
                self.state = 279
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecisionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanDecision(self):
            return self.getTypedRuleContext(govdslParser.BooleanDecisionContext,0)


        def stringList(self):
            return self.getTypedRuleContext(govdslParser.StringListContext,0)


        def elementList(self):
            return self.getTypedRuleContext(govdslParser.ElementListContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_decisionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecisionType" ):
                listener.enterDecisionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecisionType" ):
                listener.exitDecisionType(self)




    def decisionType(self):

        localctx = govdslParser.DecisionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_decisionType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.match(govdslParser.T__31)
            self.state = 281
            self.match(govdslParser.T__32)
            self.state = 285
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 282
                self.booleanDecision()
                pass
            elif token in [35]:
                self.state = 283
                self.stringList()
                pass
            elif token in [36]:
                self.state = 284
                self.elementList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanDecision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDecision" ):
                listener.enterBooleanDecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDecision" ):
                listener.exitBooleanDecision(self)




    def booleanDecision(self):

        localctx = govdslParser.BooleanDecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_booleanDecision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.match(govdslParser.T__33)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_stringList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringList" ):
                listener.enterStringList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringList" ):
                listener.exitStringList(self)




    def stringList(self):

        localctx = govdslParser.StringListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_stringList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            self.match(govdslParser.T__34)
            self.state = 290
            self.match(govdslParser.T__10)
            self.state = 291
            self.match(govdslParser.ID)
            self.state = 296
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 292
                self.match(govdslParser.T__30)
                self.state = 293
                self.match(govdslParser.ID)
                self.state = 298
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_elementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementList" ):
                listener.enterElementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementList" ):
                listener.exitElementList(self)




    def elementList(self):

        localctx = govdslParser.ElementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_elementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self.match(govdslParser.T__35)
            self.state = 300
            self.match(govdslParser.T__10)
            self.state = 301
            self.match(govdslParser.ID)
            self.state = 306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 302
                self.match(govdslParser.T__30)
                self.state = 303
                self.match(govdslParser.ID)
                self.state = 308
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self):
            return self.getTypedRuleContext(govdslParser.RolesContext,0)


        def individuals(self):
            return self.getTypedRuleContext(govdslParser.IndividualsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_participants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self.match(govdslParser.T__36)
            self.state = 310
            self.match(govdslParser.T__10)
            self.state = 319
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [39]:
                self.state = 311
                self.roles()
                self.state = 313
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==42:
                    self.state = 312
                    self.individuals()


                pass
            elif token in [42]:
                self.state = 315
                self.individuals()
                self.state = 317
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==39:
                    self.state = 316
                    self.roles()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def partID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PartIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.PartIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_policyParticipants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyParticipants" ):
                listener.enterPolicyParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyParticipants" ):
                listener.exitPolicyParticipants(self)




    def policyParticipants(self):

        localctx = govdslParser.PolicyParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_policyParticipants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 321
            self.match(govdslParser.T__37)
            self.state = 322
            self.match(govdslParser.T__10)
            self.state = 323
            self.partID()
            self.state = 328
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 324
                self.match(govdslParser.T__30)
                self.state = 325
                self.partID()
                self.state = 330
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_partID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartID" ):
                listener.enterPartID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartID" ):
                listener.exitPartID(self)




    def partID(self):

        localctx = govdslParser.PartIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_partID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 331
            self.match(govdslParser.ID)
            self.state = 333
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 332
                self.hasRole()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roleID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.RoleIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.RoleIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 335
            self.match(govdslParser.T__38)
            self.state = 336
            self.match(govdslParser.T__10)
            self.state = 337
            self.roleID()
            self.state = 342
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==40:
                self.state = 338
                self.match(govdslParser.T__39)
                self.state = 339
                self.roleID()
                self.state = 344
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roleID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleID" ):
                listener.enterRoleID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleID" ):
                listener.exitRoleID(self)




    def roleID(self):

        localctx = govdslParser.RoleIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_roleID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 345
            self.match(govdslParser.ID)
            self.state = 356
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 346
                self.match(govdslParser.T__40)
                self.state = 347
                self.match(govdslParser.T__10)
                self.state = 348
                self.participantID()
                self.state = 353
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==31:
                    self.state = 349
                    self.match(govdslParser.T__30)
                    self.state = 350
                    self.participantID()
                    self.state = 355
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_participantID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantID" ):
                listener.enterParticipantID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantID" ):
                listener.exitParticipantID(self)




    def participantID(self):

        localctx = govdslParser.ParticipantIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_participantID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individualEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualEntryContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualEntryContext,i)


        def include(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IncludeContext)
            else:
                return self.getTypedRuleContext(govdslParser.IncludeContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.match(govdslParser.T__41)
            self.state = 361
            self.match(govdslParser.T__10)
            self.state = 362
            self.individualEntry()
            self.state = 370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 363
                self.match(govdslParser.T__30)
                self.state = 365
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43 or _la==44:
                    self.state = 364
                    self.include()


                self.state = 367
                self.individualEntry()
                self.state = 372
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_include

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude" ):
                listener.enterInclude(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude" ):
                listener.exitInclude(self)




    def include(self):

        localctx = govdslParser.IncludeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_include)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            _la = self._input.LA(1)
            if not(_la==43 or _la==44):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individual(self):
            return self.getTypedRuleContext(govdslParser.IndividualContext,0)


        def agent(self):
            return self.getTypedRuleContext(govdslParser.AgentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individualEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividualEntry" ):
                listener.enterIndividualEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividualEntry" ):
                listener.exitIndividualEntry(self)




    def individualEntry(self):

        localctx = govdslParser.IndividualEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_individualEntry)
        try:
            self.state = 377
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [74]:
                self.enterOuterAlt(localctx, 1)
                self.state = 375
                self.individual()
                pass
            elif token in [46]:
                self.enterOuterAlt(localctx, 2)
                self.state = 376
                self.agent()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividual" ):
                listener.enterIndividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividual" ):
                listener.exitIndividual(self)




    def individual(self):

        localctx = govdslParser.IndividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_individual)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 379
            self.participantID()
            self.state = 381
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 380
                self.voteValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.match(govdslParser.T__32)
            self.state = 384
            self.participantID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoteValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_voteValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoteValue" ):
                listener.enterVoteValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoteValue" ):
                listener.exitVoteValue(self)




    def voteValue(self):

        localctx = govdslParser.VoteValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_voteValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 386
            self.match(govdslParser.T__44)
            self.state = 387
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AgentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def confidence(self):
            return self.getTypedRuleContext(govdslParser.ConfidenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_agent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent" ):
                listener.enterAgent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent" ):
                listener.exitAgent(self)




    def agent(self):

        localctx = govdslParser.AgentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_agent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 389
            self.match(govdslParser.T__45)
            self.state = 390
            self.participantID()
            self.state = 392
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 391
                self.voteValue()


            self.state = 395
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==47:
                self.state = 394
                self.confidence()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfidenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_confidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfidence" ):
                listener.enterConfidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfidence" ):
                listener.exitConfidence(self)




    def confidence(self):

        localctx = govdslParser.ConfidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_confidence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            self.match(govdslParser.T__46)
            self.state = 398
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def participantExclusion(self):
            return self.getTypedRuleContext(govdslParser.ParticipantExclusionContext,0)


        def minParticipant(self):
            return self.getTypedRuleContext(govdslParser.MinParticipantContext,0)


        def vetoRight(self):
            return self.getTypedRuleContext(govdslParser.VetoRightContext,0)


        def passedTests(self):
            return self.getTypedRuleContext(govdslParser.PassedTestsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 400
            self.match(govdslParser.T__47)
            self.state = 401
            self.match(govdslParser.T__10)
            self.state = 403
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 402
                self.deadline()


            self.state = 406
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==54:
                self.state = 405
                self.participantExclusion()


            self.state = 409
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==55:
                self.state = 408
                self.minParticipant()


            self.state = 412
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56:
                self.state = 411
                self.vetoRight()


            self.state = 415
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==57:
                self.state = 414
                self.passedTests()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_deadline)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 417
            self.match(govdslParser.T__48)
            self.state = 418
            self.deadlineID()
            self.state = 419
            self.match(govdslParser.T__10)
            self.state = 426
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                self.state = 420
                self.offset()
                pass

            elif la_ == 2:
                self.state = 421
                self.date()
                pass

            elif la_ == 3:
                self.state = 422
                self.offset()
                self.state = 423
                self.match(govdslParser.T__30)
                self.state = 424
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 428
            self.match(govdslParser.SIGNED_INT)
            self.state = 429
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 431
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 16888498602639360) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 435
            self.match(govdslParser.SIGNED_INT)
            self.state = 436
            self.match(govdslParser.T__16)
            self.state = 437
            self.match(govdslParser.SIGNED_INT)
            self.state = 438
            self.match(govdslParser.T__16)
            self.state = 439
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_participantExclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantExclusion" ):
                listener.enterParticipantExclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantExclusion" ):
                listener.exitParticipantExclusion(self)




    def participantExclusion(self):

        localctx = govdslParser.ParticipantExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_participantExclusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self.match(govdslParser.T__53)
            self.state = 442
            self.match(govdslParser.T__10)
            self.state = 443
            self.participantID()
            self.state = 448
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 444
                self.match(govdslParser.T__30)
                self.state = 445
                self.participantID()
                self.state = 450
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinParticipantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minParticipant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinParticipant" ):
                listener.enterMinParticipant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinParticipant" ):
                listener.exitMinParticipant(self)




    def minParticipant(self):

        localctx = govdslParser.MinParticipantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_minParticipant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 451
            self.match(govdslParser.T__54)
            self.state = 452
            self.match(govdslParser.T__10)
            self.state = 453
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VetoRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_vetoRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVetoRight" ):
                listener.enterVetoRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVetoRight" ):
                listener.exitVetoRight(self)




    def vetoRight(self):

        localctx = govdslParser.VetoRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_vetoRight)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 455
            self.match(govdslParser.T__55)
            self.state = 456
            self.match(govdslParser.T__10)
            self.state = 457
            self.participantID()
            self.state = 462
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 458
                self.match(govdslParser.T__30)
                self.state = 459
                self.participantID()
                self.state = 464
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PassedTestsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_passedTests

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPassedTests" ):
                listener.enterPassedTests(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPassedTests" ):
                listener.exitPassedTests(self)




    def passedTests(self):

        localctx = govdslParser.PassedTestsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_passedTests)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 465
            self.match(govdslParser.T__56)
            self.state = 467
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2017612633061982208) != 0):
                self.state = 466
                self.evaluationMode()


            self.state = 469
            self.match(govdslParser.T__10)
            self.state = 470
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EvaluationModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_evaluationMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvaluationMode" ):
                listener.enterEvaluationMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvaluationMode" ):
                listener.exitEvaluationMode(self)




    def evaluationMode(self):

        localctx = govdslParser.EvaluationModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_evaluationMode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2017612633061982208) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def include(self):
            return self.getTypedRuleContext(govdslParser.IncludeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_labelsCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelsCondition" ):
                listener.enterLabelsCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelsCondition" ):
                listener.exitLabelsCondition(self)




    def labelsCondition(self):

        localctx = govdslParser.LabelsConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_labelsCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 474
            self.match(govdslParser.T__60)
            self.state = 476
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2017612633061982208) != 0):
                self.state = 475
                self.evaluationMode()


            self.state = 479
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==43 or _la==44:
                self.state = 478
                self.include()


            self.state = 481
            self.match(govdslParser.T__10)
            self.state = 482
            self.match(govdslParser.ID)
            self.state = 487
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 483
                self.match(govdslParser.T__30)
                self.state = 484
                self.match(govdslParser.ID)
                self.state = 489
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 490
            self.match(govdslParser.T__61)
            self.state = 491
            self.match(govdslParser.T__10)
            self.state = 494
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [63]:
                self.state = 492
                self.votParams()
                pass
            elif token in [64]:
                self.state = 493
                self.default()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_votParams)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 496
            self.ratio()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 498
            self.match(govdslParser.T__62)
            self.state = 499
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 501
            self.match(govdslParser.T__63)
            self.state = 502
            self.nestedPolicy()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def carryOver(self):
            return self.getTypedRuleContext(govdslParser.CarryOverContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            self.match(govdslParser.T__64)
            self.state = 505
            self.match(govdslParser.T__10)

            self.state = 506
            self.orderType()
            self.state = 507
            self.orderMode()
            self.state = 509
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==70:
                self.state = 508
                self.carryOver()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderTypeValue(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_orderType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 511
            self.match(govdslParser.T__65)
            self.state = 512
            self.match(govdslParser.T__10)
            self.state = 513
            self.orderTypeValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderTypeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderTypeValue" ):
                listener.enterOrderTypeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderTypeValue" ):
                listener.exitOrderTypeValue(self)




    def orderTypeValue(self):

        localctx = govdslParser.OrderTypeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_orderTypeValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            _la = self._input.LA(1)
            if not(_la==67 or _la==68):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_orderMode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 517
            self.match(govdslParser.T__68)
            self.state = 518
            self.match(govdslParser.T__10)
            self.state = 519
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CarryOverContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_carryOver

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCarryOver" ):
                listener.enterCarryOver(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCarryOver" ):
                listener.exitCarryOver(self)




    def carryOver(self):

        localctx = govdslParser.CarryOverContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_carryOver)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 521
            self.match(govdslParser.T__69)
            self.state = 522
            self.match(govdslParser.T__10)
            self.state = 523
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = govdslParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 525
            _la = self._input.LA(1)
            if not(_la==71 or _la==72):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.NestedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.NestedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 527
            self.match(govdslParser.T__72)
            self.state = 528
            self.match(govdslParser.T__0)
            self.state = 530 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 529
                self.nestedPolicy()
                self.state = 532 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 534
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedSinglePolicyContext,0)


        def nestedComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPolicy" ):
                listener.enterNestedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPolicy" ):
                listener.exitNestedPolicy(self)




    def nestedPolicy(self):

        localctx = govdslParser.NestedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_nestedPolicy)
        try:
            self.state = 538
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 536
                self.nestedSinglePolicy()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 537
                self.nestedComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





