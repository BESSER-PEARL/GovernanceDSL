# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,93,774,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,65,
        2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,72,
        7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,78,
        2,79,7,79,2,80,7,80,1,0,1,0,1,0,4,0,166,8,0,11,0,12,0,167,1,0,1,
        0,1,1,1,1,3,1,174,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,183,8,2,1,
        2,3,2,186,8,2,1,2,3,2,189,8,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,3,3,198,
        8,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,4,1,4,3,4,209,8,4,1,4,3,4,212,
        8,4,1,4,3,4,215,8,4,1,4,1,4,1,5,1,5,1,5,1,5,3,5,223,8,5,1,5,1,5,
        1,5,1,6,1,6,1,7,1,7,1,7,1,7,1,7,4,7,235,8,7,11,7,12,7,236,1,8,1,
        8,1,8,1,8,1,9,1,9,1,9,4,9,246,8,9,11,9,12,9,247,1,10,1,10,1,10,1,
        10,1,10,1,10,3,10,256,8,10,1,10,1,10,1,10,1,10,4,10,262,8,10,11,
        10,12,10,263,1,10,1,10,3,10,268,8,10,1,11,1,11,1,12,1,12,1,13,1,
        13,1,13,4,13,277,8,13,11,13,12,13,278,1,14,1,14,1,14,1,14,1,14,4,
        14,286,8,14,11,14,12,14,287,1,14,1,14,3,14,292,8,14,1,15,1,15,1,
        15,4,15,297,8,15,11,15,12,15,298,1,16,1,16,1,16,3,16,304,8,16,1,
        16,1,16,1,16,1,16,3,16,310,8,16,1,17,1,17,1,18,1,18,1,18,3,18,317,
        8,18,1,19,1,19,1,19,1,20,1,20,1,20,1,20,1,21,1,21,1,22,1,22,1,22,
        1,22,1,23,1,23,1,24,1,24,1,24,1,24,1,24,5,24,339,8,24,10,24,12,24,
        342,9,24,1,25,1,25,1,25,1,25,1,25,3,25,349,8,25,1,26,1,26,1,27,1,
        27,1,27,1,27,1,27,5,27,358,8,27,10,27,12,27,361,9,27,1,28,1,28,1,
        28,1,28,1,28,5,28,368,8,28,10,28,12,28,371,9,28,1,29,1,29,1,29,1,
        29,1,30,1,30,1,30,1,30,1,30,4,30,382,8,30,11,30,12,30,383,1,31,1,
        31,1,31,1,31,1,31,5,31,391,8,31,10,31,12,31,394,9,31,1,32,1,32,1,
        32,3,32,399,8,32,1,32,3,32,402,8,32,1,33,1,33,1,33,1,33,3,33,408,
        8,33,1,33,5,33,411,8,33,10,33,12,33,414,9,33,1,34,1,34,3,34,418,
        8,34,1,35,1,35,1,35,3,35,423,8,35,1,35,3,35,426,8,35,1,35,3,35,429,
        8,35,1,35,3,35,432,8,35,1,35,3,35,435,8,35,1,35,3,35,438,8,35,1,
        36,1,36,1,36,1,36,1,37,1,37,1,37,1,37,1,38,1,38,1,38,1,38,1,39,1,
        39,1,39,1,39,3,39,456,8,39,1,39,3,39,459,8,39,1,39,3,39,462,8,39,
        1,39,3,39,465,8,39,1,39,3,39,468,8,39,1,39,3,39,471,8,39,1,39,3,
        39,474,8,39,1,39,3,39,477,8,39,1,39,3,39,480,8,39,1,39,3,39,483,
        8,39,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,1,42,1,42,1,42,1,42,
        1,43,1,43,1,43,1,43,3,43,501,8,43,1,43,5,43,504,8,43,10,43,12,43,
        507,9,43,1,44,1,44,1,44,1,44,3,44,513,8,44,1,44,3,44,516,8,44,1,
        44,1,44,3,44,520,8,44,1,44,3,44,523,8,44,3,44,525,8,44,1,44,1,44,
        1,45,1,45,1,45,1,45,1,46,1,46,1,46,1,46,1,47,1,47,1,47,1,47,1,47,
        5,47,542,8,47,10,47,12,47,545,9,47,1,48,1,48,3,48,549,8,48,1,49,
        1,49,1,49,1,50,1,50,1,50,3,50,557,8,50,1,50,3,50,560,8,50,1,50,3,
        50,563,8,50,1,50,3,50,566,8,50,1,50,3,50,569,8,50,1,50,3,50,572,
        8,50,1,50,3,50,575,8,50,1,50,3,50,578,8,50,1,50,5,50,581,8,50,10,
        50,12,50,584,9,50,1,51,1,51,3,51,588,8,51,1,51,1,51,1,51,1,51,1,
        51,1,51,1,51,3,51,597,8,51,1,52,1,52,3,52,601,8,52,1,52,1,52,1,52,
        1,52,1,52,1,52,1,52,3,52,610,8,52,1,53,1,53,1,53,1,54,1,54,1,55,
        1,55,1,56,1,56,1,56,1,56,1,56,1,56,1,57,1,57,1,57,1,57,1,57,5,57,
        630,8,57,10,57,12,57,633,9,57,1,58,1,58,1,58,1,58,1,59,1,59,1,59,
        1,59,1,59,5,59,644,8,59,10,59,12,59,647,9,59,1,60,1,60,1,60,1,60,
        1,60,1,60,1,60,1,60,5,60,657,8,60,10,60,12,60,660,9,60,1,60,3,60,
        663,8,60,1,60,1,60,1,60,1,60,3,60,669,8,60,1,60,1,60,1,61,1,61,3,
        61,675,8,61,1,61,1,61,1,61,1,62,1,62,3,62,682,8,62,1,62,1,62,1,62,
        1,62,1,62,1,63,1,63,1,64,1,64,1,65,1,65,3,65,695,8,65,1,65,3,65,
        698,8,65,1,65,1,65,1,65,1,65,5,65,704,8,65,10,65,12,65,707,9,65,
        1,66,1,66,1,67,1,67,1,67,1,67,1,67,3,67,716,8,67,1,68,1,68,1,69,
        1,69,1,69,1,69,1,70,1,70,1,70,1,70,3,70,728,8,70,1,71,1,71,1,71,
        1,71,3,71,734,8,71,1,72,1,72,1,73,1,73,1,73,1,73,1,73,3,73,743,8,
        73,1,74,1,74,1,74,1,74,1,75,1,75,1,76,1,76,1,76,1,76,1,77,1,77,1,
        77,1,77,1,78,1,78,1,79,1,79,1,79,4,79,764,8,79,11,79,12,79,765,1,
        79,1,79,1,80,1,80,3,80,772,8,80,1,80,0,0,81,0,2,4,6,8,10,12,14,16,
        18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,
        62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,
        104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,
        136,138,140,142,144,146,148,150,152,154,156,158,160,0,11,1,0,4,9,
        1,0,16,17,1,0,19,21,1,0,23,25,1,0,27,29,1,0,55,58,1,0,69,70,1,0,
        71,73,1,0,75,76,1,0,83,84,1,0,87,88,788,0,162,1,0,0,0,2,173,1,0,
        0,0,4,175,1,0,0,0,6,192,1,0,0,0,8,202,1,0,0,0,10,218,1,0,0,0,12,
        227,1,0,0,0,14,229,1,0,0,0,16,238,1,0,0,0,18,242,1,0,0,0,20,249,
        1,0,0,0,22,269,1,0,0,0,24,271,1,0,0,0,26,273,1,0,0,0,28,280,1,0,
        0,0,30,293,1,0,0,0,32,300,1,0,0,0,34,311,1,0,0,0,36,316,1,0,0,0,
        38,318,1,0,0,0,40,321,1,0,0,0,42,325,1,0,0,0,44,327,1,0,0,0,46,331,
        1,0,0,0,48,333,1,0,0,0,50,343,1,0,0,0,52,350,1,0,0,0,54,352,1,0,
        0,0,56,362,1,0,0,0,58,372,1,0,0,0,60,376,1,0,0,0,62,385,1,0,0,0,
        64,395,1,0,0,0,66,403,1,0,0,0,68,417,1,0,0,0,70,419,1,0,0,0,72,439,
        1,0,0,0,74,443,1,0,0,0,76,447,1,0,0,0,78,451,1,0,0,0,80,484,1,0,
        0,0,82,488,1,0,0,0,84,492,1,0,0,0,86,496,1,0,0,0,88,508,1,0,0,0,
        90,528,1,0,0,0,92,532,1,0,0,0,94,536,1,0,0,0,96,546,1,0,0,0,98,550,
        1,0,0,0,100,553,1,0,0,0,102,585,1,0,0,0,104,598,1,0,0,0,106,611,
        1,0,0,0,108,614,1,0,0,0,110,616,1,0,0,0,112,618,1,0,0,0,114,624,
        1,0,0,0,116,634,1,0,0,0,118,638,1,0,0,0,120,648,1,0,0,0,122,672,
        1,0,0,0,124,679,1,0,0,0,126,688,1,0,0,0,128,690,1,0,0,0,130,692,
        1,0,0,0,132,708,1,0,0,0,134,710,1,0,0,0,136,717,1,0,0,0,138,719,
        1,0,0,0,140,723,1,0,0,0,142,729,1,0,0,0,144,735,1,0,0,0,146,737,
        1,0,0,0,148,744,1,0,0,0,150,748,1,0,0,0,152,750,1,0,0,0,154,754,
        1,0,0,0,156,758,1,0,0,0,158,760,1,0,0,0,160,771,1,0,0,0,162,163,
        3,14,7,0,163,165,3,60,30,0,164,166,3,2,1,0,165,164,1,0,0,0,166,167,
        1,0,0,0,167,165,1,0,0,0,167,168,1,0,0,0,168,169,1,0,0,0,169,170,
        5,0,0,1,170,1,1,0,0,0,171,174,3,4,2,0,172,174,3,6,3,0,173,171,1,
        0,0,0,173,172,1,0,0,0,174,3,1,0,0,0,175,176,3,12,6,0,176,177,5,90,
        0,0,177,178,5,1,0,0,178,179,3,16,8,0,179,180,3,50,25,0,180,182,3,
        94,47,0,181,183,3,58,29,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,
        1,0,0,0,184,186,3,100,50,0,185,184,1,0,0,0,185,186,1,0,0,0,186,188,
        1,0,0,0,187,189,3,134,67,0,188,187,1,0,0,0,188,189,1,0,0,0,189,190,
        1,0,0,0,190,191,5,2,0,0,191,5,1,0,0,0,192,193,5,3,0,0,193,194,5,
        90,0,0,194,195,5,1,0,0,195,197,3,16,8,0,196,198,3,146,73,0,197,196,
        1,0,0,0,197,198,1,0,0,0,198,199,1,0,0,0,199,200,3,158,79,0,200,201,
        5,2,0,0,201,7,1,0,0,0,202,203,3,12,6,0,203,204,5,90,0,0,204,205,
        5,1,0,0,205,206,3,50,25,0,206,208,3,94,47,0,207,209,3,58,29,0,208,
        207,1,0,0,0,208,209,1,0,0,0,209,211,1,0,0,0,210,212,3,100,50,0,211,
        210,1,0,0,0,211,212,1,0,0,0,212,214,1,0,0,0,213,215,3,134,67,0,214,
        213,1,0,0,0,214,215,1,0,0,0,215,216,1,0,0,0,216,217,5,2,0,0,217,
        9,1,0,0,0,218,219,5,3,0,0,219,220,5,90,0,0,220,222,5,1,0,0,221,223,
        3,146,73,0,222,221,1,0,0,0,222,223,1,0,0,0,223,224,1,0,0,0,224,225,
        3,158,79,0,225,226,5,2,0,0,226,11,1,0,0,0,227,228,7,0,0,0,228,13,
        1,0,0,0,229,230,5,10,0,0,230,234,5,11,0,0,231,235,3,18,9,0,232,235,
        3,26,13,0,233,235,3,30,15,0,234,231,1,0,0,0,234,232,1,0,0,0,234,
        233,1,0,0,0,235,236,1,0,0,0,236,234,1,0,0,0,236,237,1,0,0,0,237,
        15,1,0,0,0,238,239,5,12,0,0,239,240,5,11,0,0,240,241,5,90,0,0,241,
        17,1,0,0,0,242,243,5,13,0,0,243,245,5,11,0,0,244,246,3,20,10,0,245,
        244,1,0,0,0,246,247,1,0,0,0,247,245,1,0,0,0,247,248,1,0,0,0,248,
        19,1,0,0,0,249,255,5,90,0,0,250,251,5,14,0,0,251,252,3,22,11,0,252,
        253,5,11,0,0,253,254,3,24,12,0,254,256,1,0,0,0,255,250,1,0,0,0,255,
        256,1,0,0,0,256,267,1,0,0,0,257,258,5,1,0,0,258,259,5,15,0,0,259,
        261,5,11,0,0,260,262,3,28,14,0,261,260,1,0,0,0,262,263,1,0,0,0,263,
        261,1,0,0,0,263,264,1,0,0,0,264,265,1,0,0,0,265,266,5,2,0,0,266,
        268,1,0,0,0,267,257,1,0,0,0,267,268,1,0,0,0,268,21,1,0,0,0,269,270,
        7,1,0,0,270,23,1,0,0,0,271,272,5,90,0,0,272,25,1,0,0,0,273,274,5,
        15,0,0,274,276,5,11,0,0,275,277,3,28,14,0,276,275,1,0,0,0,277,278,
        1,0,0,0,278,276,1,0,0,0,278,279,1,0,0,0,279,27,1,0,0,0,280,291,5,
        90,0,0,281,282,5,1,0,0,282,283,5,18,0,0,283,285,5,11,0,0,284,286,
        3,32,16,0,285,284,1,0,0,0,286,287,1,0,0,0,287,285,1,0,0,0,287,288,
        1,0,0,0,288,289,1,0,0,0,289,290,5,2,0,0,290,292,1,0,0,0,291,281,
        1,0,0,0,291,292,1,0,0,0,292,29,1,0,0,0,293,294,5,18,0,0,294,296,
        5,11,0,0,295,297,3,32,16,0,296,295,1,0,0,0,297,298,1,0,0,0,298,296,
        1,0,0,0,298,299,1,0,0,0,299,31,1,0,0,0,300,303,5,90,0,0,301,302,
        5,11,0,0,302,304,3,34,17,0,303,301,1,0,0,0,303,304,1,0,0,0,304,309,
        1,0,0,0,305,306,5,1,0,0,306,307,3,36,18,0,307,308,5,2,0,0,308,310,
        1,0,0,0,309,305,1,0,0,0,309,310,1,0,0,0,310,33,1,0,0,0,311,312,7,
        2,0,0,312,35,1,0,0,0,313,317,3,40,20,0,314,317,3,44,22,0,315,317,
        3,38,19,0,316,313,1,0,0,0,316,314,1,0,0,0,316,315,1,0,0,0,317,37,
        1,0,0,0,318,319,3,44,22,0,319,320,3,48,24,0,320,39,1,0,0,0,321,322,
        5,22,0,0,322,323,5,11,0,0,323,324,3,42,21,0,324,41,1,0,0,0,325,326,
        7,3,0,0,326,43,1,0,0,0,327,328,5,26,0,0,328,329,5,11,0,0,329,330,
        3,46,23,0,330,45,1,0,0,0,331,332,7,4,0,0,332,47,1,0,0,0,333,334,
        5,30,0,0,334,335,5,11,0,0,335,340,5,90,0,0,336,337,5,31,0,0,337,
        339,5,90,0,0,338,336,1,0,0,0,339,342,1,0,0,0,340,338,1,0,0,0,340,
        341,1,0,0,0,341,49,1,0,0,0,342,340,1,0,0,0,343,344,5,32,0,0,344,
        348,5,33,0,0,345,349,3,52,26,0,346,349,3,54,27,0,347,349,3,56,28,
        0,348,345,1,0,0,0,348,346,1,0,0,0,348,347,1,0,0,0,349,51,1,0,0,0,
        350,351,5,34,0,0,351,53,1,0,0,0,352,353,5,35,0,0,353,354,5,11,0,
        0,354,359,5,90,0,0,355,356,5,31,0,0,356,358,5,90,0,0,357,355,1,0,
        0,0,358,361,1,0,0,0,359,357,1,0,0,0,359,360,1,0,0,0,360,55,1,0,0,
        0,361,359,1,0,0,0,362,363,5,36,0,0,363,364,5,11,0,0,364,369,5,90,
        0,0,365,366,5,31,0,0,366,368,5,90,0,0,367,365,1,0,0,0,368,371,1,
        0,0,0,369,367,1,0,0,0,369,370,1,0,0,0,370,57,1,0,0,0,371,369,1,0,
        0,0,372,373,5,37,0,0,373,374,5,11,0,0,374,375,5,90,0,0,375,59,1,
        0,0,0,376,377,5,38,0,0,377,381,5,11,0,0,378,382,3,62,31,0,379,382,
        3,66,33,0,380,382,3,86,43,0,381,378,1,0,0,0,381,379,1,0,0,0,381,
        380,1,0,0,0,382,383,1,0,0,0,383,381,1,0,0,0,383,384,1,0,0,0,384,
        61,1,0,0,0,385,386,5,39,0,0,386,387,5,11,0,0,387,392,3,64,32,0,388,
        389,5,31,0,0,389,391,3,64,32,0,390,388,1,0,0,0,391,394,1,0,0,0,392,
        390,1,0,0,0,392,393,1,0,0,0,393,63,1,0,0,0,394,392,1,0,0,0,395,401,
        5,90,0,0,396,398,5,1,0,0,397,399,3,72,36,0,398,397,1,0,0,0,398,399,
        1,0,0,0,399,400,1,0,0,0,400,402,5,2,0,0,401,396,1,0,0,0,401,402,
        1,0,0,0,402,65,1,0,0,0,403,404,5,40,0,0,404,405,5,11,0,0,405,412,
        3,68,34,0,406,408,5,31,0,0,407,406,1,0,0,0,407,408,1,0,0,0,408,409,
        1,0,0,0,409,411,3,68,34,0,410,407,1,0,0,0,411,414,1,0,0,0,412,410,
        1,0,0,0,412,413,1,0,0,0,413,67,1,0,0,0,414,412,1,0,0,0,415,418,3,
        70,35,0,416,418,3,78,39,0,417,415,1,0,0,0,417,416,1,0,0,0,418,69,
        1,0,0,0,419,437,5,90,0,0,420,422,5,1,0,0,421,423,3,72,36,0,422,421,
        1,0,0,0,422,423,1,0,0,0,423,425,1,0,0,0,424,426,5,31,0,0,425,424,
        1,0,0,0,425,426,1,0,0,0,426,428,1,0,0,0,427,429,3,74,37,0,428,427,
        1,0,0,0,428,429,1,0,0,0,429,431,1,0,0,0,430,432,5,31,0,0,431,430,
        1,0,0,0,431,432,1,0,0,0,432,434,1,0,0,0,433,435,3,76,38,0,434,433,
        1,0,0,0,434,435,1,0,0,0,435,436,1,0,0,0,436,438,5,2,0,0,437,420,
        1,0,0,0,437,438,1,0,0,0,438,71,1,0,0,0,439,440,5,41,0,0,440,441,
        5,11,0,0,441,442,5,92,0,0,442,73,1,0,0,0,443,444,5,42,0,0,444,445,
        5,11,0,0,445,446,5,90,0,0,446,75,1,0,0,0,447,448,5,43,0,0,448,449,
        5,11,0,0,449,450,5,90,0,0,450,77,1,0,0,0,451,452,5,44,0,0,452,482,
        5,90,0,0,453,455,5,1,0,0,454,456,3,72,36,0,455,454,1,0,0,0,455,456,
        1,0,0,0,456,458,1,0,0,0,457,459,5,31,0,0,458,457,1,0,0,0,458,459,
        1,0,0,0,459,461,1,0,0,0,460,462,3,80,40,0,461,460,1,0,0,0,461,462,
        1,0,0,0,462,464,1,0,0,0,463,465,5,31,0,0,464,463,1,0,0,0,464,465,
        1,0,0,0,465,467,1,0,0,0,466,468,3,82,41,0,467,466,1,0,0,0,467,468,
        1,0,0,0,468,470,1,0,0,0,469,471,5,31,0,0,470,469,1,0,0,0,470,471,
        1,0,0,0,471,473,1,0,0,0,472,474,3,84,42,0,473,472,1,0,0,0,473,474,
        1,0,0,0,474,476,1,0,0,0,475,477,5,31,0,0,476,475,1,0,0,0,476,477,
        1,0,0,0,477,479,1,0,0,0,478,480,3,76,38,0,479,478,1,0,0,0,479,480,
        1,0,0,0,480,481,1,0,0,0,481,483,5,2,0,0,482,453,1,0,0,0,482,483,
        1,0,0,0,483,79,1,0,0,0,484,485,5,45,0,0,485,486,5,11,0,0,486,487,
        5,92,0,0,487,81,1,0,0,0,488,489,5,46,0,0,489,490,5,11,0,0,490,491,
        5,92,0,0,491,83,1,0,0,0,492,493,5,47,0,0,493,494,5,11,0,0,494,495,
        5,92,0,0,495,85,1,0,0,0,496,497,5,48,0,0,497,498,5,11,0,0,498,505,
        3,88,44,0,499,501,5,31,0,0,500,499,1,0,0,0,500,501,1,0,0,0,501,502,
        1,0,0,0,502,504,3,88,44,0,503,500,1,0,0,0,504,507,1,0,0,0,505,503,
        1,0,0,0,505,506,1,0,0,0,506,87,1,0,0,0,507,505,1,0,0,0,508,509,5,
        90,0,0,509,524,5,1,0,0,510,512,3,90,45,0,511,513,5,31,0,0,512,511,
        1,0,0,0,512,513,1,0,0,0,513,515,1,0,0,0,514,516,3,92,46,0,515,514,
        1,0,0,0,515,516,1,0,0,0,516,525,1,0,0,0,517,519,3,92,46,0,518,520,
        5,31,0,0,519,518,1,0,0,0,519,520,1,0,0,0,520,522,1,0,0,0,521,523,
        3,90,45,0,522,521,1,0,0,0,522,523,1,0,0,0,523,525,1,0,0,0,524,510,
        1,0,0,0,524,517,1,0,0,0,525,526,1,0,0,0,526,527,5,2,0,0,527,89,1,
        0,0,0,528,529,5,49,0,0,529,530,5,11,0,0,530,531,5,90,0,0,531,91,
        1,0,0,0,532,533,5,50,0,0,533,534,5,11,0,0,534,535,5,90,0,0,535,93,
        1,0,0,0,536,537,5,51,0,0,537,538,5,11,0,0,538,543,3,96,48,0,539,
        540,5,31,0,0,540,542,3,96,48,0,541,539,1,0,0,0,542,545,1,0,0,0,543,
        541,1,0,0,0,543,544,1,0,0,0,544,95,1,0,0,0,545,543,1,0,0,0,546,548,
        5,90,0,0,547,549,3,98,49,0,548,547,1,0,0,0,548,549,1,0,0,0,549,97,
        1,0,0,0,550,551,5,33,0,0,551,552,5,90,0,0,552,99,1,0,0,0,553,554,
        5,52,0,0,554,556,5,11,0,0,555,557,3,102,51,0,556,555,1,0,0,0,556,
        557,1,0,0,0,557,559,1,0,0,0,558,560,3,104,52,0,559,558,1,0,0,0,559,
        560,1,0,0,0,560,562,1,0,0,0,561,563,3,114,57,0,562,561,1,0,0,0,562,
        563,1,0,0,0,563,565,1,0,0,0,564,566,3,116,58,0,565,564,1,0,0,0,565,
        566,1,0,0,0,566,568,1,0,0,0,567,569,3,118,59,0,568,567,1,0,0,0,568,
        569,1,0,0,0,569,571,1,0,0,0,570,572,3,120,60,0,571,570,1,0,0,0,571,
        572,1,0,0,0,572,574,1,0,0,0,573,575,3,122,61,0,574,573,1,0,0,0,574,
        575,1,0,0,0,575,577,1,0,0,0,576,578,3,124,62,0,577,576,1,0,0,0,577,
        578,1,0,0,0,578,582,1,0,0,0,579,581,3,130,65,0,580,579,1,0,0,0,581,
        584,1,0,0,0,582,580,1,0,0,0,582,583,1,0,0,0,583,101,1,0,0,0,584,
        582,1,0,0,0,585,587,5,53,0,0,586,588,3,108,54,0,587,586,1,0,0,0,
        587,588,1,0,0,0,588,589,1,0,0,0,589,596,5,11,0,0,590,597,3,106,53,
        0,591,597,3,112,56,0,592,593,3,106,53,0,593,594,5,31,0,0,594,595,
        3,112,56,0,595,597,1,0,0,0,596,590,1,0,0,0,596,591,1,0,0,0,596,592,
        1,0,0,0,597,103,1,0,0,0,598,600,5,54,0,0,599,601,5,90,0,0,600,599,
        1,0,0,0,600,601,1,0,0,0,601,602,1,0,0,0,602,609,5,11,0,0,603,610,
        3,106,53,0,604,610,3,112,56,0,605,606,3,106,53,0,606,607,5,31,0,
        0,607,608,3,112,56,0,608,610,1,0,0,0,609,603,1,0,0,0,609,604,1,0,
        0,0,609,605,1,0,0,0,610,105,1,0,0,0,611,612,5,91,0,0,612,613,3,110,
        55,0,613,107,1,0,0,0,614,615,5,90,0,0,615,109,1,0,0,0,616,617,7,
        5,0,0,617,111,1,0,0,0,618,619,5,91,0,0,619,620,5,59,0,0,620,621,
        5,91,0,0,621,622,5,59,0,0,622,623,5,91,0,0,623,113,1,0,0,0,624,625,
        5,60,0,0,625,626,5,11,0,0,626,631,5,90,0,0,627,628,5,31,0,0,628,
        630,5,90,0,0,629,627,1,0,0,0,630,633,1,0,0,0,631,629,1,0,0,0,631,
        632,1,0,0,0,632,115,1,0,0,0,633,631,1,0,0,0,634,635,5,61,0,0,635,
        636,5,11,0,0,636,637,5,91,0,0,637,117,1,0,0,0,638,639,5,62,0,0,639,
        640,5,11,0,0,640,645,5,90,0,0,641,642,5,31,0,0,642,644,5,90,0,0,
        643,641,1,0,0,0,644,647,1,0,0,0,645,643,1,0,0,0,645,646,1,0,0,0,
        646,119,1,0,0,0,647,645,1,0,0,0,648,649,5,63,0,0,649,650,5,11,0,
        0,650,651,5,1,0,0,651,652,5,64,0,0,652,653,5,11,0,0,653,658,5,90,
        0,0,654,655,5,31,0,0,655,657,5,90,0,0,656,654,1,0,0,0,657,660,1,
        0,0,0,658,656,1,0,0,0,658,659,1,0,0,0,659,662,1,0,0,0,660,658,1,
        0,0,0,661,663,5,31,0,0,662,661,1,0,0,0,662,663,1,0,0,0,663,664,1,
        0,0,0,664,665,5,65,0,0,665,668,5,11,0,0,666,669,3,160,80,0,667,669,
        3,144,72,0,668,666,1,0,0,0,668,667,1,0,0,0,669,670,1,0,0,0,670,671,
        5,2,0,0,671,121,1,0,0,0,672,674,5,66,0,0,673,675,3,128,64,0,674,
        673,1,0,0,0,674,675,1,0,0,0,675,676,1,0,0,0,676,677,5,11,0,0,677,
        678,3,156,78,0,678,123,1,0,0,0,679,681,5,67,0,0,680,682,3,128,64,
        0,681,680,1,0,0,0,681,682,1,0,0,0,682,683,1,0,0,0,683,684,5,68,0,
        0,684,685,3,126,63,0,685,686,5,11,0,0,686,687,3,106,53,0,687,125,
        1,0,0,0,688,689,7,6,0,0,689,127,1,0,0,0,690,691,7,7,0,0,691,129,
        1,0,0,0,692,694,5,74,0,0,693,695,3,128,64,0,694,693,1,0,0,0,694,
        695,1,0,0,0,695,697,1,0,0,0,696,698,3,132,66,0,697,696,1,0,0,0,697,
        698,1,0,0,0,698,699,1,0,0,0,699,700,5,11,0,0,700,705,5,90,0,0,701,
        702,5,31,0,0,702,704,5,90,0,0,703,701,1,0,0,0,704,707,1,0,0,0,705,
        703,1,0,0,0,705,706,1,0,0,0,706,131,1,0,0,0,707,705,1,0,0,0,708,
        709,7,8,0,0,709,133,1,0,0,0,710,711,5,77,0,0,711,715,5,11,0,0,712,
        716,3,136,68,0,713,716,3,140,70,0,714,716,3,142,71,0,715,712,1,0,
        0,0,715,713,1,0,0,0,715,714,1,0,0,0,716,135,1,0,0,0,717,718,3,138,
        69,0,718,137,1,0,0,0,719,720,5,78,0,0,720,721,5,11,0,0,721,722,5,
        92,0,0,722,139,1,0,0,0,723,724,5,79,0,0,724,727,5,11,0,0,725,728,
        3,160,80,0,726,728,3,144,72,0,727,725,1,0,0,0,727,726,1,0,0,0,728,
        141,1,0,0,0,729,730,5,80,0,0,730,733,5,11,0,0,731,734,3,160,80,0,
        732,734,3,144,72,0,733,731,1,0,0,0,733,732,1,0,0,0,734,143,1,0,0,
        0,735,736,5,90,0,0,736,145,1,0,0,0,737,738,5,81,0,0,738,739,5,11,
        0,0,739,740,3,148,74,0,740,742,3,152,76,0,741,743,3,154,77,0,742,
        741,1,0,0,0,742,743,1,0,0,0,743,147,1,0,0,0,744,745,5,82,0,0,745,
        746,5,11,0,0,746,747,3,150,75,0,747,149,1,0,0,0,748,749,7,9,0,0,
        749,151,1,0,0,0,750,751,5,85,0,0,751,752,5,11,0,0,752,753,3,156,
        78,0,753,153,1,0,0,0,754,755,5,86,0,0,755,756,5,11,0,0,756,757,3,
        156,78,0,757,155,1,0,0,0,758,759,7,10,0,0,759,157,1,0,0,0,760,761,
        5,89,0,0,761,763,5,1,0,0,762,764,3,160,80,0,763,762,1,0,0,0,764,
        765,1,0,0,0,765,763,1,0,0,0,765,766,1,0,0,0,766,767,1,0,0,0,767,
        768,5,2,0,0,768,159,1,0,0,0,769,772,3,8,4,0,770,772,3,10,5,0,771,
        769,1,0,0,0,771,770,1,0,0,0,772,161,1,0,0,0,89,167,173,182,185,188,
        197,208,211,214,222,234,236,247,255,263,267,278,287,291,298,303,
        309,316,340,348,359,369,381,383,392,398,401,407,412,417,422,425,
        428,431,434,437,455,458,461,464,467,470,473,476,479,482,500,505,
        512,515,519,522,524,543,548,556,559,562,565,568,571,574,577,582,
        587,596,600,609,631,645,658,662,668,674,681,694,697,705,715,727,
        733,742,765,771
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'ComposedPolicy'", "'MajorityPolicy'", 
                     "'LeaderDrivenPolicy'", "'AbsoluteMajorityPolicy'", 
                     "'ConsensusPolicy'", "'LazyConsensusPolicy'", "'VotingPolicy'", 
                     "'Scopes'", "':'", "'Scope'", "'Projects'", "'from'", 
                     "'Activities'", "'GitHub'", "'GitLab'", "'Tasks'", 
                     "'Issue'", "'Pull request'", "'All'", "'Status'", "'completed'", 
                     "'accepted'", "'partial'", "'Action'", "'merge'", "'review'", 
                     "'release'", "'Labels'", "','", "'DecisionType'", "'as'", 
                     "'BooleanDecision'", "'StringList'", "'ElementList'", 
                     "'CommunicationChannel'", "'Participants'", "'Roles'", 
                     "'Individuals'", "'vote value'", "'profile'", "'role'", 
                     "'(Agent)'", "'confidence'", "'autonomy level'", "'explainability'", 
                     "'Profiles'", "'gender'", "'race'", "'Participant list'", 
                     "'Conditions'", "'Deadline'", "'MinDecisionTime'", 
                     "'days'", "'weeks'", "'months'", "'years'", "'/'", 
                     "'ParticipantExclusion'", "'MinParticipants'", "'VetoRight'", 
                     "'AppealRight'", "'Appealers'", "'Policy'", "'CheckCiCd'", 
                     "'MinTime'", "'of'", "'Activity'", "'InActivity'", 
                     "'pre'", "'post'", "'concurrent'", "'LabelCondition'", 
                     "'include'", "'not'", "'Parameters'", "'ratio'", "'default'", 
                     "'fallback'", "'Order'", "'Execution'", "'sequential'", 
                     "'parallel'", "'RequireAll'", "'CarryOver'", "'true'", 
                     "'false'", "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "ID", "SIGNED_INT", "FLOAT", 
                      "WS" ]

    RULE_governance = 0
    RULE_policy = 1
    RULE_topLevelSinglePolicy = 2
    RULE_topLevelComposedPolicy = 3
    RULE_nestedSinglePolicy = 4
    RULE_nestedComposedPolicy = 5
    RULE_policyType = 6
    RULE_scopes = 7
    RULE_scope = 8
    RULE_projects = 9
    RULE_project = 10
    RULE_platform = 11
    RULE_repoID = 12
    RULE_activities = 13
    RULE_activity = 14
    RULE_tasks = 15
    RULE_task = 16
    RULE_taskType = 17
    RULE_taskContent = 18
    RULE_actionWithLabels = 19
    RULE_status = 20
    RULE_statusEnum = 21
    RULE_action = 22
    RULE_actionEnum = 23
    RULE_labels = 24
    RULE_decisionType = 25
    RULE_booleanDecision = 26
    RULE_stringList = 27
    RULE_elementList = 28
    RULE_communicationChannel = 29
    RULE_participants = 30
    RULE_roles = 31
    RULE_role = 32
    RULE_individuals = 33
    RULE_individualEntry = 34
    RULE_individual = 35
    RULE_voteValue = 36
    RULE_withProfile = 37
    RULE_withRole = 38
    RULE_agent = 39
    RULE_confidence = 40
    RULE_autonomyLevel = 41
    RULE_explainability = 42
    RULE_profiles = 43
    RULE_profile = 44
    RULE_gender = 45
    RULE_race = 46
    RULE_policyParticipants = 47
    RULE_partID = 48
    RULE_hasRole = 49
    RULE_conditions = 50
    RULE_deadline = 51
    RULE_minDecisionTime = 52
    RULE_offset = 53
    RULE_deadlineID = 54
    RULE_timeUnit = 55
    RULE_date = 56
    RULE_participantExclusion = 57
    RULE_minParticipant = 58
    RULE_vetoRight = 59
    RULE_appealRight = 60
    RULE_checkCiCd = 61
    RULE_minTime = 62
    RULE_activityBool = 63
    RULE_evaluationMode = 64
    RULE_labelsCondition = 65
    RULE_include = 66
    RULE_parameters = 67
    RULE_votParams = 68
    RULE_ratio = 69
    RULE_default = 70
    RULE_fallback = 71
    RULE_policyReference = 72
    RULE_order = 73
    RULE_orderType = 74
    RULE_orderTypeValue = 75
    RULE_orderMode = 76
    RULE_carryOver = 77
    RULE_booleanValue = 78
    RULE_phases = 79
    RULE_nestedPolicy = 80

    ruleNames =  [ "governance", "policy", "topLevelSinglePolicy", "topLevelComposedPolicy", 
                   "nestedSinglePolicy", "nestedComposedPolicy", "policyType", 
                   "scopes", "scope", "projects", "project", "platform", 
                   "repoID", "activities", "activity", "tasks", "task", 
                   "taskType", "taskContent", "actionWithLabels", "status", 
                   "statusEnum", "action", "actionEnum", "labels", "decisionType", 
                   "booleanDecision", "stringList", "elementList", "communicationChannel", 
                   "participants", "roles", "role", "individuals", "individualEntry", 
                   "individual", "voteValue", "withProfile", "withRole", 
                   "agent", "confidence", "autonomyLevel", "explainability", 
                   "profiles", "profile", "gender", "race", "policyParticipants", 
                   "partID", "hasRole", "conditions", "deadline", "minDecisionTime", 
                   "offset", "deadlineID", "timeUnit", "date", "participantExclusion", 
                   "minParticipant", "vetoRight", "appealRight", "checkCiCd", 
                   "minTime", "activityBool", "evaluationMode", "labelsCondition", 
                   "include", "parameters", "votParams", "ratio", "default", 
                   "fallback", "policyReference", "order", "orderType", 
                   "orderTypeValue", "orderMode", "carryOver", "booleanValue", 
                   "phases", "nestedPolicy" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    T__88=89
    ID=90
    SIGNED_INT=91
    FLOAT=92
    WS=93

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class GovernanceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def scopes(self):
            return self.getTypedRuleContext(govdslParser.ScopesContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def policy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.PolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_governance

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGovernance" ):
                listener.enterGovernance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGovernance" ):
                listener.exitGovernance(self)




    def governance(self):

        localctx = govdslParser.GovernanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_governance)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.scopes()
            self.state = 163
            self.participants()
            self.state = 165 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 164
                self.policy()
                self.state = 167 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 169
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def topLevelSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelSinglePolicyContext,0)


        def topLevelComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.state = 171
                self.topLevelSinglePolicy()
                pass
            elif token in [3]:
                self.state = 172
                self.topLevelComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def communicationChannel(self):
            return self.getTypedRuleContext(govdslParser.CommunicationChannelContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSinglePolicy" ):
                listener.enterTopLevelSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSinglePolicy" ):
                listener.exitTopLevelSinglePolicy(self)




    def topLevelSinglePolicy(self):

        localctx = govdslParser.TopLevelSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topLevelSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.policyType()
            self.state = 176
            self.match(govdslParser.ID)
            self.state = 177
            self.match(govdslParser.T__0)
            self.state = 178
            self.scope()
            self.state = 179
            self.decisionType()
            self.state = 180
            self.policyParticipants()
            self.state = 182
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==37:
                self.state = 181
                self.communicationChannel()


            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 184
                self.conditions()


            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==77:
                self.state = 187
                self.parameters()


            self.state = 190
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelComposedPolicy" ):
                listener.enterTopLevelComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelComposedPolicy" ):
                listener.exitTopLevelComposedPolicy(self)




    def topLevelComposedPolicy(self):

        localctx = govdslParser.TopLevelComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_topLevelComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.match(govdslParser.T__2)
            self.state = 193
            self.match(govdslParser.ID)
            self.state = 194
            self.match(govdslParser.T__0)
            self.state = 195
            self.scope()
            self.state = 197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==81:
                self.state = 196
                self.order()


            self.state = 199
            self.phases()
            self.state = 200
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def communicationChannel(self):
            return self.getTypedRuleContext(govdslParser.CommunicationChannelContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedSinglePolicy" ):
                listener.enterNestedSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedSinglePolicy" ):
                listener.exitNestedSinglePolicy(self)




    def nestedSinglePolicy(self):

        localctx = govdslParser.NestedSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_nestedSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.policyType()
            self.state = 203
            self.match(govdslParser.ID)
            self.state = 204
            self.match(govdslParser.T__0)
            self.state = 205
            self.decisionType()
            self.state = 206
            self.policyParticipants()
            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==37:
                self.state = 207
                self.communicationChannel()


            self.state = 211
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 210
                self.conditions()


            self.state = 214
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==77:
                self.state = 213
                self.parameters()


            self.state = 216
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedComposedPolicy" ):
                listener.enterNestedComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedComposedPolicy" ):
                listener.exitNestedComposedPolicy(self)




    def nestedComposedPolicy(self):

        localctx = govdslParser.NestedComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_nestedComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.match(govdslParser.T__2)
            self.state = 219
            self.match(govdslParser.ID)
            self.state = 220
            self.match(govdslParser.T__0)
            self.state = 222
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==81:
                self.state = 221
                self.order()


            self.state = 224
            self.phases()
            self.state = 225
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 227
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1008) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def projects(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProjectsContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProjectsContext,i)


        def activities(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivitiesContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivitiesContext,i)


        def tasks(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TasksContext)
            else:
                return self.getTypedRuleContext(govdslParser.TasksContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_scopes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopes" ):
                listener.enterScopes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopes" ):
                listener.exitScopes(self)




    def scopes(self):

        localctx = govdslParser.ScopesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_scopes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            self.match(govdslParser.T__9)
            self.state = 230
            self.match(govdslParser.T__10)
            self.state = 234 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 234
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13]:
                    self.state = 231
                    self.projects()
                    pass
                elif token in [15]:
                    self.state = 232
                    self.activities()
                    pass
                elif token in [18]:
                    self.state = 233
                    self.tasks()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 236 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 303104) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.match(govdslParser.T__11)
            self.state = 239
            self.match(govdslParser.T__10)
            self.state = 240
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProjectContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProjectContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_projects

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProjects" ):
                listener.enterProjects(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProjects" ):
                listener.exitProjects(self)




    def projects(self):

        localctx = govdslParser.ProjectsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_projects)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            self.match(govdslParser.T__12)
            self.state = 243
            self.match(govdslParser.T__10)
            self.state = 245 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 244
                self.project()
                self.state = 247 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==90):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.match(govdslParser.ID)
            self.state = 255
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 250
                self.match(govdslParser.T__13)
                self.state = 251
                self.platform()
                self.state = 252
                self.match(govdslParser.T__10)
                self.state = 253
                self.repoID()


            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 257
                self.match(govdslParser.T__0)
                self.state = 258
                self.match(govdslParser.T__14)
                self.state = 259
                self.match(govdslParser.T__10)
                self.state = 261 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 260
                    self.activity()
                    self.state = 263 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==90):
                        break

                self.state = 265
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_platform)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            _la = self._input.LA(1)
            if not(_la==16 or _la==17):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_repoID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivitiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_activities

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivities" ):
                listener.enterActivities(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivities" ):
                listener.exitActivities(self)




    def activities(self):

        localctx = govdslParser.ActivitiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_activities)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 273
            self.match(govdslParser.T__14)
            self.state = 274
            self.match(govdslParser.T__10)
            self.state = 276 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 275
                self.activity()
                self.state = 278 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==90):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_activity)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.match(govdslParser.ID)
            self.state = 291
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 281
                self.match(govdslParser.T__0)
                self.state = 282
                self.match(govdslParser.T__17)
                self.state = 283
                self.match(govdslParser.T__10)
                self.state = 285 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 284
                    self.task()
                    self.state = 287 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==90):
                        break

                self.state = 289
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TasksContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_tasks

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTasks" ):
                listener.enterTasks(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTasks" ):
                listener.exitTasks(self)




    def tasks(self):

        localctx = govdslParser.TasksContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_tasks)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.match(govdslParser.T__17)
            self.state = 294
            self.match(govdslParser.T__10)
            self.state = 296 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 295
                self.task()
                self.state = 298 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==90):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(govdslParser.ID)
            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 301
                self.match(govdslParser.T__10)
                self.state = 302
                self.taskType()


            self.state = 309
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 305
                self.match(govdslParser.T__0)
                self.state = 306
                self.taskContent()
                self.state = 307
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_taskContent)
        try:
            self.state = 316
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 313
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 314
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 315
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.action()
            self.state = 319
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 321
            self.match(govdslParser.T__21)
            self.state = 322
            self.match(govdslParser.T__10)
            self.state = 323
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 58720256) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 327
            self.match(govdslParser.T__25)
            self.state = 328
            self.match(govdslParser.T__10)
            self.state = 329
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 331
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 939524096) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 333
            self.match(govdslParser.T__29)
            self.state = 334
            self.match(govdslParser.T__10)
            self.state = 335
            self.match(govdslParser.ID)
            self.state = 340
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 336
                self.match(govdslParser.T__30)
                self.state = 337
                self.match(govdslParser.ID)
                self.state = 342
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecisionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanDecision(self):
            return self.getTypedRuleContext(govdslParser.BooleanDecisionContext,0)


        def stringList(self):
            return self.getTypedRuleContext(govdslParser.StringListContext,0)


        def elementList(self):
            return self.getTypedRuleContext(govdslParser.ElementListContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_decisionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecisionType" ):
                listener.enterDecisionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecisionType" ):
                listener.exitDecisionType(self)




    def decisionType(self):

        localctx = govdslParser.DecisionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_decisionType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 343
            self.match(govdslParser.T__31)
            self.state = 344
            self.match(govdslParser.T__32)
            self.state = 348
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 345
                self.booleanDecision()
                pass
            elif token in [35]:
                self.state = 346
                self.stringList()
                pass
            elif token in [36]:
                self.state = 347
                self.elementList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanDecision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDecision" ):
                listener.enterBooleanDecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDecision" ):
                listener.exitBooleanDecision(self)




    def booleanDecision(self):

        localctx = govdslParser.BooleanDecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_booleanDecision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.match(govdslParser.T__33)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_stringList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringList" ):
                listener.enterStringList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringList" ):
                listener.exitStringList(self)




    def stringList(self):

        localctx = govdslParser.StringListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_stringList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 352
            self.match(govdslParser.T__34)
            self.state = 353
            self.match(govdslParser.T__10)
            self.state = 354
            self.match(govdslParser.ID)
            self.state = 359
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 355
                self.match(govdslParser.T__30)
                self.state = 356
                self.match(govdslParser.ID)
                self.state = 361
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_elementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementList" ):
                listener.enterElementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementList" ):
                listener.exitElementList(self)




    def elementList(self):

        localctx = govdslParser.ElementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_elementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 362
            self.match(govdslParser.T__35)
            self.state = 363
            self.match(govdslParser.T__10)
            self.state = 364
            self.match(govdslParser.ID)
            self.state = 369
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 365
                self.match(govdslParser.T__30)
                self.state = 366
                self.match(govdslParser.ID)
                self.state = 371
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommunicationChannelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_communicationChannel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommunicationChannel" ):
                listener.enterCommunicationChannel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommunicationChannel" ):
                listener.exitCommunicationChannel(self)




    def communicationChannel(self):

        localctx = govdslParser.CommunicationChannelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_communicationChannel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 372
            self.match(govdslParser.T__36)
            self.state = 373
            self.match(govdslParser.T__10)
            self.state = 374
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.RolesContext)
            else:
                return self.getTypedRuleContext(govdslParser.RolesContext,i)


        def individuals(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualsContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualsContext,i)


        def profiles(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProfilesContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProfilesContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_participants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(govdslParser.T__37)
            self.state = 377
            self.match(govdslParser.T__10)
            self.state = 381 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 381
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [39]:
                    self.state = 378
                    self.roles()
                    pass
                elif token in [40]:
                    self.state = 379
                    self.individuals()
                    pass
                elif token in [48]:
                    self.state = 380
                    self.profiles()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 383 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 283124244152320) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.RoleContext)
            else:
                return self.getTypedRuleContext(govdslParser.RoleContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            self.match(govdslParser.T__38)
            self.state = 386
            self.match(govdslParser.T__10)
            self.state = 387
            self.role()
            self.state = 392
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 388
                self.match(govdslParser.T__30)
                self.state = 389
                self.role()
                self.state = 394
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)




    def role(self):

        localctx = govdslParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_role)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 395
            self.match(govdslParser.ID)
            self.state = 401
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 396
                self.match(govdslParser.T__0)
                self.state = 398
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==41:
                    self.state = 397
                    self.voteValue()


                self.state = 400
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individualEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualEntryContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualEntryContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 403
            self.match(govdslParser.T__39)
            self.state = 404
            self.match(govdslParser.T__10)
            self.state = 405
            self.individualEntry()
            self.state = 412
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 31)) & ~0x3f) == 0 and ((1 << (_la - 31)) & 576460752303431681) != 0):
                self.state = 407
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 406
                    self.match(govdslParser.T__30)


                self.state = 409
                self.individualEntry()
                self.state = 414
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individual(self):
            return self.getTypedRuleContext(govdslParser.IndividualContext,0)


        def agent(self):
            return self.getTypedRuleContext(govdslParser.AgentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individualEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividualEntry" ):
                listener.enterIndividualEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividualEntry" ):
                listener.exitIndividualEntry(self)




    def individualEntry(self):

        localctx = govdslParser.IndividualEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_individualEntry)
        try:
            self.state = 417
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [90]:
                self.enterOuterAlt(localctx, 1)
                self.state = 415
                self.individual()
                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 2)
                self.state = 416
                self.agent()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def withProfile(self):
            return self.getTypedRuleContext(govdslParser.WithProfileContext,0)


        def withRole(self):
            return self.getTypedRuleContext(govdslParser.WithRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividual" ):
                listener.enterIndividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividual" ):
                listener.exitIndividual(self)




    def individual(self):

        localctx = govdslParser.IndividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_individual)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 419
            self.match(govdslParser.ID)
            self.state = 437
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 420
                self.match(govdslParser.T__0)
                self.state = 422
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==41:
                    self.state = 421
                    self.voteValue()


                self.state = 425
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                if la_ == 1:
                    self.state = 424
                    self.match(govdslParser.T__30)


                self.state = 428
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==42:
                    self.state = 427
                    self.withProfile()


                self.state = 431
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 430
                    self.match(govdslParser.T__30)


                self.state = 434
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43:
                    self.state = 433
                    self.withRole()


                self.state = 436
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoteValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_voteValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoteValue" ):
                listener.enterVoteValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoteValue" ):
                listener.exitVoteValue(self)




    def voteValue(self):

        localctx = govdslParser.VoteValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_voteValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            self.match(govdslParser.T__40)
            self.state = 440
            self.match(govdslParser.T__10)
            self.state = 441
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithProfileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_withProfile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithProfile" ):
                listener.enterWithProfile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithProfile" ):
                listener.exitWithProfile(self)




    def withProfile(self):

        localctx = govdslParser.WithProfileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_withProfile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 443
            self.match(govdslParser.T__41)
            self.state = 444
            self.match(govdslParser.T__10)
            self.state = 445
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_withRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithRole" ):
                listener.enterWithRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithRole" ):
                listener.exitWithRole(self)




    def withRole(self):

        localctx = govdslParser.WithRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_withRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 447
            self.match(govdslParser.T__42)
            self.state = 448
            self.match(govdslParser.T__10)
            self.state = 449
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AgentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def confidence(self):
            return self.getTypedRuleContext(govdslParser.ConfidenceContext,0)


        def autonomyLevel(self):
            return self.getTypedRuleContext(govdslParser.AutonomyLevelContext,0)


        def explainability(self):
            return self.getTypedRuleContext(govdslParser.ExplainabilityContext,0)


        def withRole(self):
            return self.getTypedRuleContext(govdslParser.WithRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_agent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent" ):
                listener.enterAgent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent" ):
                listener.exitAgent(self)




    def agent(self):

        localctx = govdslParser.AgentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_agent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 451
            self.match(govdslParser.T__43)
            self.state = 452
            self.match(govdslParser.ID)
            self.state = 482
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 453
                self.match(govdslParser.T__0)
                self.state = 455
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==41:
                    self.state = 454
                    self.voteValue()


                self.state = 458
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
                if la_ == 1:
                    self.state = 457
                    self.match(govdslParser.T__30)


                self.state = 461
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==45:
                    self.state = 460
                    self.confidence()


                self.state = 464
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
                if la_ == 1:
                    self.state = 463
                    self.match(govdslParser.T__30)


                self.state = 467
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==46:
                    self.state = 466
                    self.autonomyLevel()


                self.state = 470
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
                if la_ == 1:
                    self.state = 469
                    self.match(govdslParser.T__30)


                self.state = 473
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==47:
                    self.state = 472
                    self.explainability()


                self.state = 476
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 475
                    self.match(govdslParser.T__30)


                self.state = 479
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43:
                    self.state = 478
                    self.withRole()


                self.state = 481
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfidenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_confidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfidence" ):
                listener.enterConfidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfidence" ):
                listener.exitConfidence(self)




    def confidence(self):

        localctx = govdslParser.ConfidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_confidence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 484
            self.match(govdslParser.T__44)
            self.state = 485
            self.match(govdslParser.T__10)
            self.state = 486
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutonomyLevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_autonomyLevel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutonomyLevel" ):
                listener.enterAutonomyLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutonomyLevel" ):
                listener.exitAutonomyLevel(self)




    def autonomyLevel(self):

        localctx = govdslParser.AutonomyLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_autonomyLevel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 488
            self.match(govdslParser.T__45)
            self.state = 489
            self.match(govdslParser.T__10)
            self.state = 490
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplainabilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_explainability

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplainability" ):
                listener.enterExplainability(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplainability" ):
                listener.exitExplainability(self)




    def explainability(self):

        localctx = govdslParser.ExplainabilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_explainability)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 492
            self.match(govdslParser.T__46)
            self.state = 493
            self.match(govdslParser.T__10)
            self.state = 494
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProfilesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def profile(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProfileContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProfileContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_profiles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProfiles" ):
                listener.enterProfiles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProfiles" ):
                listener.exitProfiles(self)




    def profiles(self):

        localctx = govdslParser.ProfilesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_profiles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 496
            self.match(govdslParser.T__47)
            self.state = 497
            self.match(govdslParser.T__10)
            self.state = 498
            self.profile()
            self.state = 505
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31 or _la==90:
                self.state = 500
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 499
                    self.match(govdslParser.T__30)


                self.state = 502
                self.profile()
                self.state = 507
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProfileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def gender(self):
            return self.getTypedRuleContext(govdslParser.GenderContext,0)


        def race(self):
            return self.getTypedRuleContext(govdslParser.RaceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_profile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProfile" ):
                listener.enterProfile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProfile" ):
                listener.exitProfile(self)




    def profile(self):

        localctx = govdslParser.ProfileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_profile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 508
            self.match(govdslParser.ID)
            self.state = 509
            self.match(govdslParser.T__0)
            self.state = 524
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [49]:
                self.state = 510
                self.gender()
                self.state = 512
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 511
                    self.match(govdslParser.T__30)


                self.state = 515
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==50:
                    self.state = 514
                    self.race()


                pass
            elif token in [50]:
                self.state = 517
                self.race()
                self.state = 519
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 518
                    self.match(govdslParser.T__30)


                self.state = 522
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==49:
                    self.state = 521
                    self.gender()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 526
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_gender

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGender" ):
                listener.enterGender(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGender" ):
                listener.exitGender(self)




    def gender(self):

        localctx = govdslParser.GenderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_gender)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            self.match(govdslParser.T__48)
            self.state = 529
            self.match(govdslParser.T__10)
            self.state = 530
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_race

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRace" ):
                listener.enterRace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRace" ):
                listener.exitRace(self)




    def race(self):

        localctx = govdslParser.RaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_race)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 532
            self.match(govdslParser.T__49)
            self.state = 533
            self.match(govdslParser.T__10)
            self.state = 534
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def partID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PartIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.PartIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_policyParticipants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyParticipants" ):
                listener.enterPolicyParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyParticipants" ):
                listener.exitPolicyParticipants(self)




    def policyParticipants(self):

        localctx = govdslParser.PolicyParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_policyParticipants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 536
            self.match(govdslParser.T__50)
            self.state = 537
            self.match(govdslParser.T__10)
            self.state = 538
            self.partID()
            self.state = 543
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 539
                self.match(govdslParser.T__30)
                self.state = 540
                self.partID()
                self.state = 545
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_partID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartID" ):
                listener.enterPartID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartID" ):
                listener.exitPartID(self)




    def partID(self):

        localctx = govdslParser.PartIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_partID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 546
            self.match(govdslParser.ID)
            self.state = 548
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 547
                self.hasRole()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 550
            self.match(govdslParser.T__32)
            self.state = 551
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def minDecisionTime(self):
            return self.getTypedRuleContext(govdslParser.MinDecisionTimeContext,0)


        def participantExclusion(self):
            return self.getTypedRuleContext(govdslParser.ParticipantExclusionContext,0)


        def minParticipant(self):
            return self.getTypedRuleContext(govdslParser.MinParticipantContext,0)


        def vetoRight(self):
            return self.getTypedRuleContext(govdslParser.VetoRightContext,0)


        def appealRight(self):
            return self.getTypedRuleContext(govdslParser.AppealRightContext,0)


        def checkCiCd(self):
            return self.getTypedRuleContext(govdslParser.CheckCiCdContext,0)


        def minTime(self):
            return self.getTypedRuleContext(govdslParser.MinTimeContext,0)


        def labelsCondition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.LabelsConditionContext)
            else:
                return self.getTypedRuleContext(govdslParser.LabelsConditionContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 553
            self.match(govdslParser.T__51)
            self.state = 554
            self.match(govdslParser.T__10)
            self.state = 556
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==53:
                self.state = 555
                self.deadline()


            self.state = 559
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==54:
                self.state = 558
                self.minDecisionTime()


            self.state = 562
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==60:
                self.state = 561
                self.participantExclusion()


            self.state = 565
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==61:
                self.state = 564
                self.minParticipant()


            self.state = 568
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==62:
                self.state = 567
                self.vetoRight()


            self.state = 571
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==63:
                self.state = 570
                self.appealRight()


            self.state = 574
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 573
                self.checkCiCd()


            self.state = 577
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67:
                self.state = 576
                self.minTime()


            self.state = 582
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==74:
                self.state = 579
                self.labelsCondition()
                self.state = 584
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_deadline)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 585
            self.match(govdslParser.T__52)
            self.state = 587
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==90:
                self.state = 586
                self.deadlineID()


            self.state = 589
            self.match(govdslParser.T__10)
            self.state = 596
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 590
                self.offset()
                pass

            elif la_ == 2:
                self.state = 591
                self.date()
                pass

            elif la_ == 3:
                self.state = 592
                self.offset()
                self.state = 593
                self.match(govdslParser.T__30)
                self.state = 594
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinDecisionTimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minDecisionTime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinDecisionTime" ):
                listener.enterMinDecisionTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinDecisionTime" ):
                listener.exitMinDecisionTime(self)




    def minDecisionTime(self):

        localctx = govdslParser.MinDecisionTimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_minDecisionTime)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 598
            self.match(govdslParser.T__53)
            self.state = 600
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==90:
                self.state = 599
                self.match(govdslParser.ID)


            self.state = 602
            self.match(govdslParser.T__10)
            self.state = 609
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 603
                self.offset()
                pass

            elif la_ == 2:
                self.state = 604
                self.date()
                pass

            elif la_ == 3:
                self.state = 605
                self.offset()
                self.state = 606
                self.match(govdslParser.T__30)
                self.state = 607
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 611
            self.match(govdslParser.SIGNED_INT)
            self.state = 612
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 614
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 616
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 540431955284459520) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 618
            self.match(govdslParser.SIGNED_INT)
            self.state = 619
            self.match(govdslParser.T__58)
            self.state = 620
            self.match(govdslParser.SIGNED_INT)
            self.state = 621
            self.match(govdslParser.T__58)
            self.state = 622
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_participantExclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantExclusion" ):
                listener.enterParticipantExclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantExclusion" ):
                listener.exitParticipantExclusion(self)




    def participantExclusion(self):

        localctx = govdslParser.ParticipantExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_participantExclusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 624
            self.match(govdslParser.T__59)
            self.state = 625
            self.match(govdslParser.T__10)
            self.state = 626
            self.match(govdslParser.ID)
            self.state = 631
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 627
                self.match(govdslParser.T__30)
                self.state = 628
                self.match(govdslParser.ID)
                self.state = 633
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinParticipantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minParticipant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinParticipant" ):
                listener.enterMinParticipant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinParticipant" ):
                listener.exitMinParticipant(self)




    def minParticipant(self):

        localctx = govdslParser.MinParticipantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_minParticipant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 634
            self.match(govdslParser.T__60)
            self.state = 635
            self.match(govdslParser.T__10)
            self.state = 636
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VetoRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_vetoRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVetoRight" ):
                listener.enterVetoRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVetoRight" ):
                listener.exitVetoRight(self)




    def vetoRight(self):

        localctx = govdslParser.VetoRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_vetoRight)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 638
            self.match(govdslParser.T__61)
            self.state = 639
            self.match(govdslParser.T__10)
            self.state = 640
            self.match(govdslParser.ID)
            self.state = 645
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 641
                self.match(govdslParser.T__30)
                self.state = 642
                self.match(govdslParser.ID)
                self.state = 647
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AppealRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def policyReference(self):
            return self.getTypedRuleContext(govdslParser.PolicyReferenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_appealRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppealRight" ):
                listener.enterAppealRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppealRight" ):
                listener.exitAppealRight(self)




    def appealRight(self):

        localctx = govdslParser.AppealRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_appealRight)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 648
            self.match(govdslParser.T__62)
            self.state = 649
            self.match(govdslParser.T__10)
            self.state = 650
            self.match(govdslParser.T__0)
            self.state = 651
            self.match(govdslParser.T__63)
            self.state = 652
            self.match(govdslParser.T__10)
            self.state = 653
            self.match(govdslParser.ID)
            self.state = 658
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,75,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 654
                    self.match(govdslParser.T__30)
                    self.state = 655
                    self.match(govdslParser.ID) 
                self.state = 660
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,75,self._ctx)

            self.state = 662
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==31:
                self.state = 661
                self.match(govdslParser.T__30)


            self.state = 664
            self.match(govdslParser.T__64)
            self.state = 665
            self.match(govdslParser.T__10)
            self.state = 668
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 6, 7, 8, 9]:
                self.state = 666
                self.nestedPolicy()
                pass
            elif token in [90]:
                self.state = 667
                self.policyReference()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 670
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CheckCiCdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_checkCiCd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCheckCiCd" ):
                listener.enterCheckCiCd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCheckCiCd" ):
                listener.exitCheckCiCd(self)




    def checkCiCd(self):

        localctx = govdslParser.CheckCiCdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_checkCiCd)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 672
            self.match(govdslParser.T__65)
            self.state = 674
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 7) != 0):
                self.state = 673
                self.evaluationMode()


            self.state = 676
            self.match(govdslParser.T__10)
            self.state = 677
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinTimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def activityBool(self):
            return self.getTypedRuleContext(govdslParser.ActivityBoolContext,0)


        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_minTime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinTime" ):
                listener.enterMinTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinTime" ):
                listener.exitMinTime(self)




    def minTime(self):

        localctx = govdslParser.MinTimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_minTime)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 679
            self.match(govdslParser.T__66)
            self.state = 681
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 7) != 0):
                self.state = 680
                self.evaluationMode()


            self.state = 683
            self.match(govdslParser.T__67)
            self.state = 684
            self.activityBool()
            self.state = 685
            self.match(govdslParser.T__10)
            self.state = 686
            self.offset()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityBoolContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_activityBool

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivityBool" ):
                listener.enterActivityBool(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivityBool" ):
                listener.exitActivityBool(self)




    def activityBool(self):

        localctx = govdslParser.ActivityBoolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_activityBool)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 688
            _la = self._input.LA(1)
            if not(_la==69 or _la==70):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EvaluationModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_evaluationMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvaluationMode" ):
                listener.enterEvaluationMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvaluationMode" ):
                listener.exitEvaluationMode(self)




    def evaluationMode(self):

        localctx = govdslParser.EvaluationModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_evaluationMode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 690
            _la = self._input.LA(1)
            if not(((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def include(self):
            return self.getTypedRuleContext(govdslParser.IncludeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_labelsCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelsCondition" ):
                listener.enterLabelsCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelsCondition" ):
                listener.exitLabelsCondition(self)




    def labelsCondition(self):

        localctx = govdslParser.LabelsConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_labelsCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self.match(govdslParser.T__73)
            self.state = 694
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 71)) & ~0x3f) == 0 and ((1 << (_la - 71)) & 7) != 0):
                self.state = 693
                self.evaluationMode()


            self.state = 697
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==75 or _la==76:
                self.state = 696
                self.include()


            self.state = 699
            self.match(govdslParser.T__10)
            self.state = 700
            self.match(govdslParser.ID)
            self.state = 705
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 701
                self.match(govdslParser.T__30)
                self.state = 702
                self.match(govdslParser.ID)
                self.state = 707
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_include

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude" ):
                listener.enterInclude(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude" ):
                listener.exitInclude(self)




    def include(self):

        localctx = govdslParser.IncludeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_include)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 708
            _la = self._input.LA(1)
            if not(_la==75 or _la==76):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def fallback(self):
            return self.getTypedRuleContext(govdslParser.FallbackContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 710
            self.match(govdslParser.T__76)
            self.state = 711
            self.match(govdslParser.T__10)
            self.state = 715
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 712
                self.votParams()
                pass
            elif token in [79]:
                self.state = 713
                self.default()
                pass
            elif token in [80]:
                self.state = 714
                self.fallback()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_votParams)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 717
            self.ratio()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 719
            self.match(govdslParser.T__77)
            self.state = 720
            self.match(govdslParser.T__10)
            self.state = 721
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def policyReference(self):
            return self.getTypedRuleContext(govdslParser.PolicyReferenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 723
            self.match(govdslParser.T__78)
            self.state = 724
            self.match(govdslParser.T__10)
            self.state = 727
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 6, 7, 8, 9]:
                self.state = 725
                self.nestedPolicy()
                pass
            elif token in [90]:
                self.state = 726
                self.policyReference()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FallbackContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def policyReference(self):
            return self.getTypedRuleContext(govdslParser.PolicyReferenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_fallback

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFallback" ):
                listener.enterFallback(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFallback" ):
                listener.exitFallback(self)




    def fallback(self):

        localctx = govdslParser.FallbackContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_fallback)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 729
            self.match(govdslParser.T__79)
            self.state = 730
            self.match(govdslParser.T__10)
            self.state = 733
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 6, 7, 8, 9]:
                self.state = 731
                self.nestedPolicy()
                pass
            elif token in [90]:
                self.state = 732
                self.policyReference()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_policyReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyReference" ):
                listener.enterPolicyReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyReference" ):
                listener.exitPolicyReference(self)




    def policyReference(self):

        localctx = govdslParser.PolicyReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_policyReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 735
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def carryOver(self):
            return self.getTypedRuleContext(govdslParser.CarryOverContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 737
            self.match(govdslParser.T__80)
            self.state = 738
            self.match(govdslParser.T__10)

            self.state = 739
            self.orderType()
            self.state = 740
            self.orderMode()
            self.state = 742
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==86:
                self.state = 741
                self.carryOver()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderTypeValue(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_orderType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 744
            self.match(govdslParser.T__81)
            self.state = 745
            self.match(govdslParser.T__10)
            self.state = 746
            self.orderTypeValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderTypeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderTypeValue" ):
                listener.enterOrderTypeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderTypeValue" ):
                listener.exitOrderTypeValue(self)




    def orderTypeValue(self):

        localctx = govdslParser.OrderTypeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_orderTypeValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 748
            _la = self._input.LA(1)
            if not(_la==83 or _la==84):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_orderMode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 750
            self.match(govdslParser.T__84)
            self.state = 751
            self.match(govdslParser.T__10)
            self.state = 752
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CarryOverContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_carryOver

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCarryOver" ):
                listener.enterCarryOver(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCarryOver" ):
                listener.exitCarryOver(self)




    def carryOver(self):

        localctx = govdslParser.CarryOverContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_carryOver)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 754
            self.match(govdslParser.T__85)
            self.state = 755
            self.match(govdslParser.T__10)
            self.state = 756
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = govdslParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 758
            _la = self._input.LA(1)
            if not(_la==87 or _la==88):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.NestedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.NestedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 760
            self.match(govdslParser.T__88)
            self.state = 761
            self.match(govdslParser.T__0)
            self.state = 763 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 762
                self.nestedPolicy()
                self.state = 765 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 767
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedSinglePolicyContext,0)


        def nestedComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPolicy" ):
                listener.enterNestedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPolicy" ):
                listener.exitNestedPolicy(self)




    def nestedPolicy(self):

        localctx = govdslParser.NestedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_nestedPolicy)
        try:
            self.state = 771
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 769
                self.nestedSinglePolicy()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 770
                self.nestedComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





