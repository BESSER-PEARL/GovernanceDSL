# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,61,389,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,1,0,1,0,3,0,101,8,0,1,0,1,0,1,1,1,1,1,1,
        1,1,1,1,3,1,110,8,1,1,1,3,1,113,8,1,1,1,3,1,116,8,1,1,1,1,1,1,2,
        1,2,1,2,1,2,1,2,3,2,125,8,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,3,3,134,
        8,3,1,3,3,3,137,8,3,1,3,3,3,140,8,3,1,3,1,3,1,4,1,4,1,4,1,4,3,4,
        148,8,4,1,4,1,4,1,4,1,5,1,5,1,6,1,6,1,6,1,6,1,6,3,6,160,8,6,1,7,
        1,7,1,7,1,7,1,7,1,7,1,7,3,7,169,8,7,1,8,1,8,1,9,1,9,1,9,3,9,176,
        8,9,1,10,1,10,1,10,1,11,1,11,1,11,1,11,3,11,185,8,11,1,11,1,11,1,
        11,1,11,1,12,1,12,1,13,1,13,1,13,3,13,196,8,13,1,14,1,14,1,14,1,
        15,1,15,1,15,1,15,1,16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,1,19,1,
        19,1,19,1,19,1,19,5,19,218,8,19,10,19,12,19,221,9,19,1,20,1,20,1,
        20,1,20,3,20,227,8,20,1,20,1,20,3,20,231,8,20,3,20,233,8,20,1,21,
        1,21,1,21,1,21,1,21,5,21,240,8,21,10,21,12,21,243,9,21,1,22,1,22,
        1,23,1,23,1,23,1,23,1,23,5,23,252,8,23,10,23,12,23,255,9,23,1,24,
        1,24,3,24,259,8,24,1,24,3,24,262,8,24,1,25,1,25,1,25,1,26,1,26,1,
        26,1,27,1,27,1,27,3,27,273,8,27,1,27,3,27,276,8,27,1,27,3,27,279,
        8,27,1,27,3,27,282,8,27,1,27,3,27,285,8,27,1,28,1,28,1,28,1,28,1,
        28,1,28,1,28,1,28,1,28,3,28,296,8,28,1,29,1,29,1,29,1,30,1,30,1,
        31,1,31,1,32,1,32,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,33,1,33,5,
        33,316,8,33,10,33,12,33,319,9,33,1,34,1,34,1,34,1,34,1,35,1,35,1,
        35,1,35,1,35,5,35,330,8,35,10,35,12,35,333,9,35,1,36,1,36,1,36,1,
        36,3,36,339,8,36,1,37,1,37,1,38,1,38,1,38,1,39,1,39,1,39,1,40,1,
        40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,3,41,358,8,41,1,42,1,42,1,
        42,1,42,1,43,1,43,1,44,1,44,1,44,1,44,1,45,1,45,1,45,1,45,1,46,1,
        46,1,47,1,47,1,47,4,47,379,8,47,11,47,12,47,380,1,47,1,47,1,48,1,
        48,3,48,387,8,48,1,48,0,0,49,0,2,4,6,8,10,12,14,16,18,20,22,24,26,
        28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,
        72,74,76,78,80,82,84,86,88,90,92,94,96,0,7,1,0,4,9,1,0,18,20,1,0,
        22,24,1,0,26,28,1,0,38,41,1,0,51,52,1,0,55,56,376,0,100,1,0,0,0,
        2,104,1,0,0,0,4,119,1,0,0,0,6,129,1,0,0,0,8,143,1,0,0,0,10,152,1,
        0,0,0,12,154,1,0,0,0,14,161,1,0,0,0,16,170,1,0,0,0,18,172,1,0,0,
        0,20,177,1,0,0,0,22,180,1,0,0,0,24,190,1,0,0,0,26,195,1,0,0,0,28,
        197,1,0,0,0,30,200,1,0,0,0,32,204,1,0,0,0,34,206,1,0,0,0,36,210,
        1,0,0,0,38,212,1,0,0,0,40,222,1,0,0,0,42,234,1,0,0,0,44,244,1,0,
        0,0,46,246,1,0,0,0,48,256,1,0,0,0,50,263,1,0,0,0,52,266,1,0,0,0,
        54,269,1,0,0,0,56,286,1,0,0,0,58,297,1,0,0,0,60,300,1,0,0,0,62,302,
        1,0,0,0,64,304,1,0,0,0,66,310,1,0,0,0,68,320,1,0,0,0,70,324,1,0,
        0,0,72,334,1,0,0,0,74,340,1,0,0,0,76,342,1,0,0,0,78,345,1,0,0,0,
        80,348,1,0,0,0,82,352,1,0,0,0,84,359,1,0,0,0,86,363,1,0,0,0,88,365,
        1,0,0,0,90,369,1,0,0,0,92,373,1,0,0,0,94,375,1,0,0,0,96,386,1,0,
        0,0,98,101,3,2,1,0,99,101,3,4,2,0,100,98,1,0,0,0,100,99,1,0,0,0,
        101,102,1,0,0,0,102,103,5,0,0,1,103,1,1,0,0,0,104,105,3,10,5,0,105,
        106,5,58,0,0,106,107,5,1,0,0,107,109,3,12,6,0,108,110,3,40,20,0,
        109,108,1,0,0,0,109,110,1,0,0,0,110,112,1,0,0,0,111,113,3,54,27,
        0,112,111,1,0,0,0,112,113,1,0,0,0,113,115,1,0,0,0,114,116,3,72,36,
        0,115,114,1,0,0,0,115,116,1,0,0,0,116,117,1,0,0,0,117,118,5,2,0,
        0,118,3,1,0,0,0,119,120,5,3,0,0,120,121,5,58,0,0,121,122,5,1,0,0,
        122,124,3,12,6,0,123,125,3,82,41,0,124,123,1,0,0,0,124,125,1,0,0,
        0,125,126,1,0,0,0,126,127,3,94,47,0,127,128,5,2,0,0,128,5,1,0,0,
        0,129,130,3,10,5,0,130,131,5,58,0,0,131,133,5,1,0,0,132,134,3,40,
        20,0,133,132,1,0,0,0,133,134,1,0,0,0,134,136,1,0,0,0,135,137,3,54,
        27,0,136,135,1,0,0,0,136,137,1,0,0,0,137,139,1,0,0,0,138,140,3,72,
        36,0,139,138,1,0,0,0,139,140,1,0,0,0,140,141,1,0,0,0,141,142,5,2,
        0,0,142,7,1,0,0,0,143,144,5,3,0,0,144,145,5,58,0,0,145,147,5,1,0,
        0,146,148,3,82,41,0,147,146,1,0,0,0,147,148,1,0,0,0,148,149,1,0,
        0,0,149,150,3,94,47,0,150,151,5,2,0,0,151,9,1,0,0,0,152,153,7,0,
        0,0,153,11,1,0,0,0,154,155,5,10,0,0,155,159,5,11,0,0,156,160,3,14,
        7,0,157,160,3,20,10,0,158,160,3,22,11,0,159,156,1,0,0,0,159,157,
        1,0,0,0,159,158,1,0,0,0,160,13,1,0,0,0,161,162,5,12,0,0,162,168,
        5,58,0,0,163,164,5,13,0,0,164,165,3,16,8,0,165,166,5,11,0,0,166,
        167,3,18,9,0,167,169,1,0,0,0,168,163,1,0,0,0,168,169,1,0,0,0,169,
        15,1,0,0,0,170,171,5,14,0,0,171,17,1,0,0,0,172,175,5,58,0,0,173,
        174,5,15,0,0,174,176,5,58,0,0,175,173,1,0,0,0,175,176,1,0,0,0,176,
        19,1,0,0,0,177,178,5,16,0,0,178,179,5,58,0,0,179,21,1,0,0,0,180,
        181,5,17,0,0,181,184,5,58,0,0,182,183,5,11,0,0,183,185,3,24,12,0,
        184,182,1,0,0,0,184,185,1,0,0,0,185,186,1,0,0,0,186,187,5,1,0,0,
        187,188,3,26,13,0,188,189,5,2,0,0,189,23,1,0,0,0,190,191,7,1,0,0,
        191,25,1,0,0,0,192,196,3,30,15,0,193,196,3,34,17,0,194,196,3,28,
        14,0,195,192,1,0,0,0,195,193,1,0,0,0,195,194,1,0,0,0,196,27,1,0,
        0,0,197,198,3,34,17,0,198,199,3,38,19,0,199,29,1,0,0,0,200,201,5,
        21,0,0,201,202,5,11,0,0,202,203,3,32,16,0,203,31,1,0,0,0,204,205,
        7,2,0,0,205,33,1,0,0,0,206,207,5,25,0,0,207,208,5,11,0,0,208,209,
        3,36,18,0,209,35,1,0,0,0,210,211,7,3,0,0,211,37,1,0,0,0,212,213,
        5,29,0,0,213,214,5,11,0,0,214,219,5,58,0,0,215,216,5,30,0,0,216,
        218,5,58,0,0,217,215,1,0,0,0,218,221,1,0,0,0,219,217,1,0,0,0,219,
        220,1,0,0,0,220,39,1,0,0,0,221,219,1,0,0,0,222,223,5,31,0,0,223,
        232,5,11,0,0,224,226,3,42,21,0,225,227,3,46,23,0,226,225,1,0,0,0,
        226,227,1,0,0,0,227,233,1,0,0,0,228,230,3,46,23,0,229,231,3,42,21,
        0,230,229,1,0,0,0,230,231,1,0,0,0,231,233,1,0,0,0,232,224,1,0,0,
        0,232,228,1,0,0,0,233,41,1,0,0,0,234,235,5,32,0,0,235,236,5,11,0,
        0,236,241,3,44,22,0,237,238,5,30,0,0,238,240,3,44,22,0,239,237,1,
        0,0,0,240,243,1,0,0,0,241,239,1,0,0,0,241,242,1,0,0,0,242,43,1,0,
        0,0,243,241,1,0,0,0,244,245,5,58,0,0,245,45,1,0,0,0,246,247,5,33,
        0,0,247,248,5,11,0,0,248,253,3,48,24,0,249,250,5,30,0,0,250,252,
        3,48,24,0,251,249,1,0,0,0,252,255,1,0,0,0,253,251,1,0,0,0,253,254,
        1,0,0,0,254,47,1,0,0,0,255,253,1,0,0,0,256,258,3,44,22,0,257,259,
        3,50,25,0,258,257,1,0,0,0,258,259,1,0,0,0,259,261,1,0,0,0,260,262,
        3,52,26,0,261,260,1,0,0,0,261,262,1,0,0,0,262,49,1,0,0,0,263,264,
        5,34,0,0,264,265,3,44,22,0,265,51,1,0,0,0,266,267,5,35,0,0,267,268,
        5,60,0,0,268,53,1,0,0,0,269,270,5,36,0,0,270,272,5,11,0,0,271,273,
        3,56,28,0,272,271,1,0,0,0,272,273,1,0,0,0,273,275,1,0,0,0,274,276,
        3,66,33,0,275,274,1,0,0,0,275,276,1,0,0,0,276,278,1,0,0,0,277,279,
        3,68,34,0,278,277,1,0,0,0,278,279,1,0,0,0,279,281,1,0,0,0,280,282,
        3,70,35,0,281,280,1,0,0,0,281,282,1,0,0,0,282,284,1,0,0,0,283,285,
        3,80,40,0,284,283,1,0,0,0,284,285,1,0,0,0,285,55,1,0,0,0,286,287,
        5,37,0,0,287,288,3,60,30,0,288,295,5,11,0,0,289,296,3,58,29,0,290,
        296,3,64,32,0,291,292,3,58,29,0,292,293,5,30,0,0,293,294,3,64,32,
        0,294,296,1,0,0,0,295,289,1,0,0,0,295,290,1,0,0,0,295,291,1,0,0,
        0,296,57,1,0,0,0,297,298,5,59,0,0,298,299,3,62,31,0,299,59,1,0,0,
        0,300,301,5,58,0,0,301,61,1,0,0,0,302,303,7,4,0,0,303,63,1,0,0,0,
        304,305,5,59,0,0,305,306,5,15,0,0,306,307,5,59,0,0,307,308,5,15,
        0,0,308,309,5,59,0,0,309,65,1,0,0,0,310,311,5,42,0,0,311,312,5,11,
        0,0,312,317,3,44,22,0,313,314,5,30,0,0,314,316,3,44,22,0,315,313,
        1,0,0,0,316,319,1,0,0,0,317,315,1,0,0,0,317,318,1,0,0,0,318,67,1,
        0,0,0,319,317,1,0,0,0,320,321,5,43,0,0,321,322,5,11,0,0,322,323,
        5,59,0,0,323,69,1,0,0,0,324,325,5,44,0,0,325,326,5,11,0,0,326,331,
        3,44,22,0,327,328,5,30,0,0,328,330,3,44,22,0,329,327,1,0,0,0,330,
        333,1,0,0,0,331,329,1,0,0,0,331,332,1,0,0,0,332,71,1,0,0,0,333,331,
        1,0,0,0,334,335,5,45,0,0,335,338,5,11,0,0,336,339,3,74,37,0,337,
        339,3,78,39,0,338,336,1,0,0,0,338,337,1,0,0,0,339,73,1,0,0,0,340,
        341,3,76,38,0,341,75,1,0,0,0,342,343,5,46,0,0,343,344,5,60,0,0,344,
        77,1,0,0,0,345,346,5,47,0,0,346,347,3,96,48,0,347,79,1,0,0,0,348,
        349,5,48,0,0,349,350,5,11,0,0,350,351,3,92,46,0,351,81,1,0,0,0,352,
        353,5,49,0,0,353,354,5,11,0,0,354,355,3,84,42,0,355,357,3,88,44,
        0,356,358,3,90,45,0,357,356,1,0,0,0,357,358,1,0,0,0,358,83,1,0,0,
        0,359,360,5,50,0,0,360,361,5,11,0,0,361,362,3,86,43,0,362,85,1,0,
        0,0,363,364,7,5,0,0,364,87,1,0,0,0,365,366,5,53,0,0,366,367,5,11,
        0,0,367,368,3,92,46,0,368,89,1,0,0,0,369,370,5,54,0,0,370,371,5,
        11,0,0,371,372,3,92,46,0,372,91,1,0,0,0,373,374,7,6,0,0,374,93,1,
        0,0,0,375,376,5,57,0,0,376,378,5,1,0,0,377,379,3,96,48,0,378,377,
        1,0,0,0,379,380,1,0,0,0,380,378,1,0,0,0,380,381,1,0,0,0,381,382,
        1,0,0,0,382,383,5,2,0,0,383,95,1,0,0,0,384,387,3,6,3,0,385,387,3,
        8,4,0,386,384,1,0,0,0,386,385,1,0,0,0,387,97,1,0,0,0,34,100,109,
        112,115,124,133,136,139,147,159,168,175,184,195,219,226,230,232,
        241,253,258,261,272,275,278,281,284,295,317,331,338,357,380,386
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'ComposedPolicy'", "'MajorityPolicy'", 
                     "'LeaderDrivenPolicy'", "'AbsoluteMajorityPolicy'", 
                     "'ConsensusPolicy'", "'LazyConsensusPolicy'", "'VotingPolicy'", 
                     "'Scope'", "':'", "'Project'", "'from'", "'GitHub'", 
                     "'/'", "'Activity'", "'Task'", "'Issue'", "'Pull request'", 
                     "'All'", "'Status'", "'completed'", "'accepted'", "'partial'", 
                     "'Action'", "'merge'", "'review'", "'release'", "'Labels'", 
                     "','", "'Participants'", "'Roles'", "'Individuals'", 
                     "'as'", "'with confidence'", "'Conditions'", "'Deadline'", 
                     "'days'", "'weeks'", "'months'", "'years'", "'ParticipantExclusion'", 
                     "'MinParticipants'", "'VetoRight'", "'Parameters'", 
                     "'ratio'", "'default'", "'PassedTests'", "'Order'", 
                     "'Execution'", "'sequential'", "'parallel'", "'RequireAll'", 
                     "'CarryOver'", "'true'", "'false'", "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "ID", "SIGNED_INT", "FLOAT", 
                      "WS" ]

    RULE_policy = 0
    RULE_topLevelSinglePolicy = 1
    RULE_topLevelComposedPolicy = 2
    RULE_nestedSinglePolicy = 3
    RULE_nestedComposedPolicy = 4
    RULE_policyType = 5
    RULE_scope = 6
    RULE_project = 7
    RULE_platform = 8
    RULE_repoID = 9
    RULE_activity = 10
    RULE_task = 11
    RULE_taskType = 12
    RULE_taskContent = 13
    RULE_actionWithLabels = 14
    RULE_status = 15
    RULE_statusEnum = 16
    RULE_action = 17
    RULE_actionEnum = 18
    RULE_labels = 19
    RULE_participants = 20
    RULE_roles = 21
    RULE_participantID = 22
    RULE_individuals = 23
    RULE_individual = 24
    RULE_hasRole = 25
    RULE_confidence = 26
    RULE_conditions = 27
    RULE_deadline = 28
    RULE_offset = 29
    RULE_deadlineID = 30
    RULE_timeUnit = 31
    RULE_date = 32
    RULE_participantExclusion = 33
    RULE_minParticipant = 34
    RULE_vetoRight = 35
    RULE_parameters = 36
    RULE_votParams = 37
    RULE_ratio = 38
    RULE_default = 39
    RULE_passedTests = 40
    RULE_order = 41
    RULE_orderType = 42
    RULE_orderTypeValue = 43
    RULE_orderMode = 44
    RULE_carryOver = 45
    RULE_booleanValue = 46
    RULE_phases = 47
    RULE_nestedPolicy = 48

    ruleNames =  [ "policy", "topLevelSinglePolicy", "topLevelComposedPolicy", 
                   "nestedSinglePolicy", "nestedComposedPolicy", "policyType", 
                   "scope", "project", "platform", "repoID", "activity", 
                   "task", "taskType", "taskContent", "actionWithLabels", 
                   "status", "statusEnum", "action", "actionEnum", "labels", 
                   "participants", "roles", "participantID", "individuals", 
                   "individual", "hasRole", "confidence", "conditions", 
                   "deadline", "offset", "deadlineID", "timeUnit", "date", 
                   "participantExclusion", "minParticipant", "vetoRight", 
                   "parameters", "votParams", "ratio", "default", "passedTests", 
                   "order", "orderType", "orderTypeValue", "orderMode", 
                   "carryOver", "booleanValue", "phases", "nestedPolicy" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    ID=58
    SIGNED_INT=59
    FLOAT=60
    WS=61

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def topLevelSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelSinglePolicyContext,0)


        def topLevelComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.state = 98
                self.topLevelSinglePolicy()
                pass
            elif token in [3]:
                self.state = 99
                self.topLevelComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 102
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSinglePolicy" ):
                listener.enterTopLevelSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSinglePolicy" ):
                listener.exitTopLevelSinglePolicy(self)




    def topLevelSinglePolicy(self):

        localctx = govdslParser.TopLevelSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_topLevelSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.policyType()
            self.state = 105
            self.match(govdslParser.ID)
            self.state = 106
            self.match(govdslParser.T__0)
            self.state = 107
            self.scope()
            self.state = 109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==31:
                self.state = 108
                self.participants()


            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==36:
                self.state = 111
                self.conditions()


            self.state = 115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 114
                self.parameters()


            self.state = 117
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelComposedPolicy" ):
                listener.enterTopLevelComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelComposedPolicy" ):
                listener.exitTopLevelComposedPolicy(self)




    def topLevelComposedPolicy(self):

        localctx = govdslParser.TopLevelComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topLevelComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(govdslParser.T__2)
            self.state = 120
            self.match(govdslParser.ID)
            self.state = 121
            self.match(govdslParser.T__0)
            self.state = 122
            self.scope()
            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 123
                self.order()


            self.state = 126
            self.phases()
            self.state = 127
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedSinglePolicy" ):
                listener.enterNestedSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedSinglePolicy" ):
                listener.exitNestedSinglePolicy(self)




    def nestedSinglePolicy(self):

        localctx = govdslParser.NestedSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_nestedSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.policyType()
            self.state = 130
            self.match(govdslParser.ID)
            self.state = 131
            self.match(govdslParser.T__0)
            self.state = 133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==31:
                self.state = 132
                self.participants()


            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==36:
                self.state = 135
                self.conditions()


            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 138
                self.parameters()


            self.state = 141
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedComposedPolicy" ):
                listener.enterNestedComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedComposedPolicy" ):
                listener.exitNestedComposedPolicy(self)




    def nestedComposedPolicy(self):

        localctx = govdslParser.NestedComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_nestedComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(govdslParser.T__2)
            self.state = 144
            self.match(govdslParser.ID)
            self.state = 145
            self.match(govdslParser.T__0)
            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 146
                self.order()


            self.state = 149
            self.phases()
            self.state = 150
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1008) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self):
            return self.getTypedRuleContext(govdslParser.ProjectContext,0)


        def activity(self):
            return self.getTypedRuleContext(govdslParser.ActivityContext,0)


        def task(self):
            return self.getTypedRuleContext(govdslParser.TaskContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(govdslParser.T__9)
            self.state = 155
            self.match(govdslParser.T__10)
            self.state = 159
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [12]:
                self.state = 156
                self.project()
                pass
            elif token in [16]:
                self.state = 157
                self.activity()
                pass
            elif token in [17]:
                self.state = 158
                self.task()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self.match(govdslParser.T__11)
            self.state = 162
            self.match(govdslParser.ID)
            self.state = 168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 163
                self.match(govdslParser.T__12)
                self.state = 164
                self.platform()
                self.state = 165
                self.match(govdslParser.T__10)
                self.state = 166
                self.repoID()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.match(govdslParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(govdslParser.ID)
            self.state = 175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 173
                self.match(govdslParser.T__14)
                self.state = 174
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_activity)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.match(govdslParser.T__15)
            self.state = 178
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.match(govdslParser.T__16)
            self.state = 181
            self.match(govdslParser.ID)
            self.state = 184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 182
                self.match(govdslParser.T__10)
                self.state = 183
                self.taskType()


            self.state = 186
            self.match(govdslParser.T__0)
            self.state = 187
            self.taskContent()
            self.state = 188
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1835008) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_taskContent)
        try:
            self.state = 195
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 192
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 193
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 194
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.action()
            self.state = 198
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(govdslParser.T__20)
            self.state = 201
            self.match(govdslParser.T__10)
            self.state = 202
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 29360128) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.match(govdslParser.T__24)
            self.state = 207
            self.match(govdslParser.T__10)
            self.state = 208
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 469762048) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self.match(govdslParser.T__28)
            self.state = 213
            self.match(govdslParser.T__10)
            self.state = 214
            self.match(govdslParser.ID)
            self.state = 219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==30:
                self.state = 215
                self.match(govdslParser.T__29)
                self.state = 216
                self.match(govdslParser.ID)
                self.state = 221
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self):
            return self.getTypedRuleContext(govdslParser.RolesContext,0)


        def individuals(self):
            return self.getTypedRuleContext(govdslParser.IndividualsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_participants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.match(govdslParser.T__30)
            self.state = 223
            self.match(govdslParser.T__10)
            self.state = 232
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [32]:
                self.state = 224
                self.roles()
                self.state = 226
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==33:
                    self.state = 225
                    self.individuals()


                pass
            elif token in [33]:
                self.state = 228
                self.individuals()
                self.state = 230
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==32:
                    self.state = 229
                    self.roles()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.match(govdslParser.T__31)
            self.state = 235
            self.match(govdslParser.T__10)
            self.state = 236
            self.participantID()
            self.state = 241
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==30:
                self.state = 237
                self.match(govdslParser.T__29)
                self.state = 238
                self.participantID()
                self.state = 243
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_participantID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantID" ):
                listener.enterParticipantID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantID" ):
                listener.exitParticipantID(self)




    def participantID(self):

        localctx = govdslParser.ParticipantIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_participantID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individual(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            self.match(govdslParser.T__32)
            self.state = 247
            self.match(govdslParser.T__10)
            self.state = 248
            self.individual()
            self.state = 253
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==30:
                self.state = 249
                self.match(govdslParser.T__29)
                self.state = 250
                self.individual()
                self.state = 255
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def confidence(self):
            return self.getTypedRuleContext(govdslParser.ConfidenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividual" ):
                listener.enterIndividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividual" ):
                listener.exitIndividual(self)




    def individual(self):

        localctx = govdslParser.IndividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_individual)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.participantID()
            self.state = 258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 257
                self.hasRole()


            self.state = 261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 260
                self.confidence()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.match(govdslParser.T__33)
            self.state = 264
            self.participantID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfidenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_confidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfidence" ):
                listener.enterConfidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfidence" ):
                listener.exitConfidence(self)




    def confidence(self):

        localctx = govdslParser.ConfidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_confidence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(govdslParser.T__34)
            self.state = 267
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def participantExclusion(self):
            return self.getTypedRuleContext(govdslParser.ParticipantExclusionContext,0)


        def minParticipant(self):
            return self.getTypedRuleContext(govdslParser.MinParticipantContext,0)


        def vetoRight(self):
            return self.getTypedRuleContext(govdslParser.VetoRightContext,0)


        def passedTests(self):
            return self.getTypedRuleContext(govdslParser.PassedTestsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            self.match(govdslParser.T__35)
            self.state = 270
            self.match(govdslParser.T__10)
            self.state = 272
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==37:
                self.state = 271
                self.deadline()


            self.state = 275
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 274
                self.participantExclusion()


            self.state = 278
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==43:
                self.state = 277
                self.minParticipant()


            self.state = 281
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==44:
                self.state = 280
                self.vetoRight()


            self.state = 284
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 283
                self.passedTests()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_deadline)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.match(govdslParser.T__36)
            self.state = 287
            self.deadlineID()
            self.state = 288
            self.match(govdslParser.T__10)
            self.state = 295
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.state = 289
                self.offset()
                pass

            elif la_ == 2:
                self.state = 290
                self.date()
                pass

            elif la_ == 3:
                self.state = 291
                self.offset()
                self.state = 292
                self.match(govdslParser.T__29)
                self.state = 293
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self.match(govdslParser.SIGNED_INT)
            self.state = 298
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4123168604160) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(govdslParser.SIGNED_INT)
            self.state = 305
            self.match(govdslParser.T__14)
            self.state = 306
            self.match(govdslParser.SIGNED_INT)
            self.state = 307
            self.match(govdslParser.T__14)
            self.state = 308
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_participantExclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantExclusion" ):
                listener.enterParticipantExclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantExclusion" ):
                listener.exitParticipantExclusion(self)




    def participantExclusion(self):

        localctx = govdslParser.ParticipantExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_participantExclusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            self.match(govdslParser.T__41)
            self.state = 311
            self.match(govdslParser.T__10)
            self.state = 312
            self.participantID()
            self.state = 317
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==30:
                self.state = 313
                self.match(govdslParser.T__29)
                self.state = 314
                self.participantID()
                self.state = 319
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinParticipantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minParticipant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinParticipant" ):
                listener.enterMinParticipant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinParticipant" ):
                listener.exitMinParticipant(self)




    def minParticipant(self):

        localctx = govdslParser.MinParticipantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_minParticipant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            self.match(govdslParser.T__42)
            self.state = 321
            self.match(govdslParser.T__10)
            self.state = 322
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VetoRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_vetoRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVetoRight" ):
                listener.enterVetoRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVetoRight" ):
                listener.exitVetoRight(self)




    def vetoRight(self):

        localctx = govdslParser.VetoRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_vetoRight)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(govdslParser.T__43)
            self.state = 325
            self.match(govdslParser.T__10)
            self.state = 326
            self.participantID()
            self.state = 331
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==30:
                self.state = 327
                self.match(govdslParser.T__29)
                self.state = 328
                self.participantID()
                self.state = 333
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            self.match(govdslParser.T__44)
            self.state = 335
            self.match(govdslParser.T__10)
            self.state = 338
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [46]:
                self.state = 336
                self.votParams()
                pass
            elif token in [47]:
                self.state = 337
                self.default()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_votParams)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 340
            self.ratio()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.match(govdslParser.T__45)
            self.state = 343
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 345
            self.match(govdslParser.T__46)
            self.state = 346
            self.nestedPolicy()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PassedTestsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_passedTests

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPassedTests" ):
                listener.enterPassedTests(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPassedTests" ):
                listener.exitPassedTests(self)




    def passedTests(self):

        localctx = govdslParser.PassedTestsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_passedTests)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            self.match(govdslParser.T__47)
            self.state = 349
            self.match(govdslParser.T__10)
            self.state = 350
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def carryOver(self):
            return self.getTypedRuleContext(govdslParser.CarryOverContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 352
            self.match(govdslParser.T__48)
            self.state = 353
            self.match(govdslParser.T__10)

            self.state = 354
            self.orderType()
            self.state = 355
            self.orderMode()
            self.state = 357
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==54:
                self.state = 356
                self.carryOver()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderTypeValue(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_orderType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self.match(govdslParser.T__49)
            self.state = 360
            self.match(govdslParser.T__10)
            self.state = 361
            self.orderTypeValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderTypeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderTypeValue" ):
                listener.enterOrderTypeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderTypeValue" ):
                listener.exitOrderTypeValue(self)




    def orderTypeValue(self):

        localctx = govdslParser.OrderTypeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_orderTypeValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            _la = self._input.LA(1)
            if not(_la==51 or _la==52):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_orderMode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            self.match(govdslParser.T__52)
            self.state = 366
            self.match(govdslParser.T__10)
            self.state = 367
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CarryOverContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_carryOver

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCarryOver" ):
                listener.enterCarryOver(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCarryOver" ):
                listener.exitCarryOver(self)




    def carryOver(self):

        localctx = govdslParser.CarryOverContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_carryOver)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 369
            self.match(govdslParser.T__53)
            self.state = 370
            self.match(govdslParser.T__10)
            self.state = 371
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = govdslParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            _la = self._input.LA(1)
            if not(_la==55 or _la==56):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.NestedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.NestedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 375
            self.match(govdslParser.T__56)
            self.state = 376
            self.match(govdslParser.T__0)
            self.state = 378 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 377
                self.nestedPolicy()
                self.state = 380 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 382
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedSinglePolicyContext,0)


        def nestedComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPolicy" ):
                listener.enterNestedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPolicy" ):
                listener.exitNestedPolicy(self)




    def nestedPolicy(self):

        localctx = govdslParser.NestedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_nestedPolicy)
        try:
            self.state = 386
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 384
                self.nestedSinglePolicy()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 385
                self.nestedComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





