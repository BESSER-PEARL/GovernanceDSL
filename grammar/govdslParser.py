# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,56,362,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,1,0,1,0,3,0,97,8,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,3,1,106,8,1,
        1,1,3,1,109,8,1,1,1,3,1,112,8,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,3,2,
        121,8,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,3,3,130,8,3,1,3,3,3,133,8,3,
        1,3,3,3,136,8,3,1,3,1,3,1,4,1,4,1,4,1,4,3,4,144,8,4,1,4,1,4,1,4,
        1,5,1,5,1,6,1,6,1,6,1,6,1,6,3,6,156,8,6,1,7,1,7,1,7,1,7,1,7,1,7,
        1,7,3,7,165,8,7,1,8,1,8,1,9,1,9,1,9,3,9,172,8,9,1,10,1,10,1,10,1,
        11,1,11,1,11,1,11,3,11,181,8,11,1,11,1,11,1,11,1,11,1,12,1,12,1,
        13,1,13,1,13,3,13,192,8,13,1,14,1,14,1,14,1,15,1,15,1,15,1,15,1,
        16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,1,19,1,19,1,19,1,19,1,19,5,
        19,214,8,19,10,19,12,19,217,9,19,1,20,1,20,1,20,1,20,3,20,223,8,
        20,1,20,1,20,3,20,227,8,20,3,20,229,8,20,1,21,1,21,1,21,1,21,1,21,
        5,21,236,8,21,10,21,12,21,239,9,21,1,22,1,22,1,23,1,23,1,23,1,23,
        1,23,5,23,248,8,23,10,23,12,23,251,9,23,1,24,1,24,3,24,255,8,24,
        1,24,3,24,258,8,24,1,25,1,25,1,25,1,26,1,26,1,26,1,27,1,27,1,27,
        3,27,269,8,27,1,27,3,27,272,8,27,1,28,1,28,1,28,1,28,1,28,1,28,1,
        28,1,28,1,28,3,28,283,8,28,1,29,1,29,1,29,1,30,1,30,1,31,1,31,1,
        32,1,32,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,33,1,33,1,34,1,34,1,
        34,1,34,3,34,307,8,34,1,35,1,35,1,35,1,35,1,35,1,35,3,35,315,8,35,
        1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,1,39,1,39,1,39,1,39,
        1,39,3,39,331,8,39,1,40,1,40,1,40,1,40,1,41,1,41,1,42,1,42,1,42,
        1,42,1,43,1,43,1,43,1,43,1,44,1,44,1,45,1,45,1,45,4,45,352,8,45,
        11,45,12,45,353,1,45,1,45,1,46,1,46,3,46,360,8,46,1,46,0,0,47,0,
        2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,
        48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,
        92,0,7,1,0,4,6,1,0,15,17,1,0,19,21,1,0,23,25,1,0,35,38,1,0,46,47,
        1,0,50,51,348,0,96,1,0,0,0,2,100,1,0,0,0,4,115,1,0,0,0,6,125,1,0,
        0,0,8,139,1,0,0,0,10,148,1,0,0,0,12,150,1,0,0,0,14,157,1,0,0,0,16,
        166,1,0,0,0,18,168,1,0,0,0,20,173,1,0,0,0,22,176,1,0,0,0,24,186,
        1,0,0,0,26,191,1,0,0,0,28,193,1,0,0,0,30,196,1,0,0,0,32,200,1,0,
        0,0,34,202,1,0,0,0,36,206,1,0,0,0,38,208,1,0,0,0,40,218,1,0,0,0,
        42,230,1,0,0,0,44,240,1,0,0,0,46,242,1,0,0,0,48,252,1,0,0,0,50,259,
        1,0,0,0,52,262,1,0,0,0,54,265,1,0,0,0,56,273,1,0,0,0,58,284,1,0,
        0,0,60,287,1,0,0,0,62,289,1,0,0,0,64,291,1,0,0,0,66,297,1,0,0,0,
        68,302,1,0,0,0,70,314,1,0,0,0,72,316,1,0,0,0,74,319,1,0,0,0,76,322,
        1,0,0,0,78,325,1,0,0,0,80,332,1,0,0,0,82,336,1,0,0,0,84,338,1,0,
        0,0,86,342,1,0,0,0,88,346,1,0,0,0,90,348,1,0,0,0,92,359,1,0,0,0,
        94,97,3,2,1,0,95,97,3,4,2,0,96,94,1,0,0,0,96,95,1,0,0,0,97,98,1,
        0,0,0,98,99,5,0,0,1,99,1,1,0,0,0,100,101,3,10,5,0,101,102,5,53,0,
        0,102,103,5,1,0,0,103,105,3,12,6,0,104,106,3,40,20,0,105,104,1,0,
        0,0,105,106,1,0,0,0,106,108,1,0,0,0,107,109,3,54,27,0,108,107,1,
        0,0,0,108,109,1,0,0,0,109,111,1,0,0,0,110,112,3,68,34,0,111,110,
        1,0,0,0,111,112,1,0,0,0,112,113,1,0,0,0,113,114,5,2,0,0,114,3,1,
        0,0,0,115,116,5,3,0,0,116,117,5,53,0,0,117,118,5,1,0,0,118,120,3,
        12,6,0,119,121,3,78,39,0,120,119,1,0,0,0,120,121,1,0,0,0,121,122,
        1,0,0,0,122,123,3,90,45,0,123,124,5,2,0,0,124,5,1,0,0,0,125,126,
        3,10,5,0,126,127,5,53,0,0,127,129,5,1,0,0,128,130,3,40,20,0,129,
        128,1,0,0,0,129,130,1,0,0,0,130,132,1,0,0,0,131,133,3,54,27,0,132,
        131,1,0,0,0,132,133,1,0,0,0,133,135,1,0,0,0,134,136,3,68,34,0,135,
        134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,0,137,138,5,2,0,0,138,
        7,1,0,0,0,139,140,5,3,0,0,140,141,5,53,0,0,141,143,5,1,0,0,142,144,
        3,78,39,0,143,142,1,0,0,0,143,144,1,0,0,0,144,145,1,0,0,0,145,146,
        3,90,45,0,146,147,5,2,0,0,147,9,1,0,0,0,148,149,7,0,0,0,149,11,1,
        0,0,0,150,151,5,7,0,0,151,155,5,8,0,0,152,156,3,14,7,0,153,156,3,
        20,10,0,154,156,3,22,11,0,155,152,1,0,0,0,155,153,1,0,0,0,155,154,
        1,0,0,0,156,13,1,0,0,0,157,158,5,9,0,0,158,164,5,53,0,0,159,160,
        5,10,0,0,160,161,3,16,8,0,161,162,5,8,0,0,162,163,3,18,9,0,163,165,
        1,0,0,0,164,159,1,0,0,0,164,165,1,0,0,0,165,15,1,0,0,0,166,167,5,
        11,0,0,167,17,1,0,0,0,168,171,5,53,0,0,169,170,5,12,0,0,170,172,
        5,53,0,0,171,169,1,0,0,0,171,172,1,0,0,0,172,19,1,0,0,0,173,174,
        5,13,0,0,174,175,5,53,0,0,175,21,1,0,0,0,176,177,5,14,0,0,177,180,
        5,53,0,0,178,179,5,8,0,0,179,181,3,24,12,0,180,178,1,0,0,0,180,181,
        1,0,0,0,181,182,1,0,0,0,182,183,5,1,0,0,183,184,3,26,13,0,184,185,
        5,2,0,0,185,23,1,0,0,0,186,187,7,1,0,0,187,25,1,0,0,0,188,192,3,
        30,15,0,189,192,3,34,17,0,190,192,3,28,14,0,191,188,1,0,0,0,191,
        189,1,0,0,0,191,190,1,0,0,0,192,27,1,0,0,0,193,194,3,34,17,0,194,
        195,3,38,19,0,195,29,1,0,0,0,196,197,5,18,0,0,197,198,5,8,0,0,198,
        199,3,32,16,0,199,31,1,0,0,0,200,201,7,2,0,0,201,33,1,0,0,0,202,
        203,5,22,0,0,203,204,5,8,0,0,204,205,3,36,18,0,205,35,1,0,0,0,206,
        207,7,3,0,0,207,37,1,0,0,0,208,209,5,26,0,0,209,210,5,8,0,0,210,
        215,5,53,0,0,211,212,5,27,0,0,212,214,5,53,0,0,213,211,1,0,0,0,214,
        217,1,0,0,0,215,213,1,0,0,0,215,216,1,0,0,0,216,39,1,0,0,0,217,215,
        1,0,0,0,218,219,5,28,0,0,219,228,5,8,0,0,220,222,3,42,21,0,221,223,
        3,46,23,0,222,221,1,0,0,0,222,223,1,0,0,0,223,229,1,0,0,0,224,226,
        3,46,23,0,225,227,3,42,21,0,226,225,1,0,0,0,226,227,1,0,0,0,227,
        229,1,0,0,0,228,220,1,0,0,0,228,224,1,0,0,0,229,41,1,0,0,0,230,231,
        5,29,0,0,231,232,5,8,0,0,232,237,3,44,22,0,233,234,5,27,0,0,234,
        236,3,44,22,0,235,233,1,0,0,0,236,239,1,0,0,0,237,235,1,0,0,0,237,
        238,1,0,0,0,238,43,1,0,0,0,239,237,1,0,0,0,240,241,5,53,0,0,241,
        45,1,0,0,0,242,243,5,30,0,0,243,244,5,8,0,0,244,249,3,48,24,0,245,
        246,5,27,0,0,246,248,3,48,24,0,247,245,1,0,0,0,248,251,1,0,0,0,249,
        247,1,0,0,0,249,250,1,0,0,0,250,47,1,0,0,0,251,249,1,0,0,0,252,254,
        3,44,22,0,253,255,3,50,25,0,254,253,1,0,0,0,254,255,1,0,0,0,255,
        257,1,0,0,0,256,258,3,52,26,0,257,256,1,0,0,0,257,258,1,0,0,0,258,
        49,1,0,0,0,259,260,5,31,0,0,260,261,3,44,22,0,261,51,1,0,0,0,262,
        263,5,32,0,0,263,264,5,55,0,0,264,53,1,0,0,0,265,266,5,33,0,0,266,
        268,5,8,0,0,267,269,3,56,28,0,268,267,1,0,0,0,268,269,1,0,0,0,269,
        271,1,0,0,0,270,272,3,66,33,0,271,270,1,0,0,0,271,272,1,0,0,0,272,
        55,1,0,0,0,273,274,5,34,0,0,274,275,3,60,30,0,275,282,5,8,0,0,276,
        283,3,58,29,0,277,283,3,64,32,0,278,279,3,58,29,0,279,280,5,27,0,
        0,280,281,3,64,32,0,281,283,1,0,0,0,282,276,1,0,0,0,282,277,1,0,
        0,0,282,278,1,0,0,0,283,57,1,0,0,0,284,285,5,54,0,0,285,286,3,62,
        31,0,286,59,1,0,0,0,287,288,5,53,0,0,288,61,1,0,0,0,289,290,7,4,
        0,0,290,63,1,0,0,0,291,292,5,54,0,0,292,293,5,12,0,0,293,294,5,54,
        0,0,294,295,5,12,0,0,295,296,5,54,0,0,296,65,1,0,0,0,297,298,5,39,
        0,0,298,299,5,53,0,0,299,300,5,8,0,0,300,301,3,44,22,0,301,67,1,
        0,0,0,302,303,5,40,0,0,303,306,5,8,0,0,304,307,3,70,35,0,305,307,
        3,76,38,0,306,304,1,0,0,0,306,305,1,0,0,0,307,69,1,0,0,0,308,315,
        3,72,36,0,309,315,3,74,37,0,310,311,3,72,36,0,311,312,5,27,0,0,312,
        313,3,74,37,0,313,315,1,0,0,0,314,308,1,0,0,0,314,309,1,0,0,0,314,
        310,1,0,0,0,315,71,1,0,0,0,316,317,5,41,0,0,317,318,5,54,0,0,318,
        73,1,0,0,0,319,320,5,42,0,0,320,321,5,55,0,0,321,75,1,0,0,0,322,
        323,5,43,0,0,323,324,3,92,46,0,324,77,1,0,0,0,325,326,5,44,0,0,326,
        327,5,8,0,0,327,328,3,80,40,0,328,330,3,84,42,0,329,331,3,86,43,
        0,330,329,1,0,0,0,330,331,1,0,0,0,331,79,1,0,0,0,332,333,5,45,0,
        0,333,334,5,8,0,0,334,335,3,82,41,0,335,81,1,0,0,0,336,337,7,5,0,
        0,337,83,1,0,0,0,338,339,5,48,0,0,339,340,5,8,0,0,340,341,3,88,44,
        0,341,85,1,0,0,0,342,343,5,49,0,0,343,344,5,8,0,0,344,345,3,88,44,
        0,345,87,1,0,0,0,346,347,7,6,0,0,347,89,1,0,0,0,348,349,5,52,0,0,
        349,351,5,1,0,0,350,352,3,92,46,0,351,350,1,0,0,0,352,353,1,0,0,
        0,353,351,1,0,0,0,353,354,1,0,0,0,354,355,1,0,0,0,355,356,5,2,0,
        0,356,91,1,0,0,0,357,360,3,6,3,0,358,360,3,8,4,0,359,357,1,0,0,0,
        359,358,1,0,0,0,360,93,1,0,0,0,30,96,105,108,111,120,129,132,135,
        143,155,164,171,180,191,215,222,226,228,237,249,254,257,268,271,
        282,306,314,330,353,359
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'ComposedPolicy'", "'MajorityPolicy'", 
                     "'LeaderDrivenPolicy'", "'AbsoluteMajorityPolicy'", 
                     "'Scope'", "':'", "'Project'", "'from'", "'GitHub'", 
                     "'/'", "'Activity'", "'Task'", "'Issue'", "'Pull request'", 
                     "'All'", "'Status'", "'completed'", "'accepted'", "'partial'", 
                     "'Action'", "'merge'", "'review'", "'release'", "'Labels'", 
                     "','", "'Participants'", "'Roles'", "'Individuals'", 
                     "'as'", "'with confidence'", "'Conditions'", "'Deadline'", 
                     "'days'", "'weeks'", "'months'", "'years'", "'ParticipantExclusion'", 
                     "'Parameters'", "'minVotes'", "'ratio'", "'default'", 
                     "'Order'", "'Execution'", "'sequential'", "'parallel'", 
                     "'RequireAll'", "'CarryOver'", "'true'", "'false'", 
                     "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "ID", "SIGNED_INT", "FLOAT", "WS" ]

    RULE_policy = 0
    RULE_topLevelSinglePolicy = 1
    RULE_topLevelComposedPolicy = 2
    RULE_nestedSinglePolicy = 3
    RULE_nestedComposedPolicy = 4
    RULE_policyType = 5
    RULE_scope = 6
    RULE_project = 7
    RULE_platform = 8
    RULE_repoID = 9
    RULE_activity = 10
    RULE_task = 11
    RULE_taskType = 12
    RULE_taskContent = 13
    RULE_actionWithLabels = 14
    RULE_status = 15
    RULE_statusEnum = 16
    RULE_action = 17
    RULE_actionEnum = 18
    RULE_labels = 19
    RULE_participants = 20
    RULE_roles = 21
    RULE_participantID = 22
    RULE_individuals = 23
    RULE_individual = 24
    RULE_hasRole = 25
    RULE_confidence = 26
    RULE_conditions = 27
    RULE_deadline = 28
    RULE_offset = 29
    RULE_deadlineID = 30
    RULE_timeUnit = 31
    RULE_date = 32
    RULE_participantExclusion = 33
    RULE_parameters = 34
    RULE_votParams = 35
    RULE_minVotes = 36
    RULE_ratio = 37
    RULE_default = 38
    RULE_order = 39
    RULE_orderType = 40
    RULE_orderTypeValue = 41
    RULE_orderMode = 42
    RULE_carryOver = 43
    RULE_booleanValue = 44
    RULE_phases = 45
    RULE_nestedPolicy = 46

    ruleNames =  [ "policy", "topLevelSinglePolicy", "topLevelComposedPolicy", 
                   "nestedSinglePolicy", "nestedComposedPolicy", "policyType", 
                   "scope", "project", "platform", "repoID", "activity", 
                   "task", "taskType", "taskContent", "actionWithLabels", 
                   "status", "statusEnum", "action", "actionEnum", "labels", 
                   "participants", "roles", "participantID", "individuals", 
                   "individual", "hasRole", "confidence", "conditions", 
                   "deadline", "offset", "deadlineID", "timeUnit", "date", 
                   "participantExclusion", "parameters", "votParams", "minVotes", 
                   "ratio", "default", "order", "orderType", "orderTypeValue", 
                   "orderMode", "carryOver", "booleanValue", "phases", "nestedPolicy" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    ID=53
    SIGNED_INT=54
    FLOAT=55
    WS=56

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def topLevelSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelSinglePolicyContext,0)


        def topLevelComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6]:
                self.state = 94
                self.topLevelSinglePolicy()
                pass
            elif token in [3]:
                self.state = 95
                self.topLevelComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 98
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSinglePolicy" ):
                listener.enterTopLevelSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSinglePolicy" ):
                listener.exitTopLevelSinglePolicy(self)




    def topLevelSinglePolicy(self):

        localctx = govdslParser.TopLevelSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_topLevelSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.policyType()
            self.state = 101
            self.match(govdslParser.ID)
            self.state = 102
            self.match(govdslParser.T__0)
            self.state = 103
            self.scope()
            self.state = 105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 104
                self.participants()


            self.state = 108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 107
                self.conditions()


            self.state = 111
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 110
                self.parameters()


            self.state = 113
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelComposedPolicy" ):
                listener.enterTopLevelComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelComposedPolicy" ):
                listener.exitTopLevelComposedPolicy(self)




    def topLevelComposedPolicy(self):

        localctx = govdslParser.TopLevelComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topLevelComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self.match(govdslParser.T__2)
            self.state = 116
            self.match(govdslParser.ID)
            self.state = 117
            self.match(govdslParser.T__0)
            self.state = 118
            self.scope()
            self.state = 120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==44:
                self.state = 119
                self.order()


            self.state = 122
            self.phases()
            self.state = 123
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedSinglePolicy" ):
                listener.enterNestedSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedSinglePolicy" ):
                listener.exitNestedSinglePolicy(self)




    def nestedSinglePolicy(self):

        localctx = govdslParser.NestedSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_nestedSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.policyType()
            self.state = 126
            self.match(govdslParser.ID)
            self.state = 127
            self.match(govdslParser.T__0)
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 128
                self.participants()


            self.state = 132
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 131
                self.conditions()


            self.state = 135
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 134
                self.parameters()


            self.state = 137
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedComposedPolicy" ):
                listener.enterNestedComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedComposedPolicy" ):
                listener.exitNestedComposedPolicy(self)




    def nestedComposedPolicy(self):

        localctx = govdslParser.NestedComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_nestedComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.match(govdslParser.T__2)
            self.state = 140
            self.match(govdslParser.ID)
            self.state = 141
            self.match(govdslParser.T__0)
            self.state = 143
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==44:
                self.state = 142
                self.order()


            self.state = 145
            self.phases()
            self.state = 146
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 112) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self):
            return self.getTypedRuleContext(govdslParser.ProjectContext,0)


        def activity(self):
            return self.getTypedRuleContext(govdslParser.ActivityContext,0)


        def task(self):
            return self.getTypedRuleContext(govdslParser.TaskContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(govdslParser.T__6)
            self.state = 151
            self.match(govdslParser.T__7)
            self.state = 155
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9]:
                self.state = 152
                self.project()
                pass
            elif token in [13]:
                self.state = 153
                self.activity()
                pass
            elif token in [14]:
                self.state = 154
                self.task()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self.match(govdslParser.T__8)
            self.state = 158
            self.match(govdslParser.ID)
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==10:
                self.state = 159
                self.match(govdslParser.T__9)
                self.state = 160
                self.platform()
                self.state = 161
                self.match(govdslParser.T__7)
                self.state = 162
                self.repoID()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.match(govdslParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(govdslParser.ID)
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 169
                self.match(govdslParser.T__11)
                self.state = 170
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_activity)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(govdslParser.T__12)
            self.state = 174
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self.match(govdslParser.T__13)
            self.state = 177
            self.match(govdslParser.ID)
            self.state = 180
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 178
                self.match(govdslParser.T__7)
                self.state = 179
                self.taskType()


            self.state = 182
            self.match(govdslParser.T__0)
            self.state = 183
            self.taskContent()
            self.state = 184
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 229376) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_taskContent)
        try:
            self.state = 191
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 188
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 189
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 190
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.action()
            self.state = 194
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.match(govdslParser.T__17)
            self.state = 197
            self.match(govdslParser.T__7)
            self.state = 198
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.match(govdslParser.T__21)
            self.state = 203
            self.match(govdslParser.T__7)
            self.state = 204
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 58720256) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(govdslParser.T__25)
            self.state = 209
            self.match(govdslParser.T__7)
            self.state = 210
            self.match(govdslParser.ID)
            self.state = 215
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 211
                self.match(govdslParser.T__26)
                self.state = 212
                self.match(govdslParser.ID)
                self.state = 217
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self):
            return self.getTypedRuleContext(govdslParser.RolesContext,0)


        def individuals(self):
            return self.getTypedRuleContext(govdslParser.IndividualsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_participants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.match(govdslParser.T__27)
            self.state = 219
            self.match(govdslParser.T__7)
            self.state = 228
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [29]:
                self.state = 220
                self.roles()
                self.state = 222
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==30:
                    self.state = 221
                    self.individuals()


                pass
            elif token in [30]:
                self.state = 224
                self.individuals()
                self.state = 226
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 225
                    self.roles()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(govdslParser.T__28)
            self.state = 231
            self.match(govdslParser.T__7)
            self.state = 232
            self.participantID()
            self.state = 237
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 233
                self.match(govdslParser.T__26)
                self.state = 234
                self.participantID()
                self.state = 239
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_participantID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantID" ):
                listener.enterParticipantID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantID" ):
                listener.exitParticipantID(self)




    def participantID(self):

        localctx = govdslParser.ParticipantIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_participantID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individual(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            self.match(govdslParser.T__29)
            self.state = 243
            self.match(govdslParser.T__7)
            self.state = 244
            self.individual()
            self.state = 249
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 245
                self.match(govdslParser.T__26)
                self.state = 246
                self.individual()
                self.state = 251
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def confidence(self):
            return self.getTypedRuleContext(govdslParser.ConfidenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividual" ):
                listener.enterIndividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividual" ):
                listener.exitIndividual(self)




    def individual(self):

        localctx = govdslParser.IndividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_individual)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self.participantID()
            self.state = 254
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==31:
                self.state = 253
                self.hasRole()


            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 256
                self.confidence()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 259
            self.match(govdslParser.T__30)
            self.state = 260
            self.participantID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfidenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_confidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfidence" ):
                listener.enterConfidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfidence" ):
                listener.exitConfidence(self)




    def confidence(self):

        localctx = govdslParser.ConfidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_confidence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(govdslParser.T__31)
            self.state = 263
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def participantExclusion(self):
            return self.getTypedRuleContext(govdslParser.ParticipantExclusionContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self.match(govdslParser.T__32)
            self.state = 266
            self.match(govdslParser.T__7)
            self.state = 268
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 267
                self.deadline()


            self.state = 271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 270
                self.participantExclusion()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_deadline)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 273
            self.match(govdslParser.T__33)
            self.state = 274
            self.deadlineID()
            self.state = 275
            self.match(govdslParser.T__7)
            self.state = 282
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.state = 276
                self.offset()
                pass

            elif la_ == 2:
                self.state = 277
                self.date()
                pass

            elif la_ == 3:
                self.state = 278
                self.offset()
                self.state = 279
                self.match(govdslParser.T__26)
                self.state = 280
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self.match(govdslParser.SIGNED_INT)
            self.state = 285
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 515396075520) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            self.match(govdslParser.SIGNED_INT)
            self.state = 292
            self.match(govdslParser.T__11)
            self.state = 293
            self.match(govdslParser.SIGNED_INT)
            self.state = 294
            self.match(govdslParser.T__11)
            self.state = 295
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_participantExclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantExclusion" ):
                listener.enterParticipantExclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantExclusion" ):
                listener.exitParticipantExclusion(self)




    def participantExclusion(self):

        localctx = govdslParser.ParticipantExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_participantExclusion)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self.match(govdslParser.T__38)
            self.state = 298
            self.match(govdslParser.ID)
            self.state = 299
            self.match(govdslParser.T__7)
            self.state = 300
            self.participantID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.match(govdslParser.T__39)
            self.state = 303
            self.match(govdslParser.T__7)
            self.state = 306
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [41, 42]:
                self.state = 304
                self.votParams()
                pass
            elif token in [43]:
                self.state = 305
                self.default()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def minVotes(self):
            return self.getTypedRuleContext(govdslParser.MinVotesContext,0)


        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_votParams)
        try:
            self.state = 314
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 308
                self.minVotes()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 309
                self.ratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 310
                self.minVotes()
                self.state = 311
                self.match(govdslParser.T__26)
                self.state = 312
                self.ratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinVotesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minVotes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinVotes" ):
                listener.enterMinVotes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinVotes" ):
                listener.exitMinVotes(self)




    def minVotes(self):

        localctx = govdslParser.MinVotesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_minVotes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            self.match(govdslParser.T__40)
            self.state = 317
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319
            self.match(govdslParser.T__41)
            self.state = 320
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            self.match(govdslParser.T__42)
            self.state = 323
            self.nestedPolicy()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def carryOver(self):
            return self.getTypedRuleContext(govdslParser.CarryOverContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            self.match(govdslParser.T__43)
            self.state = 326
            self.match(govdslParser.T__7)

            self.state = 327
            self.orderType()
            self.state = 328
            self.orderMode()
            self.state = 330
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 329
                self.carryOver()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderTypeValue(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_orderType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            self.match(govdslParser.T__44)
            self.state = 333
            self.match(govdslParser.T__7)
            self.state = 334
            self.orderTypeValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderTypeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderTypeValue" ):
                listener.enterOrderTypeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderTypeValue" ):
                listener.exitOrderTypeValue(self)




    def orderTypeValue(self):

        localctx = govdslParser.OrderTypeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_orderTypeValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            _la = self._input.LA(1)
            if not(_la==46 or _la==47):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_orderMode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(govdslParser.T__47)
            self.state = 339
            self.match(govdslParser.T__7)
            self.state = 340
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CarryOverContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_carryOver

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCarryOver" ):
                listener.enterCarryOver(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCarryOver" ):
                listener.exitCarryOver(self)




    def carryOver(self):

        localctx = govdslParser.CarryOverContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_carryOver)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.match(govdslParser.T__48)
            self.state = 343
            self.match(govdslParser.T__7)
            self.state = 344
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = govdslParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 346
            _la = self._input.LA(1)
            if not(_la==50 or _la==51):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.NestedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.NestedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            self.match(govdslParser.T__51)
            self.state = 349
            self.match(govdslParser.T__0)
            self.state = 351 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 350
                self.nestedPolicy()
                self.state = 353 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 120) != 0)):
                    break

            self.state = 355
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedSinglePolicyContext,0)


        def nestedComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPolicy" ):
                listener.enterNestedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPolicy" ):
                listener.exitNestedPolicy(self)




    def nestedPolicy(self):

        localctx = govdslParser.NestedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_nestedPolicy)
        try:
            self.state = 359
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 357
                self.nestedSinglePolicy()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 358
                self.nestedComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





