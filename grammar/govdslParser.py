# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,54,336,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,1,0,1,0,1,0,1,1,1,1,3,1,92,8,1,1,2,
        1,2,1,2,1,2,5,2,98,8,2,10,2,12,2,101,9,2,1,2,1,2,1,3,1,3,1,3,1,3,
        5,3,109,8,3,10,3,12,3,112,9,3,1,3,1,3,1,4,1,4,1,4,1,4,3,4,120,8,
        4,1,5,1,5,3,5,124,8,5,1,6,1,6,1,6,1,6,1,6,4,6,131,8,6,11,6,12,6,
        132,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,142,8,7,1,8,1,8,1,9,1,9,1,9,
        3,9,149,8,9,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,3,11,159,8,11,
        1,11,1,11,1,11,1,11,1,12,1,12,1,13,1,13,1,14,1,14,1,14,1,14,1,15,
        1,15,1,15,1,15,3,15,177,8,15,1,16,1,16,1,16,1,16,1,16,5,16,184,8,
        16,10,16,12,16,187,9,16,1,17,1,17,1,18,1,18,1,18,1,18,1,18,5,18,
        196,8,18,10,18,12,18,199,9,18,1,19,1,19,1,19,4,19,204,8,19,11,19,
        12,19,205,1,19,3,19,209,8,19,1,19,3,19,212,8,19,1,20,1,20,1,20,1,
        20,1,20,1,20,1,20,1,20,1,20,3,20,223,8,20,1,21,1,21,1,21,1,22,1,
        22,1,23,1,23,1,24,1,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,
        25,1,25,1,25,1,25,1,25,3,25,247,8,25,1,26,1,26,1,27,1,27,1,27,1,
        28,1,28,1,28,1,29,1,29,1,29,4,29,260,8,29,11,29,12,29,261,1,30,1,
        30,1,30,1,30,1,30,1,30,1,30,1,31,1,31,1,32,1,32,1,33,3,33,276,8,
        33,1,33,3,33,279,8,33,1,33,3,33,282,8,33,1,33,3,33,285,8,33,1,34,
        1,34,1,34,1,34,5,34,291,8,34,10,34,12,34,294,9,34,1,35,1,35,1,35,
        1,36,1,36,1,37,1,37,1,37,1,37,5,37,305,8,37,10,37,12,37,308,9,37,
        1,38,1,38,1,38,1,39,1,39,1,39,1,39,1,39,1,39,1,39,3,39,320,8,39,
        1,40,1,40,1,41,1,41,1,42,1,42,1,42,1,42,4,42,330,8,42,11,42,12,42,
        331,1,42,1,42,1,42,0,0,43,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
        30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
        74,76,78,80,82,84,0,7,1,0,13,15,1,0,17,19,1,0,26,29,1,0,34,36,1,
        0,39,40,1,0,46,47,1,0,48,49,325,0,86,1,0,0,0,2,91,1,0,0,0,4,93,1,
        0,0,0,6,104,1,0,0,0,8,119,1,0,0,0,10,123,1,0,0,0,12,125,1,0,0,0,
        14,134,1,0,0,0,16,143,1,0,0,0,18,145,1,0,0,0,20,150,1,0,0,0,22,154,
        1,0,0,0,24,164,1,0,0,0,26,166,1,0,0,0,28,168,1,0,0,0,30,176,1,0,
        0,0,32,178,1,0,0,0,34,188,1,0,0,0,36,190,1,0,0,0,38,200,1,0,0,0,
        40,213,1,0,0,0,42,224,1,0,0,0,44,227,1,0,0,0,46,229,1,0,0,0,48,231,
        1,0,0,0,50,237,1,0,0,0,52,248,1,0,0,0,54,250,1,0,0,0,56,253,1,0,
        0,0,58,256,1,0,0,0,60,263,1,0,0,0,62,270,1,0,0,0,64,272,1,0,0,0,
        66,275,1,0,0,0,68,286,1,0,0,0,70,295,1,0,0,0,72,298,1,0,0,0,74,300,
        1,0,0,0,76,309,1,0,0,0,78,312,1,0,0,0,80,321,1,0,0,0,82,323,1,0,
        0,0,84,325,1,0,0,0,86,87,3,2,1,0,87,88,5,0,0,1,88,1,1,0,0,0,89,92,
        3,4,2,0,90,92,3,6,3,0,91,89,1,0,0,0,91,90,1,0,0,0,92,3,1,0,0,0,93,
        94,5,1,0,0,94,95,5,51,0,0,95,99,5,2,0,0,96,98,3,8,4,0,97,96,1,0,
        0,0,98,101,1,0,0,0,99,97,1,0,0,0,99,100,1,0,0,0,100,102,1,0,0,0,
        101,99,1,0,0,0,102,103,5,3,0,0,103,5,1,0,0,0,104,105,5,4,0,0,105,
        106,5,51,0,0,106,110,5,2,0,0,107,109,3,10,5,0,108,107,1,0,0,0,109,
        112,1,0,0,0,110,108,1,0,0,0,110,111,1,0,0,0,111,113,1,0,0,0,112,
        110,1,0,0,0,113,114,5,3,0,0,114,7,1,0,0,0,115,120,3,12,6,0,116,120,
        3,30,15,0,117,120,3,38,19,0,118,120,3,58,29,0,119,115,1,0,0,0,119,
        116,1,0,0,0,119,117,1,0,0,0,119,118,1,0,0,0,120,9,1,0,0,0,121,124,
        3,78,39,0,122,124,3,84,42,0,123,121,1,0,0,0,123,122,1,0,0,0,124,
        11,1,0,0,0,125,126,5,5,0,0,126,130,5,6,0,0,127,131,3,14,7,0,128,
        131,3,20,10,0,129,131,3,22,11,0,130,127,1,0,0,0,130,128,1,0,0,0,
        130,129,1,0,0,0,131,132,1,0,0,0,132,130,1,0,0,0,132,133,1,0,0,0,
        133,13,1,0,0,0,134,135,5,7,0,0,135,141,5,51,0,0,136,137,5,8,0,0,
        137,138,3,16,8,0,138,139,5,6,0,0,139,140,3,18,9,0,140,142,1,0,0,
        0,141,136,1,0,0,0,141,142,1,0,0,0,142,15,1,0,0,0,143,144,5,9,0,0,
        144,17,1,0,0,0,145,148,5,51,0,0,146,147,5,10,0,0,147,149,5,51,0,
        0,148,146,1,0,0,0,148,149,1,0,0,0,149,19,1,0,0,0,150,151,5,11,0,
        0,151,152,5,51,0,0,152,153,5,6,0,0,153,21,1,0,0,0,154,155,5,12,0,
        0,155,158,5,51,0,0,156,157,5,6,0,0,157,159,3,24,12,0,158,156,1,0,
        0,0,158,159,1,0,0,0,159,160,1,0,0,0,160,161,5,2,0,0,161,162,3,26,
        13,0,162,163,5,3,0,0,163,23,1,0,0,0,164,165,7,0,0,0,165,25,1,0,0,
        0,166,167,3,28,14,0,167,27,1,0,0,0,168,169,5,16,0,0,169,170,5,6,
        0,0,170,171,7,1,0,0,171,29,1,0,0,0,172,173,5,20,0,0,173,174,5,6,
        0,0,174,177,3,32,16,0,175,177,3,36,18,0,176,172,1,0,0,0,176,175,
        1,0,0,0,177,31,1,0,0,0,178,179,5,21,0,0,179,180,5,6,0,0,180,185,
        3,34,17,0,181,182,5,22,0,0,182,184,3,34,17,0,183,181,1,0,0,0,184,
        187,1,0,0,0,185,183,1,0,0,0,185,186,1,0,0,0,186,33,1,0,0,0,187,185,
        1,0,0,0,188,189,5,51,0,0,189,35,1,0,0,0,190,191,5,23,0,0,191,192,
        5,6,0,0,192,197,3,34,17,0,193,194,5,22,0,0,194,196,3,34,17,0,195,
        193,1,0,0,0,196,199,1,0,0,0,197,195,1,0,0,0,197,198,1,0,0,0,198,
        37,1,0,0,0,199,197,1,0,0,0,200,201,5,24,0,0,201,203,5,6,0,0,202,
        204,3,40,20,0,203,202,1,0,0,0,204,205,1,0,0,0,205,203,1,0,0,0,205,
        206,1,0,0,0,206,208,1,0,0,0,207,209,3,50,25,0,208,207,1,0,0,0,208,
        209,1,0,0,0,209,211,1,0,0,0,210,212,3,56,28,0,211,210,1,0,0,0,211,
        212,1,0,0,0,212,39,1,0,0,0,213,214,5,25,0,0,214,215,3,44,22,0,215,
        222,5,6,0,0,216,223,3,42,21,0,217,223,3,48,24,0,218,219,3,42,21,
        0,219,220,5,22,0,0,220,221,3,48,24,0,221,223,1,0,0,0,222,216,1,0,
        0,0,222,217,1,0,0,0,222,218,1,0,0,0,223,41,1,0,0,0,224,225,5,52,
        0,0,225,226,3,46,23,0,226,43,1,0,0,0,227,228,5,51,0,0,228,45,1,0,
        0,0,229,230,7,2,0,0,230,47,1,0,0,0,231,232,5,52,0,0,232,233,5,10,
        0,0,233,234,5,52,0,0,234,235,5,10,0,0,235,236,5,52,0,0,236,49,1,
        0,0,0,237,238,5,30,0,0,238,239,3,52,26,0,239,246,5,6,0,0,240,247,
        3,54,27,0,241,247,3,56,28,0,242,243,3,54,27,0,243,244,5,22,0,0,244,
        245,3,56,28,0,245,247,1,0,0,0,246,240,1,0,0,0,246,241,1,0,0,0,246,
        242,1,0,0,0,247,51,1,0,0,0,248,249,5,51,0,0,249,53,1,0,0,0,250,251,
        5,31,0,0,251,252,5,52,0,0,252,55,1,0,0,0,253,254,5,32,0,0,254,255,
        5,53,0,0,255,57,1,0,0,0,256,257,5,33,0,0,257,259,5,6,0,0,258,260,
        3,60,30,0,259,258,1,0,0,0,260,261,1,0,0,0,261,259,1,0,0,0,261,262,
        1,0,0,0,262,59,1,0,0,0,263,264,3,62,31,0,264,265,5,6,0,0,265,266,
        3,64,32,0,266,267,5,2,0,0,267,268,3,66,33,0,268,269,5,3,0,0,269,
        61,1,0,0,0,270,271,5,51,0,0,271,63,1,0,0,0,272,273,7,3,0,0,273,65,
        1,0,0,0,274,276,3,68,34,0,275,274,1,0,0,0,275,276,1,0,0,0,276,278,
        1,0,0,0,277,279,3,70,35,0,278,277,1,0,0,0,278,279,1,0,0,0,279,281,
        1,0,0,0,280,282,3,74,37,0,281,280,1,0,0,0,281,282,1,0,0,0,282,284,
        1,0,0,0,283,285,3,76,38,0,284,283,1,0,0,0,284,285,1,0,0,0,285,67,
        1,0,0,0,286,287,5,37,0,0,287,292,3,34,17,0,288,289,5,22,0,0,289,
        291,3,34,17,0,290,288,1,0,0,0,291,294,1,0,0,0,292,290,1,0,0,0,292,
        293,1,0,0,0,293,69,1,0,0,0,294,292,1,0,0,0,295,296,5,38,0,0,296,
        297,3,72,36,0,297,71,1,0,0,0,298,299,7,4,0,0,299,73,1,0,0,0,300,
        301,5,41,0,0,301,306,5,51,0,0,302,303,5,22,0,0,303,305,5,51,0,0,
        304,302,1,0,0,0,305,308,1,0,0,0,306,304,1,0,0,0,306,307,1,0,0,0,
        307,75,1,0,0,0,308,306,1,0,0,0,309,310,5,42,0,0,310,311,3,62,31,
        0,311,77,1,0,0,0,312,313,5,43,0,0,313,314,5,6,0,0,314,319,3,80,40,
        0,315,316,5,44,0,0,316,317,3,82,41,0,317,318,5,45,0,0,318,320,1,
        0,0,0,319,315,1,0,0,0,319,320,1,0,0,0,320,79,1,0,0,0,321,322,7,5,
        0,0,322,81,1,0,0,0,323,324,7,6,0,0,324,83,1,0,0,0,325,326,5,50,0,
        0,326,329,5,2,0,0,327,330,3,4,2,0,328,330,3,6,3,0,329,327,1,0,0,
        0,329,328,1,0,0,0,330,331,1,0,0,0,331,329,1,0,0,0,331,332,1,0,0,
        0,332,333,1,0,0,0,333,334,5,3,0,0,334,85,1,0,0,0,28,91,99,110,119,
        123,130,132,141,148,158,176,185,197,205,208,211,222,246,261,275,
        278,281,284,292,306,319,329,331
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'Policy'", "'{'", "'}'", "'PhasedPolicy'", 
                     "'Scopes'", "':'", "'Project'", "'from'", "'GitHub'", 
                     "'/'", "'Activity'", "'Task'", "'Issue'", "'Pull request'", 
                     "'All'", "'Status'", "'completed'", "'accepted'", "'partial'", 
                     "'Participants'", "'Roles'", "','", "'Individuals'", 
                     "'Conditions'", "'Deadline'", "'days'", "'weeks'", 
                     "'months'", "'years'", "'VotingCondition'", "'minVotes'", 
                     "'ratio'", "'Rules'", "'Majority'", "'LeaderDriven'", 
                     "'Ratio'", "'people'", "'range'", "'Present'", "'Qualified'", 
                     "'conditions'", "'default'", "'Order'", "'('", "')'", 
                     "'Sequential'", "'Parallel'", "'exclusive'", "'inclusive'", 
                     "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "ID", "SIGNED_INT", 
                      "FLOAT", "WS" ]

    RULE_policy = 0
    RULE_policyContent = 1
    RULE_singlePolicy = 2
    RULE_phasedPolicy = 3
    RULE_attributesSingle = 4
    RULE_attributesPhased = 5
    RULE_scopes = 6
    RULE_project = 7
    RULE_platform = 8
    RULE_repoID = 9
    RULE_activity = 10
    RULE_task = 11
    RULE_taskType = 12
    RULE_taskContent = 13
    RULE_status = 14
    RULE_participants = 15
    RULE_roles = 16
    RULE_participantID = 17
    RULE_individuals = 18
    RULE_conditions = 19
    RULE_deadline = 20
    RULE_offset = 21
    RULE_deadlineID = 22
    RULE_timeUnit = 23
    RULE_date = 24
    RULE_votingCondition = 25
    RULE_voteConditionID = 26
    RULE_minVotes = 27
    RULE_ratio = 28
    RULE_rules = 29
    RULE_rule = 30
    RULE_ruleID = 31
    RULE_ruleType = 32
    RULE_ruleContent = 33
    RULE_people = 34
    RULE_rangeType = 35
    RULE_rangeID = 36
    RULE_ruleConditions = 37
    RULE_default = 38
    RULE_order = 39
    RULE_orderType = 40
    RULE_orderMode = 41
    RULE_phases = 42

    ruleNames =  [ "policy", "policyContent", "singlePolicy", "phasedPolicy", 
                   "attributesSingle", "attributesPhased", "scopes", "project", 
                   "platform", "repoID", "activity", "task", "taskType", 
                   "taskContent", "status", "participants", "roles", "participantID", 
                   "individuals", "conditions", "deadline", "offset", "deadlineID", 
                   "timeUnit", "date", "votingCondition", "voteConditionID", 
                   "minVotes", "ratio", "rules", "rule", "ruleID", "ruleType", 
                   "ruleContent", "people", "rangeType", "rangeID", "ruleConditions", 
                   "default", "order", "orderType", "orderMode", "phases" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    ID=51
    SIGNED_INT=52
    FLOAT=53
    WS=54

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyContent(self):
            return self.getTypedRuleContext(govdslParser.PolicyContentContext,0)


        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.policyContent()
            self.state = 87
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singlePolicy(self):
            return self.getTypedRuleContext(govdslParser.SinglePolicyContext,0)


        def phasedPolicy(self):
            return self.getTypedRuleContext(govdslParser.PhasedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policyContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyContent" ):
                listener.enterPolicyContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyContent" ):
                listener.exitPolicyContent(self)




    def policyContent(self):

        localctx = govdslParser.PolicyContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_policyContent)
        try:
            self.state = 91
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1]:
                self.enterOuterAlt(localctx, 1)
                self.state = 89
                self.singlePolicy()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 90
                self.phasedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def attributesSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.AttributesSingleContext)
            else:
                return self.getTypedRuleContext(govdslParser.AttributesSingleContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_singlePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSinglePolicy" ):
                listener.enterSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSinglePolicy" ):
                listener.exitSinglePolicy(self)




    def singlePolicy(self):

        localctx = govdslParser.SinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_singlePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.match(govdslParser.T__0)
            self.state = 94
            self.match(govdslParser.ID)
            self.state = 95
            self.match(govdslParser.T__1)
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 8616149024) != 0):
                self.state = 96
                self.attributesSingle()
                self.state = 101
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 102
            self.match(govdslParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def attributesPhased(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.AttributesPhasedContext)
            else:
                return self.getTypedRuleContext(govdslParser.AttributesPhasedContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phasedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhasedPolicy" ):
                listener.enterPhasedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhasedPolicy" ):
                listener.exitPhasedPolicy(self)




    def phasedPolicy(self):

        localctx = govdslParser.PhasedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_phasedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.match(govdslParser.T__3)
            self.state = 105
            self.match(govdslParser.ID)
            self.state = 106
            self.match(govdslParser.T__1)
            self.state = 110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==43 or _la==50:
                self.state = 107
                self.attributesPhased()
                self.state = 112
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 113
            self.match(govdslParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributesSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scopes(self):
            return self.getTypedRuleContext(govdslParser.ScopesContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def rules(self):
            return self.getTypedRuleContext(govdslParser.RulesContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_attributesSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributesSingle" ):
                listener.enterAttributesSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributesSingle" ):
                listener.exitAttributesSingle(self)




    def attributesSingle(self):

        localctx = govdslParser.AttributesSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_attributesSingle)
        try:
            self.state = 119
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 115
                self.scopes()
                pass
            elif token in [20, 23]:
                self.enterOuterAlt(localctx, 2)
                self.state = 116
                self.participants()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 3)
                self.state = 117
                self.conditions()
                pass
            elif token in [33]:
                self.enterOuterAlt(localctx, 4)
                self.state = 118
                self.rules()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributesPhasedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_attributesPhased

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributesPhased" ):
                listener.enterAttributesPhased(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributesPhased" ):
                listener.exitAttributesPhased(self)




    def attributesPhased(self):

        localctx = govdslParser.AttributesPhasedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_attributesPhased)
        try:
            self.state = 123
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [43]:
                self.enterOuterAlt(localctx, 1)
                self.state = 121
                self.order()
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 2)
                self.state = 122
                self.phases()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProjectContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProjectContext,i)


        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_scopes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopes" ):
                listener.enterScopes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopes" ):
                listener.exitScopes(self)




    def scopes(self):

        localctx = govdslParser.ScopesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_scopes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(govdslParser.T__4)
            self.state = 126
            self.match(govdslParser.T__5)
            self.state = 130 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 130
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [7]:
                    self.state = 127
                    self.project()
                    pass
                elif token in [11]:
                    self.state = 128
                    self.activity()
                    pass
                elif token in [12]:
                    self.state = 129
                    self.task()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 132 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 6272) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self.match(govdslParser.T__6)
            self.state = 135
            self.match(govdslParser.ID)
            self.state = 141
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 136
                self.match(govdslParser.T__7)
                self.state = 137
                self.platform()
                self.state = 138
                self.match(govdslParser.T__5)
                self.state = 139
                self.repoID()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(govdslParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 145
            self.match(govdslParser.ID)
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==10:
                self.state = 146
                self.match(govdslParser.T__9)
                self.state = 147
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_activity)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(govdslParser.T__10)
            self.state = 151
            self.match(govdslParser.ID)
            self.state = 152
            self.match(govdslParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(govdslParser.T__11)
            self.state = 155
            self.match(govdslParser.ID)
            self.state = 158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 156
                self.match(govdslParser.T__5)
                self.state = 157
                self.taskType()


            self.state = 160
            self.match(govdslParser.T__1)
            self.state = 161
            self.taskContent()
            self.state = 162
            self.match(govdslParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 57344) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_taskContent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.status()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_status)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(govdslParser.T__15)
            self.state = 169
            self.match(govdslParser.T__5)
            self.state = 170
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 917504) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self):
            return self.getTypedRuleContext(govdslParser.RolesContext,0)


        def individuals(self):
            return self.getTypedRuleContext(govdslParser.IndividualsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_participants)
        try:
            self.state = 176
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [20]:
                self.enterOuterAlt(localctx, 1)
                self.state = 172
                self.match(govdslParser.T__19)
                self.state = 173
                self.match(govdslParser.T__5)
                self.state = 174
                self.roles()
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 2)
                self.state = 175
                self.individuals()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.match(govdslParser.T__20)
            self.state = 179
            self.match(govdslParser.T__5)
            self.state = 180
            self.participantID()
            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==22:
                self.state = 181
                self.match(govdslParser.T__21)
                self.state = 182
                self.participantID()
                self.state = 187
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_participantID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantID" ):
                listener.enterParticipantID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantID" ):
                listener.exitParticipantID(self)




    def participantID(self):

        localctx = govdslParser.ParticipantIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_participantID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 188
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(govdslParser.T__22)
            self.state = 191
            self.match(govdslParser.T__5)
            self.state = 192
            self.participantID()
            self.state = 197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==22:
                self.state = 193
                self.match(govdslParser.T__21)
                self.state = 194
                self.participantID()
                self.state = 199
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.DeadlineContext)
            else:
                return self.getTypedRuleContext(govdslParser.DeadlineContext,i)


        def votingCondition(self):
            return self.getTypedRuleContext(govdslParser.VotingConditionContext,0)


        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(govdslParser.T__23)
            self.state = 201
            self.match(govdslParser.T__5)
            self.state = 203 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 202
                self.deadline()
                self.state = 205 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==25):
                    break

            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 207
                self.votingCondition()


            self.state = 211
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 210
                self.ratio()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_deadline)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(govdslParser.T__24)
            self.state = 214
            self.deadlineID()
            self.state = 215
            self.match(govdslParser.T__5)
            self.state = 222
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 216
                self.offset()
                pass

            elif la_ == 2:
                self.state = 217
                self.date()
                pass

            elif la_ == 3:
                self.state = 218
                self.offset()
                self.state = 219
                self.match(govdslParser.T__21)
                self.state = 220
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.match(govdslParser.SIGNED_INT)
            self.state = 225
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 227
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1006632960) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(govdslParser.SIGNED_INT)
            self.state = 232
            self.match(govdslParser.T__9)
            self.state = 233
            self.match(govdslParser.SIGNED_INT)
            self.state = 234
            self.match(govdslParser.T__9)
            self.state = 235
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotingConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def voteConditionID(self):
            return self.getTypedRuleContext(govdslParser.VoteConditionIDContext,0)


        def minVotes(self):
            return self.getTypedRuleContext(govdslParser.MinVotesContext,0)


        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votingCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotingCondition" ):
                listener.enterVotingCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotingCondition" ):
                listener.exitVotingCondition(self)




    def votingCondition(self):

        localctx = govdslParser.VotingConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_votingCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 237
            self.match(govdslParser.T__29)
            self.state = 238
            self.voteConditionID()
            self.state = 239
            self.match(govdslParser.T__5)
            self.state = 246
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.state = 240
                self.minVotes()
                pass

            elif la_ == 2:
                self.state = 241
                self.ratio()
                pass

            elif la_ == 3:
                self.state = 242
                self.minVotes()
                self.state = 243
                self.match(govdslParser.T__21)
                self.state = 244
                self.ratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoteConditionIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_voteConditionID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoteConditionID" ):
                listener.enterVoteConditionID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoteConditionID" ):
                listener.exitVoteConditionID(self)




    def voteConditionID(self):

        localctx = govdslParser.VoteConditionIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_voteConditionID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinVotesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minVotes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinVotes" ):
                listener.enterMinVotes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinVotes" ):
                listener.exitMinVotes(self)




    def minVotes(self):

        localctx = govdslParser.MinVotesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_minVotes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(govdslParser.T__30)
            self.state = 251
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.match(govdslParser.T__31)
            self.state = 254
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rule_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.RuleContext)
            else:
                return self.getTypedRuleContext(govdslParser.RuleContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_rules

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRules" ):
                listener.enterRules(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRules" ):
                listener.exitRules(self)




    def rules(self):

        localctx = govdslParser.RulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_rules)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.match(govdslParser.T__32)
            self.state = 257
            self.match(govdslParser.T__5)
            self.state = 259 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 258
                self.rule_()
                self.state = 261 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==51):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleID(self):
            return self.getTypedRuleContext(govdslParser.RuleIDContext,0)


        def ruleType(self):
            return self.getTypedRuleContext(govdslParser.RuleTypeContext,0)


        def ruleContent(self):
            return self.getTypedRuleContext(govdslParser.RuleContentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRule" ):
                listener.enterRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRule" ):
                listener.exitRule(self)




    def rule_(self):

        localctx = govdslParser.RuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.ruleID()
            self.state = 264
            self.match(govdslParser.T__5)
            self.state = 265
            self.ruleType()
            self.state = 266
            self.match(govdslParser.T__1)
            self.state = 267
            self.ruleContent()
            self.state = 268
            self.match(govdslParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ruleID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleID" ):
                listener.enterRuleID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleID" ):
                listener.exitRuleID(self)




    def ruleID(self):

        localctx = govdslParser.RuleIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_ruleID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_ruleType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleType" ):
                listener.enterRuleType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleType" ):
                listener.exitRuleType(self)




    def ruleType(self):

        localctx = govdslParser.RuleTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_ruleType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 272
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 120259084288) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def people(self):
            return self.getTypedRuleContext(govdslParser.PeopleContext,0)


        def rangeType(self):
            return self.getTypedRuleContext(govdslParser.RangeTypeContext,0)


        def ruleConditions(self):
            return self.getTypedRuleContext(govdslParser.RuleConditionsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_ruleContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleContent" ):
                listener.enterRuleContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleContent" ):
                listener.exitRuleContent(self)




    def ruleContent(self):

        localctx = govdslParser.RuleContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_ruleContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==37:
                self.state = 274
                self.people()


            self.state = 278
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38:
                self.state = 277
                self.rangeType()


            self.state = 281
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 280
                self.ruleConditions()


            self.state = 284
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 283
                self.default()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeopleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_people

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeople" ):
                listener.enterPeople(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeople" ):
                listener.exitPeople(self)




    def people(self):

        localctx = govdslParser.PeopleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_people)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.match(govdslParser.T__36)
            self.state = 287
            self.participantID()
            self.state = 292
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==22:
                self.state = 288
                self.match(govdslParser.T__21)
                self.state = 289
                self.participantID()
                self.state = 294
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RangeTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rangeID(self):
            return self.getTypedRuleContext(govdslParser.RangeIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_rangeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRangeType" ):
                listener.enterRangeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRangeType" ):
                listener.exitRangeType(self)




    def rangeType(self):

        localctx = govdslParser.RangeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_rangeType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self.match(govdslParser.T__37)
            self.state = 296
            self.rangeID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RangeIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_rangeID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRangeID" ):
                listener.enterRangeID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRangeID" ):
                listener.exitRangeID(self)




    def rangeID(self):

        localctx = govdslParser.RangeIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_rangeID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            _la = self._input.LA(1)
            if not(_la==39 or _la==40):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_ruleConditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConditions" ):
                listener.enterRuleConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConditions" ):
                listener.exitRuleConditions(self)




    def ruleConditions(self):

        localctx = govdslParser.RuleConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_ruleConditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(govdslParser.T__40)
            self.state = 301
            self.match(govdslParser.ID)
            self.state = 306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==22:
                self.state = 302
                self.match(govdslParser.T__21)
                self.state = 303
                self.match(govdslParser.ID)
                self.state = 308
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleID(self):
            return self.getTypedRuleContext(govdslParser.RuleIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self.match(govdslParser.T__41)
            self.state = 310
            self.ruleID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 312
            self.match(govdslParser.T__42)
            self.state = 313
            self.match(govdslParser.T__5)
            self.state = 314
            self.orderType()
            self.state = 319
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==44:
                self.state = 315
                self.match(govdslParser.T__43)
                self.state = 316
                self.orderMode()
                self.state = 317
                self.match(govdslParser.T__44)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_orderType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 321
            _la = self._input.LA(1)
            if not(_la==46 or _la==47):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_orderMode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 323
            _la = self._input.LA(1)
            if not(_la==48 or _la==49):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singlePolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.SinglePolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.SinglePolicyContext,i)


        def phasedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PhasedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.PhasedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            self.match(govdslParser.T__49)
            self.state = 326
            self.match(govdslParser.T__1)
            self.state = 329 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 329
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [1]:
                    self.state = 327
                    self.singlePolicy()
                    pass
                elif token in [4]:
                    self.state = 328
                    self.phasedPolicy()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 331 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==1 or _la==4):
                    break

            self.state = 333
            self.match(govdslParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





