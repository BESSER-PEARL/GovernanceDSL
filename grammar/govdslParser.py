# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,51,304,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,1,0,1,0,1,0,1,1,1,1,3,1,90,8,1,1,2,1,2,1,2,1,
        2,5,2,96,8,2,10,2,12,2,99,9,2,1,2,1,2,1,3,1,3,1,4,1,4,1,4,1,4,5,
        4,109,8,4,10,4,12,4,112,9,4,1,4,1,4,1,5,1,5,1,5,1,5,3,5,120,8,5,
        1,6,1,6,3,6,124,8,6,1,7,1,7,1,7,1,7,1,7,3,7,131,8,7,1,8,1,8,1,8,
        1,8,1,8,1,8,1,8,3,8,140,8,8,1,9,1,9,1,10,1,10,1,10,3,10,147,8,10,
        1,11,1,11,1,11,1,12,1,12,1,12,1,12,3,12,156,8,12,1,12,1,12,1,12,
        1,12,1,13,1,13,1,14,1,14,1,14,3,14,167,8,14,1,15,1,15,1,15,1,16,
        1,16,1,16,1,16,1,17,1,17,1,18,1,18,1,18,1,18,1,19,1,19,1,20,1,20,
        1,20,1,20,1,20,5,20,189,8,20,10,20,12,20,192,9,20,1,21,1,21,1,21,
        1,21,3,21,198,8,21,1,22,1,22,1,22,1,22,1,22,5,22,205,8,22,10,22,
        12,22,208,9,22,1,23,1,23,1,24,1,24,1,24,1,24,1,24,5,24,217,8,24,
        10,24,12,24,220,9,24,1,25,1,25,3,25,224,8,25,1,26,1,26,1,26,1,27,
        1,27,1,27,3,27,232,8,27,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,
        1,28,3,28,243,8,28,1,29,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,
        1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,33,3,33,262,8,33,1,34,1,34,
        1,34,1,34,1,34,1,34,3,34,270,8,34,1,35,1,35,1,35,1,36,1,36,1,36,
        1,37,1,37,1,37,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,288,8,38,
        1,39,1,39,1,40,1,40,1,41,1,41,1,41,1,41,4,41,298,8,41,11,41,12,41,
        299,1,41,1,41,1,41,0,0,42,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
        30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
        74,76,78,80,82,0,7,1,0,3,5,1,0,15,17,1,0,19,21,1,0,23,25,1,0,34,
        37,1,0,43,44,1,0,45,46,289,0,84,1,0,0,0,2,89,1,0,0,0,4,91,1,0,0,
        0,6,102,1,0,0,0,8,104,1,0,0,0,10,119,1,0,0,0,12,123,1,0,0,0,14,125,
        1,0,0,0,16,132,1,0,0,0,18,141,1,0,0,0,20,143,1,0,0,0,22,148,1,0,
        0,0,24,151,1,0,0,0,26,161,1,0,0,0,28,166,1,0,0,0,30,168,1,0,0,0,
        32,171,1,0,0,0,34,175,1,0,0,0,36,177,1,0,0,0,38,181,1,0,0,0,40,183,
        1,0,0,0,42,197,1,0,0,0,44,199,1,0,0,0,46,209,1,0,0,0,48,211,1,0,
        0,0,50,221,1,0,0,0,52,225,1,0,0,0,54,228,1,0,0,0,56,233,1,0,0,0,
        58,244,1,0,0,0,60,247,1,0,0,0,62,249,1,0,0,0,64,251,1,0,0,0,66,261,
        1,0,0,0,68,269,1,0,0,0,70,271,1,0,0,0,72,274,1,0,0,0,74,277,1,0,
        0,0,76,280,1,0,0,0,78,289,1,0,0,0,80,291,1,0,0,0,82,293,1,0,0,0,
        84,85,3,2,1,0,85,86,5,0,0,1,86,1,1,0,0,0,87,90,3,4,2,0,88,90,3,8,
        4,0,89,87,1,0,0,0,89,88,1,0,0,0,90,3,1,0,0,0,91,92,3,6,3,0,92,93,
        5,48,0,0,93,97,5,1,0,0,94,96,3,10,5,0,95,94,1,0,0,0,96,99,1,0,0,
        0,97,95,1,0,0,0,97,98,1,0,0,0,98,100,1,0,0,0,99,97,1,0,0,0,100,101,
        5,2,0,0,101,5,1,0,0,0,102,103,7,0,0,0,103,7,1,0,0,0,104,105,5,6,
        0,0,105,106,5,48,0,0,106,110,5,1,0,0,107,109,3,12,6,0,108,107,1,
        0,0,0,109,112,1,0,0,0,110,108,1,0,0,0,110,111,1,0,0,0,111,113,1,
        0,0,0,112,110,1,0,0,0,113,114,5,2,0,0,114,9,1,0,0,0,115,120,3,14,
        7,0,116,120,3,42,21,0,117,120,3,54,27,0,118,120,3,66,33,0,119,115,
        1,0,0,0,119,116,1,0,0,0,119,117,1,0,0,0,119,118,1,0,0,0,120,11,1,
        0,0,0,121,124,3,76,38,0,122,124,3,82,41,0,123,121,1,0,0,0,123,122,
        1,0,0,0,124,13,1,0,0,0,125,126,5,7,0,0,126,130,5,8,0,0,127,131,3,
        16,8,0,128,131,3,22,11,0,129,131,3,24,12,0,130,127,1,0,0,0,130,128,
        1,0,0,0,130,129,1,0,0,0,131,15,1,0,0,0,132,133,5,9,0,0,133,139,5,
        48,0,0,134,135,5,10,0,0,135,136,3,18,9,0,136,137,5,8,0,0,137,138,
        3,20,10,0,138,140,1,0,0,0,139,134,1,0,0,0,139,140,1,0,0,0,140,17,
        1,0,0,0,141,142,5,11,0,0,142,19,1,0,0,0,143,146,5,48,0,0,144,145,
        5,12,0,0,145,147,5,48,0,0,146,144,1,0,0,0,146,147,1,0,0,0,147,21,
        1,0,0,0,148,149,5,13,0,0,149,150,5,48,0,0,150,23,1,0,0,0,151,152,
        5,14,0,0,152,155,5,48,0,0,153,154,5,8,0,0,154,156,3,26,13,0,155,
        153,1,0,0,0,155,156,1,0,0,0,156,157,1,0,0,0,157,158,5,1,0,0,158,
        159,3,28,14,0,159,160,5,2,0,0,160,25,1,0,0,0,161,162,7,1,0,0,162,
        27,1,0,0,0,163,167,3,32,16,0,164,167,3,36,18,0,165,167,3,30,15,0,
        166,163,1,0,0,0,166,164,1,0,0,0,166,165,1,0,0,0,167,29,1,0,0,0,168,
        169,3,36,18,0,169,170,3,40,20,0,170,31,1,0,0,0,171,172,5,18,0,0,
        172,173,5,8,0,0,173,174,3,34,17,0,174,33,1,0,0,0,175,176,7,2,0,0,
        176,35,1,0,0,0,177,178,5,22,0,0,178,179,5,8,0,0,179,180,3,38,19,
        0,180,37,1,0,0,0,181,182,7,3,0,0,182,39,1,0,0,0,183,184,5,26,0,0,
        184,185,5,8,0,0,185,190,5,48,0,0,186,187,5,27,0,0,187,189,5,48,0,
        0,188,186,1,0,0,0,189,192,1,0,0,0,190,188,1,0,0,0,190,191,1,0,0,
        0,191,41,1,0,0,0,192,190,1,0,0,0,193,194,5,28,0,0,194,195,5,8,0,
        0,195,198,3,44,22,0,196,198,3,48,24,0,197,193,1,0,0,0,197,196,1,
        0,0,0,198,43,1,0,0,0,199,200,5,29,0,0,200,201,5,8,0,0,201,206,3,
        46,23,0,202,203,5,27,0,0,203,205,3,46,23,0,204,202,1,0,0,0,205,208,
        1,0,0,0,206,204,1,0,0,0,206,207,1,0,0,0,207,45,1,0,0,0,208,206,1,
        0,0,0,209,210,5,48,0,0,210,47,1,0,0,0,211,212,5,30,0,0,212,213,5,
        8,0,0,213,218,3,50,25,0,214,215,5,27,0,0,215,217,3,50,25,0,216,214,
        1,0,0,0,217,220,1,0,0,0,218,216,1,0,0,0,218,219,1,0,0,0,219,49,1,
        0,0,0,220,218,1,0,0,0,221,223,3,46,23,0,222,224,3,52,26,0,223,222,
        1,0,0,0,223,224,1,0,0,0,224,51,1,0,0,0,225,226,5,31,0,0,226,227,
        3,46,23,0,227,53,1,0,0,0,228,229,5,32,0,0,229,231,5,8,0,0,230,232,
        3,56,28,0,231,230,1,0,0,0,231,232,1,0,0,0,232,55,1,0,0,0,233,234,
        5,33,0,0,234,235,3,60,30,0,235,242,5,8,0,0,236,243,3,58,29,0,237,
        243,3,64,32,0,238,239,3,58,29,0,239,240,5,27,0,0,240,241,3,64,32,
        0,241,243,1,0,0,0,242,236,1,0,0,0,242,237,1,0,0,0,242,238,1,0,0,
        0,243,57,1,0,0,0,244,245,5,49,0,0,245,246,3,62,31,0,246,59,1,0,0,
        0,247,248,5,48,0,0,248,61,1,0,0,0,249,250,7,4,0,0,250,63,1,0,0,0,
        251,252,5,49,0,0,252,253,5,12,0,0,253,254,5,49,0,0,254,255,5,12,
        0,0,255,256,5,49,0,0,256,65,1,0,0,0,257,258,5,38,0,0,258,259,5,8,
        0,0,259,262,3,68,34,0,260,262,3,74,37,0,261,257,1,0,0,0,261,260,
        1,0,0,0,262,67,1,0,0,0,263,270,3,70,35,0,264,270,3,72,36,0,265,266,
        3,70,35,0,266,267,5,27,0,0,267,268,3,72,36,0,268,270,1,0,0,0,269,
        263,1,0,0,0,269,264,1,0,0,0,269,265,1,0,0,0,270,69,1,0,0,0,271,272,
        5,39,0,0,272,273,5,49,0,0,273,71,1,0,0,0,274,275,5,40,0,0,275,276,
        5,50,0,0,276,73,1,0,0,0,277,278,5,41,0,0,278,279,3,2,1,0,279,75,
        1,0,0,0,280,281,5,42,0,0,281,282,5,8,0,0,282,287,3,78,39,0,283,284,
        5,1,0,0,284,285,3,80,40,0,285,286,5,2,0,0,286,288,1,0,0,0,287,283,
        1,0,0,0,287,288,1,0,0,0,288,77,1,0,0,0,289,290,7,5,0,0,290,79,1,
        0,0,0,291,292,7,6,0,0,292,81,1,0,0,0,293,294,5,47,0,0,294,297,5,
        1,0,0,295,298,3,4,2,0,296,298,3,8,4,0,297,295,1,0,0,0,297,296,1,
        0,0,0,298,299,1,0,0,0,299,297,1,0,0,0,299,300,1,0,0,0,300,301,1,
        0,0,0,301,302,5,2,0,0,302,83,1,0,0,0,22,89,97,110,119,123,130,139,
        146,155,166,190,197,206,218,223,231,242,261,269,287,297,299
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'MajorityPolicy'", "'LeaderDrivenPolicy'", 
                     "'AbsoluteMajorityPolicy'", "'PhasedPolicy'", "'Scope'", 
                     "':'", "'Project'", "'from'", "'GitHub'", "'/'", "'Activity'", 
                     "'Task'", "'Issue'", "'Pull request'", "'All'", "'Status'", 
                     "'completed'", "'accepted'", "'partial'", "'Action'", 
                     "'merge'", "'review'", "'release'", "'Labels'", "','", 
                     "'Participants'", "'Roles'", "'Individuals'", "'as'", 
                     "'Conditions'", "'Deadline'", "'days'", "'weeks'", 
                     "'months'", "'years'", "'Parameters'", "'minVotes'", 
                     "'ratio'", "'default'", "'Order'", "'Sequential'", 
                     "'Parallel'", "'exclusive'", "'inclusive'", "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "ID", "SIGNED_INT", "FLOAT", "WS" ]

    RULE_policy = 0
    RULE_policyContent = 1
    RULE_singlePolicy = 2
    RULE_policyType = 3
    RULE_phasedPolicy = 4
    RULE_attributesSingle = 5
    RULE_attributesPhased = 6
    RULE_scope = 7
    RULE_project = 8
    RULE_platform = 9
    RULE_repoID = 10
    RULE_activity = 11
    RULE_task = 12
    RULE_taskType = 13
    RULE_taskContent = 14
    RULE_actionWithLabels = 15
    RULE_status = 16
    RULE_statusEnum = 17
    RULE_action = 18
    RULE_actionEnum = 19
    RULE_labels = 20
    RULE_participants = 21
    RULE_roles = 22
    RULE_participantID = 23
    RULE_individuals = 24
    RULE_individualID = 25
    RULE_hasRole = 26
    RULE_conditions = 27
    RULE_deadline = 28
    RULE_offset = 29
    RULE_deadlineID = 30
    RULE_timeUnit = 31
    RULE_date = 32
    RULE_parameters = 33
    RULE_votParams = 34
    RULE_minVotes = 35
    RULE_ratio = 36
    RULE_default = 37
    RULE_order = 38
    RULE_orderType = 39
    RULE_orderMode = 40
    RULE_phases = 41

    ruleNames =  [ "policy", "policyContent", "singlePolicy", "policyType", 
                   "phasedPolicy", "attributesSingle", "attributesPhased", 
                   "scope", "project", "platform", "repoID", "activity", 
                   "task", "taskType", "taskContent", "actionWithLabels", 
                   "status", "statusEnum", "action", "actionEnum", "labels", 
                   "participants", "roles", "participantID", "individuals", 
                   "individualID", "hasRole", "conditions", "deadline", 
                   "offset", "deadlineID", "timeUnit", "date", "parameters", 
                   "votParams", "minVotes", "ratio", "default", "order", 
                   "orderType", "orderMode", "phases" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    ID=48
    SIGNED_INT=49
    FLOAT=50
    WS=51

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyContent(self):
            return self.getTypedRuleContext(govdslParser.PolicyContentContext,0)


        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.policyContent()
            self.state = 85
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singlePolicy(self):
            return self.getTypedRuleContext(govdslParser.SinglePolicyContext,0)


        def phasedPolicy(self):
            return self.getTypedRuleContext(govdslParser.PhasedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policyContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyContent" ):
                listener.enterPolicyContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyContent" ):
                listener.exitPolicyContent(self)




    def policyContent(self):

        localctx = govdslParser.PolicyContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_policyContent)
        try:
            self.state = 89
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 87
                self.singlePolicy()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 2)
                self.state = 88
                self.phasedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def attributesSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.AttributesSingleContext)
            else:
                return self.getTypedRuleContext(govdslParser.AttributesSingleContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_singlePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSinglePolicy" ):
                listener.enterSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSinglePolicy" ):
                listener.exitSinglePolicy(self)




    def singlePolicy(self):

        localctx = govdslParser.SinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_singlePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self.policyType()
            self.state = 92
            self.match(govdslParser.ID)
            self.state = 93
            self.match(govdslParser.T__0)
            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 2479538307200) != 0):
                self.state = 94
                self.attributesSingle()
                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 100
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 56) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def attributesPhased(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.AttributesPhasedContext)
            else:
                return self.getTypedRuleContext(govdslParser.AttributesPhasedContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phasedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhasedPolicy" ):
                listener.enterPhasedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhasedPolicy" ):
                listener.exitPhasedPolicy(self)




    def phasedPolicy(self):

        localctx = govdslParser.PhasedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_phasedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.match(govdslParser.T__5)
            self.state = 105
            self.match(govdslParser.ID)
            self.state = 106
            self.match(govdslParser.T__0)
            self.state = 110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==42 or _la==47:
                self.state = 107
                self.attributesPhased()
                self.state = 112
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 113
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributesSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_attributesSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributesSingle" ):
                listener.enterAttributesSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributesSingle" ):
                listener.exitAttributesSingle(self)




    def attributesSingle(self):

        localctx = govdslParser.AttributesSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_attributesSingle)
        try:
            self.state = 119
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 115
                self.scope()
                pass
            elif token in [28, 30]:
                self.enterOuterAlt(localctx, 2)
                self.state = 116
                self.participants()
                pass
            elif token in [32]:
                self.enterOuterAlt(localctx, 3)
                self.state = 117
                self.conditions()
                pass
            elif token in [38, 41]:
                self.enterOuterAlt(localctx, 4)
                self.state = 118
                self.parameters()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributesPhasedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_attributesPhased

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributesPhased" ):
                listener.enterAttributesPhased(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributesPhased" ):
                listener.exitAttributesPhased(self)




    def attributesPhased(self):

        localctx = govdslParser.AttributesPhasedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_attributesPhased)
        try:
            self.state = 123
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [42]:
                self.enterOuterAlt(localctx, 1)
                self.state = 121
                self.order()
                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 2)
                self.state = 122
                self.phases()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self):
            return self.getTypedRuleContext(govdslParser.ProjectContext,0)


        def activity(self):
            return self.getTypedRuleContext(govdslParser.ActivityContext,0)


        def task(self):
            return self.getTypedRuleContext(govdslParser.TaskContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(govdslParser.T__6)
            self.state = 126
            self.match(govdslParser.T__7)
            self.state = 130
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9]:
                self.state = 127
                self.project()
                pass
            elif token in [13]:
                self.state = 128
                self.activity()
                pass
            elif token in [14]:
                self.state = 129
                self.task()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(govdslParser.T__8)
            self.state = 133
            self.match(govdslParser.ID)
            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==10:
                self.state = 134
                self.match(govdslParser.T__9)
                self.state = 135
                self.platform()
                self.state = 136
                self.match(govdslParser.T__7)
                self.state = 137
                self.repoID()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self.match(govdslParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(govdslParser.ID)
            self.state = 146
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 144
                self.match(govdslParser.T__11)
                self.state = 145
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_activity)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            self.match(govdslParser.T__12)
            self.state = 149
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(govdslParser.T__13)
            self.state = 152
            self.match(govdslParser.ID)
            self.state = 155
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 153
                self.match(govdslParser.T__7)
                self.state = 154
                self.taskType()


            self.state = 157
            self.match(govdslParser.T__0)
            self.state = 158
            self.taskContent()
            self.state = 159
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 229376) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_taskContent)
        try:
            self.state = 166
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 163
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 164
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 165
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.action()
            self.state = 169
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 171
            self.match(govdslParser.T__17)
            self.state = 172
            self.match(govdslParser.T__7)
            self.state = 173
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.match(govdslParser.T__21)
            self.state = 178
            self.match(govdslParser.T__7)
            self.state = 179
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 58720256) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(govdslParser.T__25)
            self.state = 184
            self.match(govdslParser.T__7)
            self.state = 185
            self.match(govdslParser.ID)
            self.state = 190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 186
                self.match(govdslParser.T__26)
                self.state = 187
                self.match(govdslParser.ID)
                self.state = 192
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self):
            return self.getTypedRuleContext(govdslParser.RolesContext,0)


        def individuals(self):
            return self.getTypedRuleContext(govdslParser.IndividualsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_participants)
        try:
            self.state = 197
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [28]:
                self.enterOuterAlt(localctx, 1)
                self.state = 193
                self.match(govdslParser.T__27)
                self.state = 194
                self.match(govdslParser.T__7)
                self.state = 195
                self.roles()
                pass
            elif token in [30]:
                self.enterOuterAlt(localctx, 2)
                self.state = 196
                self.individuals()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(govdslParser.T__28)
            self.state = 200
            self.match(govdslParser.T__7)
            self.state = 201
            self.participantID()
            self.state = 206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 202
                self.match(govdslParser.T__26)
                self.state = 203
                self.participantID()
                self.state = 208
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_participantID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantID" ):
                listener.enterParticipantID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantID" ):
                listener.exitParticipantID(self)




    def participantID(self):

        localctx = govdslParser.ParticipantIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_participantID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individualID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(govdslParser.T__29)
            self.state = 212
            self.match(govdslParser.T__7)
            self.state = 213
            self.individualID()
            self.state = 218
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 214
                self.match(govdslParser.T__26)
                self.state = 215
                self.individualID()
                self.state = 220
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individualID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividualID" ):
                listener.enterIndividualID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividualID" ):
                listener.exitIndividualID(self)




    def individualID(self):

        localctx = govdslParser.IndividualIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_individualID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self.participantID()
            self.state = 223
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==31:
                self.state = 222
                self.hasRole()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            self.match(govdslParser.T__30)
            self.state = 226
            self.participantID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            self.match(govdslParser.T__31)
            self.state = 229
            self.match(govdslParser.T__7)
            self.state = 231
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 230
                self.deadline()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_deadline)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(govdslParser.T__32)
            self.state = 234
            self.deadlineID()
            self.state = 235
            self.match(govdslParser.T__7)
            self.state = 242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 236
                self.offset()
                pass

            elif la_ == 2:
                self.state = 237
                self.date()
                pass

            elif la_ == 3:
                self.state = 238
                self.offset()
                self.state = 239
                self.match(govdslParser.T__26)
                self.state = 240
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self.match(govdslParser.SIGNED_INT)
            self.state = 245
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 257698037760) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self.match(govdslParser.SIGNED_INT)
            self.state = 252
            self.match(govdslParser.T__11)
            self.state = 253
            self.match(govdslParser.SIGNED_INT)
            self.state = 254
            self.match(govdslParser.T__11)
            self.state = 255
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_parameters)
        try:
            self.state = 261
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [38]:
                self.enterOuterAlt(localctx, 1)
                self.state = 257
                self.match(govdslParser.T__37)
                self.state = 258
                self.match(govdslParser.T__7)
                self.state = 259
                self.votParams()
                pass
            elif token in [41]:
                self.enterOuterAlt(localctx, 2)
                self.state = 260
                self.default()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def minVotes(self):
            return self.getTypedRuleContext(govdslParser.MinVotesContext,0)


        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_votParams)
        try:
            self.state = 269
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 263
                self.minVotes()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 264
                self.ratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 265
                self.minVotes()
                self.state = 266
                self.match(govdslParser.T__26)
                self.state = 267
                self.ratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinVotesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minVotes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinVotes" ):
                listener.enterMinVotes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinVotes" ):
                listener.exitMinVotes(self)




    def minVotes(self):

        localctx = govdslParser.MinVotesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_minVotes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.match(govdslParser.T__38)
            self.state = 272
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(govdslParser.T__39)
            self.state = 275
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyContent(self):
            return self.getTypedRuleContext(govdslParser.PolicyContentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self.match(govdslParser.T__40)
            self.state = 278
            self.policyContent()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.match(govdslParser.T__41)
            self.state = 281
            self.match(govdslParser.T__7)
            self.state = 282
            self.orderType()
            self.state = 287
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 283
                self.match(govdslParser.T__0)
                self.state = 284
                self.orderMode()
                self.state = 285
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_orderType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            _la = self._input.LA(1)
            if not(_la==43 or _la==44):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_orderMode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            _la = self._input.LA(1)
            if not(_la==45 or _la==46):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singlePolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.SinglePolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.SinglePolicyContext,i)


        def phasedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PhasedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.PhasedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.match(govdslParser.T__46)
            self.state = 294
            self.match(govdslParser.T__0)
            self.state = 297 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 297
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 4, 5]:
                    self.state = 295
                    self.singlePolicy()
                    pass
                elif token in [6]:
                    self.state = 296
                    self.phasedPolicy()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 299 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 120) != 0)):
                    break

            self.state = 301
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





