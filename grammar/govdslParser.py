# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,79,559,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,65,
        1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,3,1,141,8,1,1,2,1,2,1,2,1,2,1,2,
        1,2,3,2,149,8,2,1,2,3,2,152,8,2,1,2,3,2,155,8,2,1,2,1,2,1,3,1,3,
        1,3,1,3,1,3,3,3,164,8,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,4,3,4,174,
        8,4,1,4,3,4,177,8,4,1,4,3,4,180,8,4,1,4,1,4,1,5,1,5,1,5,1,5,3,5,
        188,8,5,1,5,1,5,1,5,1,6,1,6,1,7,1,7,1,7,1,7,1,7,3,7,200,8,7,1,8,
        1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,3,9,213,8,9,1,9,1,9,1,9,
        1,9,4,9,219,8,9,11,9,12,9,220,1,9,1,9,3,9,225,8,9,1,10,1,10,1,11,
        1,11,1,11,3,11,232,8,11,1,12,1,12,1,12,1,13,1,13,1,13,1,13,1,13,
        4,13,242,8,13,11,13,12,13,243,1,13,1,13,3,13,248,8,13,1,14,1,14,
        1,14,1,15,1,15,1,15,3,15,256,8,15,1,15,1,15,1,15,1,15,3,15,262,8,
        15,1,16,1,16,1,17,1,17,1,17,3,17,269,8,17,1,18,1,18,1,18,1,19,1,
        19,1,19,1,19,1,20,1,20,1,21,1,21,1,21,1,21,1,22,1,22,1,23,1,23,1,
        23,1,23,1,23,5,23,291,8,23,10,23,12,23,294,9,23,1,24,1,24,1,24,1,
        24,1,24,3,24,301,8,24,1,25,1,25,1,26,1,26,1,26,1,26,1,26,5,26,310,
        8,26,10,26,12,26,313,9,26,1,27,1,27,1,27,1,27,1,27,5,27,320,8,27,
        10,27,12,27,323,9,27,1,28,1,28,1,28,1,28,3,28,329,8,28,1,28,1,28,
        3,28,333,8,28,3,28,335,8,28,1,29,1,29,1,29,1,29,1,29,5,29,342,8,
        29,10,29,12,29,345,9,29,1,30,1,30,3,30,349,8,30,1,31,1,31,1,31,1,
        31,1,31,5,31,356,8,31,10,31,12,31,359,9,31,1,32,1,32,1,32,1,32,1,
        32,1,32,5,32,367,8,32,10,32,12,32,370,9,32,3,32,372,8,32,1,33,1,
        33,1,34,1,34,1,34,1,34,1,34,5,34,381,8,34,10,34,12,34,384,9,34,1,
        35,1,35,3,35,388,8,35,1,36,1,36,3,36,392,8,36,1,37,1,37,1,37,1,38,
        1,38,1,38,1,39,1,39,1,39,3,39,403,8,39,1,39,3,39,406,8,39,1,40,1,
        40,1,40,1,41,1,41,1,41,3,41,414,8,41,1,41,3,41,417,8,41,1,41,3,41,
        420,8,41,1,41,3,41,423,8,41,1,41,3,41,426,8,41,1,41,5,41,429,8,41,
        10,41,12,41,432,9,41,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,
        3,42,443,8,42,1,43,1,43,1,43,1,44,1,44,1,45,1,45,1,46,1,46,1,46,
        1,46,1,46,1,46,1,47,1,47,1,47,1,47,1,47,5,47,463,8,47,10,47,12,47,
        466,9,47,1,48,1,48,1,48,1,48,1,49,1,49,1,49,1,49,1,49,5,49,477,8,
        49,10,49,12,49,480,9,49,1,50,1,50,3,50,484,8,50,1,50,1,50,1,50,1,
        51,1,51,1,52,1,52,3,52,493,8,52,1,52,3,52,496,8,52,1,52,1,52,1,52,
        1,52,5,52,502,8,52,10,52,12,52,505,9,52,1,53,1,53,1,54,1,54,1,54,
        1,54,3,54,513,8,54,1,55,1,55,1,56,1,56,1,56,1,57,1,57,1,57,1,58,
        1,58,1,58,1,58,1,58,3,58,528,8,58,1,59,1,59,1,59,1,59,1,60,1,60,
        1,61,1,61,1,61,1,61,1,62,1,62,1,62,1,62,1,63,1,63,1,64,1,64,1,64,
        4,64,549,8,64,11,64,12,64,550,1,64,1,64,1,65,1,65,3,65,557,8,65,
        1,65,0,0,66,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,
        38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,
        82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,
        120,122,124,126,128,130,0,9,1,0,4,9,1,0,21,23,1,0,25,27,1,0,29,31,
        1,0,50,53,1,0,58,60,1,0,62,63,1,0,69,70,1,0,73,74,549,0,132,1,0,
        0,0,2,140,1,0,0,0,4,142,1,0,0,0,6,158,1,0,0,0,8,168,1,0,0,0,10,183,
        1,0,0,0,12,192,1,0,0,0,14,194,1,0,0,0,16,201,1,0,0,0,18,205,1,0,
        0,0,20,226,1,0,0,0,22,228,1,0,0,0,24,233,1,0,0,0,26,236,1,0,0,0,
        28,249,1,0,0,0,30,252,1,0,0,0,32,263,1,0,0,0,34,268,1,0,0,0,36,270,
        1,0,0,0,38,273,1,0,0,0,40,277,1,0,0,0,42,279,1,0,0,0,44,283,1,0,
        0,0,46,285,1,0,0,0,48,295,1,0,0,0,50,302,1,0,0,0,52,304,1,0,0,0,
        54,314,1,0,0,0,56,324,1,0,0,0,58,336,1,0,0,0,60,346,1,0,0,0,62,350,
        1,0,0,0,64,360,1,0,0,0,66,373,1,0,0,0,68,375,1,0,0,0,70,387,1,0,
        0,0,72,389,1,0,0,0,74,393,1,0,0,0,76,396,1,0,0,0,78,399,1,0,0,0,
        80,407,1,0,0,0,82,410,1,0,0,0,84,433,1,0,0,0,86,444,1,0,0,0,88,447,
        1,0,0,0,90,449,1,0,0,0,92,451,1,0,0,0,94,457,1,0,0,0,96,467,1,0,
        0,0,98,471,1,0,0,0,100,481,1,0,0,0,102,488,1,0,0,0,104,490,1,0,0,
        0,106,506,1,0,0,0,108,508,1,0,0,0,110,514,1,0,0,0,112,516,1,0,0,
        0,114,519,1,0,0,0,116,522,1,0,0,0,118,529,1,0,0,0,120,533,1,0,0,
        0,122,535,1,0,0,0,124,539,1,0,0,0,126,543,1,0,0,0,128,545,1,0,0,
        0,130,556,1,0,0,0,132,133,3,14,7,0,133,134,3,56,28,0,134,135,3,2,
        1,0,135,136,1,0,0,0,136,137,5,0,0,1,137,1,1,0,0,0,138,141,3,4,2,
        0,139,141,3,6,3,0,140,138,1,0,0,0,140,139,1,0,0,0,141,3,1,0,0,0,
        142,143,3,12,6,0,143,144,5,76,0,0,144,145,5,1,0,0,145,146,3,16,8,
        0,146,148,3,48,24,0,147,149,3,58,29,0,148,147,1,0,0,0,148,149,1,
        0,0,0,149,151,1,0,0,0,150,152,3,82,41,0,151,150,1,0,0,0,151,152,
        1,0,0,0,152,154,1,0,0,0,153,155,3,108,54,0,154,153,1,0,0,0,154,155,
        1,0,0,0,155,156,1,0,0,0,156,157,5,2,0,0,157,5,1,0,0,0,158,159,5,
        3,0,0,159,160,5,76,0,0,160,161,5,1,0,0,161,163,3,16,8,0,162,164,
        3,116,58,0,163,162,1,0,0,0,163,164,1,0,0,0,164,165,1,0,0,0,165,166,
        3,128,64,0,166,167,5,2,0,0,167,7,1,0,0,0,168,169,3,12,6,0,169,170,
        5,76,0,0,170,171,5,1,0,0,171,173,3,48,24,0,172,174,3,58,29,0,173,
        172,1,0,0,0,173,174,1,0,0,0,174,176,1,0,0,0,175,177,3,82,41,0,176,
        175,1,0,0,0,176,177,1,0,0,0,177,179,1,0,0,0,178,180,3,108,54,0,179,
        178,1,0,0,0,179,180,1,0,0,0,180,181,1,0,0,0,181,182,5,2,0,0,182,
        9,1,0,0,0,183,184,5,3,0,0,184,185,5,76,0,0,185,187,5,1,0,0,186,188,
        3,116,58,0,187,186,1,0,0,0,187,188,1,0,0,0,188,189,1,0,0,0,189,190,
        3,128,64,0,190,191,5,2,0,0,191,11,1,0,0,0,192,193,7,0,0,0,193,13,
        1,0,0,0,194,195,5,10,0,0,195,199,5,11,0,0,196,200,3,18,9,0,197,200,
        3,24,12,0,198,200,3,28,14,0,199,196,1,0,0,0,199,197,1,0,0,0,199,
        198,1,0,0,0,200,15,1,0,0,0,201,202,5,12,0,0,202,203,5,11,0,0,203,
        204,5,76,0,0,204,17,1,0,0,0,205,206,5,13,0,0,206,212,5,76,0,0,207,
        208,5,14,0,0,208,209,3,20,10,0,209,210,5,11,0,0,210,211,3,22,11,
        0,211,213,1,0,0,0,212,207,1,0,0,0,212,213,1,0,0,0,213,224,1,0,0,
        0,214,215,5,1,0,0,215,216,5,15,0,0,216,218,5,11,0,0,217,219,3,26,
        13,0,218,217,1,0,0,0,219,220,1,0,0,0,220,218,1,0,0,0,220,221,1,0,
        0,0,221,222,1,0,0,0,222,223,5,2,0,0,223,225,1,0,0,0,224,214,1,0,
        0,0,224,225,1,0,0,0,225,19,1,0,0,0,226,227,5,16,0,0,227,21,1,0,0,
        0,228,231,5,76,0,0,229,230,5,17,0,0,230,232,5,76,0,0,231,229,1,0,
        0,0,231,232,1,0,0,0,232,23,1,0,0,0,233,234,5,18,0,0,234,235,3,26,
        13,0,235,25,1,0,0,0,236,247,5,76,0,0,237,238,5,1,0,0,238,239,5,19,
        0,0,239,241,5,11,0,0,240,242,3,30,15,0,241,240,1,0,0,0,242,243,1,
        0,0,0,243,241,1,0,0,0,243,244,1,0,0,0,244,245,1,0,0,0,245,246,5,
        2,0,0,246,248,1,0,0,0,247,237,1,0,0,0,247,248,1,0,0,0,248,27,1,0,
        0,0,249,250,5,20,0,0,250,251,3,30,15,0,251,29,1,0,0,0,252,255,5,
        76,0,0,253,254,5,11,0,0,254,256,3,32,16,0,255,253,1,0,0,0,255,256,
        1,0,0,0,256,261,1,0,0,0,257,258,5,1,0,0,258,259,3,34,17,0,259,260,
        5,2,0,0,260,262,1,0,0,0,261,257,1,0,0,0,261,262,1,0,0,0,262,31,1,
        0,0,0,263,264,7,1,0,0,264,33,1,0,0,0,265,269,3,38,19,0,266,269,3,
        42,21,0,267,269,3,36,18,0,268,265,1,0,0,0,268,266,1,0,0,0,268,267,
        1,0,0,0,269,35,1,0,0,0,270,271,3,42,21,0,271,272,3,46,23,0,272,37,
        1,0,0,0,273,274,5,24,0,0,274,275,5,11,0,0,275,276,3,40,20,0,276,
        39,1,0,0,0,277,278,7,2,0,0,278,41,1,0,0,0,279,280,5,28,0,0,280,281,
        5,11,0,0,281,282,3,44,22,0,282,43,1,0,0,0,283,284,7,3,0,0,284,45,
        1,0,0,0,285,286,5,32,0,0,286,287,5,11,0,0,287,292,5,76,0,0,288,289,
        5,33,0,0,289,291,5,76,0,0,290,288,1,0,0,0,291,294,1,0,0,0,292,290,
        1,0,0,0,292,293,1,0,0,0,293,47,1,0,0,0,294,292,1,0,0,0,295,296,5,
        34,0,0,296,300,5,35,0,0,297,301,3,50,25,0,298,301,3,52,26,0,299,
        301,3,54,27,0,300,297,1,0,0,0,300,298,1,0,0,0,300,299,1,0,0,0,301,
        49,1,0,0,0,302,303,5,36,0,0,303,51,1,0,0,0,304,305,5,37,0,0,305,
        306,5,11,0,0,306,311,5,76,0,0,307,308,5,33,0,0,308,310,5,76,0,0,
        309,307,1,0,0,0,310,313,1,0,0,0,311,309,1,0,0,0,311,312,1,0,0,0,
        312,53,1,0,0,0,313,311,1,0,0,0,314,315,5,38,0,0,315,316,5,11,0,0,
        316,321,5,76,0,0,317,318,5,33,0,0,318,320,5,76,0,0,319,317,1,0,0,
        0,320,323,1,0,0,0,321,319,1,0,0,0,321,322,1,0,0,0,322,55,1,0,0,0,
        323,321,1,0,0,0,324,325,5,39,0,0,325,334,5,11,0,0,326,328,3,62,31,
        0,327,329,3,68,34,0,328,327,1,0,0,0,328,329,1,0,0,0,329,335,1,0,
        0,0,330,332,3,68,34,0,331,333,3,62,31,0,332,331,1,0,0,0,332,333,
        1,0,0,0,333,335,1,0,0,0,334,326,1,0,0,0,334,330,1,0,0,0,335,57,1,
        0,0,0,336,337,5,40,0,0,337,338,5,11,0,0,338,343,3,60,30,0,339,340,
        5,33,0,0,340,342,3,60,30,0,341,339,1,0,0,0,342,345,1,0,0,0,343,341,
        1,0,0,0,343,344,1,0,0,0,344,59,1,0,0,0,345,343,1,0,0,0,346,348,5,
        76,0,0,347,349,3,74,37,0,348,347,1,0,0,0,348,349,1,0,0,0,349,61,
        1,0,0,0,350,351,5,41,0,0,351,352,5,11,0,0,352,357,3,64,32,0,353,
        354,5,42,0,0,354,356,3,64,32,0,355,353,1,0,0,0,356,359,1,0,0,0,357,
        355,1,0,0,0,357,358,1,0,0,0,358,63,1,0,0,0,359,357,1,0,0,0,360,371,
        5,76,0,0,361,362,5,43,0,0,362,363,5,11,0,0,363,368,3,66,33,0,364,
        365,5,33,0,0,365,367,3,66,33,0,366,364,1,0,0,0,367,370,1,0,0,0,368,
        366,1,0,0,0,368,369,1,0,0,0,369,372,1,0,0,0,370,368,1,0,0,0,371,
        361,1,0,0,0,371,372,1,0,0,0,372,65,1,0,0,0,373,374,5,76,0,0,374,
        67,1,0,0,0,375,376,5,44,0,0,376,377,5,11,0,0,377,382,3,70,35,0,378,
        379,5,33,0,0,379,381,3,70,35,0,380,378,1,0,0,0,381,384,1,0,0,0,382,
        380,1,0,0,0,382,383,1,0,0,0,383,69,1,0,0,0,384,382,1,0,0,0,385,388,
        3,72,36,0,386,388,3,78,39,0,387,385,1,0,0,0,387,386,1,0,0,0,388,
        71,1,0,0,0,389,391,3,66,33,0,390,392,3,76,38,0,391,390,1,0,0,0,391,
        392,1,0,0,0,392,73,1,0,0,0,393,394,5,35,0,0,394,395,3,66,33,0,395,
        75,1,0,0,0,396,397,5,45,0,0,397,398,5,78,0,0,398,77,1,0,0,0,399,
        400,5,46,0,0,400,402,3,66,33,0,401,403,3,76,38,0,402,401,1,0,0,0,
        402,403,1,0,0,0,403,405,1,0,0,0,404,406,3,80,40,0,405,404,1,0,0,
        0,405,406,1,0,0,0,406,79,1,0,0,0,407,408,5,47,0,0,408,409,5,78,0,
        0,409,81,1,0,0,0,410,411,5,48,0,0,411,413,5,11,0,0,412,414,3,84,
        42,0,413,412,1,0,0,0,413,414,1,0,0,0,414,416,1,0,0,0,415,417,3,94,
        47,0,416,415,1,0,0,0,416,417,1,0,0,0,417,419,1,0,0,0,418,420,3,96,
        48,0,419,418,1,0,0,0,419,420,1,0,0,0,420,422,1,0,0,0,421,423,3,98,
        49,0,422,421,1,0,0,0,422,423,1,0,0,0,423,425,1,0,0,0,424,426,3,100,
        50,0,425,424,1,0,0,0,425,426,1,0,0,0,426,430,1,0,0,0,427,429,3,104,
        52,0,428,427,1,0,0,0,429,432,1,0,0,0,430,428,1,0,0,0,430,431,1,0,
        0,0,431,83,1,0,0,0,432,430,1,0,0,0,433,434,5,49,0,0,434,435,3,88,
        44,0,435,442,5,11,0,0,436,443,3,86,43,0,437,443,3,92,46,0,438,439,
        3,86,43,0,439,440,5,33,0,0,440,441,3,92,46,0,441,443,1,0,0,0,442,
        436,1,0,0,0,442,437,1,0,0,0,442,438,1,0,0,0,443,85,1,0,0,0,444,445,
        5,77,0,0,445,446,3,90,45,0,446,87,1,0,0,0,447,448,5,76,0,0,448,89,
        1,0,0,0,449,450,7,4,0,0,450,91,1,0,0,0,451,452,5,77,0,0,452,453,
        5,17,0,0,453,454,5,77,0,0,454,455,5,17,0,0,455,456,5,77,0,0,456,
        93,1,0,0,0,457,458,5,54,0,0,458,459,5,11,0,0,459,464,3,66,33,0,460,
        461,5,33,0,0,461,463,3,66,33,0,462,460,1,0,0,0,463,466,1,0,0,0,464,
        462,1,0,0,0,464,465,1,0,0,0,465,95,1,0,0,0,466,464,1,0,0,0,467,468,
        5,55,0,0,468,469,5,11,0,0,469,470,5,77,0,0,470,97,1,0,0,0,471,472,
        5,56,0,0,472,473,5,11,0,0,473,478,3,66,33,0,474,475,5,33,0,0,475,
        477,3,66,33,0,476,474,1,0,0,0,477,480,1,0,0,0,478,476,1,0,0,0,478,
        479,1,0,0,0,479,99,1,0,0,0,480,478,1,0,0,0,481,483,5,57,0,0,482,
        484,3,102,51,0,483,482,1,0,0,0,483,484,1,0,0,0,484,485,1,0,0,0,485,
        486,5,11,0,0,486,487,3,126,63,0,487,101,1,0,0,0,488,489,7,5,0,0,
        489,103,1,0,0,0,490,492,5,61,0,0,491,493,3,102,51,0,492,491,1,0,
        0,0,492,493,1,0,0,0,493,495,1,0,0,0,494,496,3,106,53,0,495,494,1,
        0,0,0,495,496,1,0,0,0,496,497,1,0,0,0,497,498,5,11,0,0,498,503,5,
        76,0,0,499,500,5,33,0,0,500,502,5,76,0,0,501,499,1,0,0,0,502,505,
        1,0,0,0,503,501,1,0,0,0,503,504,1,0,0,0,504,105,1,0,0,0,505,503,
        1,0,0,0,506,507,7,6,0,0,507,107,1,0,0,0,508,509,5,64,0,0,509,512,
        5,11,0,0,510,513,3,110,55,0,511,513,3,114,57,0,512,510,1,0,0,0,512,
        511,1,0,0,0,513,109,1,0,0,0,514,515,3,112,56,0,515,111,1,0,0,0,516,
        517,5,65,0,0,517,518,5,78,0,0,518,113,1,0,0,0,519,520,5,66,0,0,520,
        521,3,130,65,0,521,115,1,0,0,0,522,523,5,67,0,0,523,524,5,11,0,0,
        524,525,3,118,59,0,525,527,3,122,61,0,526,528,3,124,62,0,527,526,
        1,0,0,0,527,528,1,0,0,0,528,117,1,0,0,0,529,530,5,68,0,0,530,531,
        5,11,0,0,531,532,3,120,60,0,532,119,1,0,0,0,533,534,7,7,0,0,534,
        121,1,0,0,0,535,536,5,71,0,0,536,537,5,11,0,0,537,538,3,126,63,0,
        538,123,1,0,0,0,539,540,5,72,0,0,540,541,5,11,0,0,541,542,3,126,
        63,0,542,125,1,0,0,0,543,544,7,8,0,0,544,127,1,0,0,0,545,546,5,75,
        0,0,546,548,5,1,0,0,547,549,3,130,65,0,548,547,1,0,0,0,549,550,1,
        0,0,0,550,548,1,0,0,0,550,551,1,0,0,0,551,552,1,0,0,0,552,553,5,
        2,0,0,553,129,1,0,0,0,554,557,3,8,4,0,555,557,3,10,5,0,556,554,1,
        0,0,0,556,555,1,0,0,0,557,131,1,0,0,0,53,140,148,151,154,163,173,
        176,179,187,199,212,220,224,231,243,247,255,261,268,292,300,311,
        321,328,332,334,343,348,357,368,371,382,387,391,402,405,413,416,
        419,422,425,430,442,464,478,483,492,495,503,512,527,550,556
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'ComposedPolicy'", "'MajorityPolicy'", 
                     "'LeaderDrivenPolicy'", "'AbsoluteMajorityPolicy'", 
                     "'ConsensusPolicy'", "'LazyConsensusPolicy'", "'VotingPolicy'", 
                     "'Scopes'", "':'", "'Scope'", "'Project'", "'from'", 
                     "'activities'", "'GitHub'", "'/'", "'Activity'", "'tasks'", 
                     "'Task'", "'Issue'", "'Pull request'", "'All'", "'Status'", 
                     "'completed'", "'accepted'", "'partial'", "'Action'", 
                     "'merge'", "'review'", "'release'", "'Labels'", "','", 
                     "'DecisionType'", "'as'", "'BooleanDecision'", "'StringList'", 
                     "'ElementList'", "'Participants'", "'Participant list'", 
                     "'Roles'", "';'", "'composed of'", "'Individuals'", 
                     "'with vote value'", "'(Agent)'", "'with confidence'", 
                     "'Conditions'", "'Deadline'", "'days'", "'weeks'", 
                     "'months'", "'years'", "'ParticipantExclusion'", "'MinParticipants'", 
                     "'VetoRight'", "'PassedTests'", "'pre'", "'post'", 
                     "'concurrent'", "'LabelCondition'", "'include'", "'not'", 
                     "'Parameters'", "'ratio'", "'default'", "'Order'", 
                     "'Execution'", "'sequential'", "'parallel'", "'RequireAll'", 
                     "'CarryOver'", "'true'", "'false'", "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "ID", "SIGNED_INT", "FLOAT", "WS" ]

    RULE_governance = 0
    RULE_policy = 1
    RULE_topLevelSinglePolicy = 2
    RULE_topLevelComposedPolicy = 3
    RULE_nestedSinglePolicy = 4
    RULE_nestedComposedPolicy = 5
    RULE_policyType = 6
    RULE_scopes = 7
    RULE_scope = 8
    RULE_project = 9
    RULE_platform = 10
    RULE_repoID = 11
    RULE_act = 12
    RULE_activity = 13
    RULE_tsk = 14
    RULE_task = 15
    RULE_taskType = 16
    RULE_taskContent = 17
    RULE_actionWithLabels = 18
    RULE_status = 19
    RULE_statusEnum = 20
    RULE_action = 21
    RULE_actionEnum = 22
    RULE_labels = 23
    RULE_decisionType = 24
    RULE_booleanDecision = 25
    RULE_stringList = 26
    RULE_elementList = 27
    RULE_participants = 28
    RULE_policyParticipants = 29
    RULE_partID = 30
    RULE_roles = 31
    RULE_roleID = 32
    RULE_participantID = 33
    RULE_individuals = 34
    RULE_individualEntry = 35
    RULE_individual = 36
    RULE_hasRole = 37
    RULE_voteValue = 38
    RULE_agent = 39
    RULE_confidence = 40
    RULE_conditions = 41
    RULE_deadline = 42
    RULE_offset = 43
    RULE_deadlineID = 44
    RULE_timeUnit = 45
    RULE_date = 46
    RULE_participantExclusion = 47
    RULE_minParticipant = 48
    RULE_vetoRight = 49
    RULE_passedTests = 50
    RULE_evaluationMode = 51
    RULE_labelsCondition = 52
    RULE_include = 53
    RULE_parameters = 54
    RULE_votParams = 55
    RULE_ratio = 56
    RULE_default = 57
    RULE_order = 58
    RULE_orderType = 59
    RULE_orderTypeValue = 60
    RULE_orderMode = 61
    RULE_carryOver = 62
    RULE_booleanValue = 63
    RULE_phases = 64
    RULE_nestedPolicy = 65

    ruleNames =  [ "governance", "policy", "topLevelSinglePolicy", "topLevelComposedPolicy", 
                   "nestedSinglePolicy", "nestedComposedPolicy", "policyType", 
                   "scopes", "scope", "project", "platform", "repoID", "act", 
                   "activity", "tsk", "task", "taskType", "taskContent", 
                   "actionWithLabels", "status", "statusEnum", "action", 
                   "actionEnum", "labels", "decisionType", "booleanDecision", 
                   "stringList", "elementList", "participants", "policyParticipants", 
                   "partID", "roles", "roleID", "participantID", "individuals", 
                   "individualEntry", "individual", "hasRole", "voteValue", 
                   "agent", "confidence", "conditions", "deadline", "offset", 
                   "deadlineID", "timeUnit", "date", "participantExclusion", 
                   "minParticipant", "vetoRight", "passedTests", "evaluationMode", 
                   "labelsCondition", "include", "parameters", "votParams", 
                   "ratio", "default", "order", "orderType", "orderTypeValue", 
                   "orderMode", "carryOver", "booleanValue", "phases", "nestedPolicy" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    ID=76
    SIGNED_INT=77
    FLOAT=78
    WS=79

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class GovernanceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def scopes(self):
            return self.getTypedRuleContext(govdslParser.ScopesContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def policy(self):
            return self.getTypedRuleContext(govdslParser.PolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_governance

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGovernance" ):
                listener.enterGovernance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGovernance" ):
                listener.exitGovernance(self)




    def governance(self):

        localctx = govdslParser.GovernanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_governance)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.scopes()
            self.state = 133
            self.participants()
            self.state = 134
            self.policy()
            self.state = 136
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def topLevelSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelSinglePolicyContext,0)


        def topLevelComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.state = 138
                self.topLevelSinglePolicy()
                pass
            elif token in [3]:
                self.state = 139
                self.topLevelComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSinglePolicy" ):
                listener.enterTopLevelSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSinglePolicy" ):
                listener.exitTopLevelSinglePolicy(self)




    def topLevelSinglePolicy(self):

        localctx = govdslParser.TopLevelSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topLevelSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.policyType()
            self.state = 143
            self.match(govdslParser.ID)
            self.state = 144
            self.match(govdslParser.T__0)
            self.state = 145
            self.scope()
            self.state = 146
            self.decisionType()
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 147
                self.policyParticipants()


            self.state = 151
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 150
                self.conditions()


            self.state = 154
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==64:
                self.state = 153
                self.parameters()


            self.state = 156
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelComposedPolicy" ):
                listener.enterTopLevelComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelComposedPolicy" ):
                listener.exitTopLevelComposedPolicy(self)




    def topLevelComposedPolicy(self):

        localctx = govdslParser.TopLevelComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_topLevelComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(govdslParser.T__2)
            self.state = 159
            self.match(govdslParser.ID)
            self.state = 160
            self.match(govdslParser.T__0)
            self.state = 161
            self.scope()
            self.state = 163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67:
                self.state = 162
                self.order()


            self.state = 165
            self.phases()
            self.state = 166
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedSinglePolicy" ):
                listener.enterNestedSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedSinglePolicy" ):
                listener.exitNestedSinglePolicy(self)




    def nestedSinglePolicy(self):

        localctx = govdslParser.NestedSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_nestedSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.policyType()
            self.state = 169
            self.match(govdslParser.ID)
            self.state = 170
            self.match(govdslParser.T__0)
            self.state = 171
            self.decisionType()
            self.state = 173
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 172
                self.policyParticipants()


            self.state = 176
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 175
                self.conditions()


            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==64:
                self.state = 178
                self.parameters()


            self.state = 181
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedComposedPolicy" ):
                listener.enterNestedComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedComposedPolicy" ):
                listener.exitNestedComposedPolicy(self)




    def nestedComposedPolicy(self):

        localctx = govdslParser.NestedComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_nestedComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(govdslParser.T__2)
            self.state = 184
            self.match(govdslParser.ID)
            self.state = 185
            self.match(govdslParser.T__0)
            self.state = 187
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67:
                self.state = 186
                self.order()


            self.state = 189
            self.phases()
            self.state = 190
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1008) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self):
            return self.getTypedRuleContext(govdslParser.ProjectContext,0)


        def act(self):
            return self.getTypedRuleContext(govdslParser.ActContext,0)


        def tsk(self):
            return self.getTypedRuleContext(govdslParser.TskContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_scopes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopes" ):
                listener.enterScopes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopes" ):
                listener.exitScopes(self)




    def scopes(self):

        localctx = govdslParser.ScopesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_scopes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            self.match(govdslParser.T__9)
            self.state = 195
            self.match(govdslParser.T__10)
            self.state = 199
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [13]:
                self.state = 196
                self.project()
                pass
            elif token in [18]:
                self.state = 197
                self.act()
                pass
            elif token in [20]:
                self.state = 198
                self.tsk()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(govdslParser.T__11)
            self.state = 202
            self.match(govdslParser.T__10)
            self.state = 203
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self.match(govdslParser.T__12)
            self.state = 206
            self.match(govdslParser.ID)
            self.state = 212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 207
                self.match(govdslParser.T__13)
                self.state = 208
                self.platform()
                self.state = 209
                self.match(govdslParser.T__10)
                self.state = 210
                self.repoID()


            self.state = 224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 214
                self.match(govdslParser.T__0)
                self.state = 215
                self.match(govdslParser.T__14)
                self.state = 216
                self.match(govdslParser.T__10)
                self.state = 218 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 217
                    self.activity()
                    self.state = 220 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==76):
                        break

                self.state = 222
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self.match(govdslParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            self.match(govdslParser.ID)
            self.state = 231
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 229
                self.match(govdslParser.T__16)
                self.state = 230
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def activity(self):
            return self.getTypedRuleContext(govdslParser.ActivityContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_act

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAct" ):
                listener.enterAct(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAct" ):
                listener.exitAct(self)




    def act(self):

        localctx = govdslParser.ActContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_act)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(govdslParser.T__17)
            self.state = 234
            self.activity()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_activity)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(govdslParser.ID)
            self.state = 247
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 237
                self.match(govdslParser.T__0)
                self.state = 238
                self.match(govdslParser.T__18)
                self.state = 239
                self.match(govdslParser.T__10)
                self.state = 241 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 240
                    self.task()
                    self.state = 243 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==76):
                        break

                self.state = 245
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def task(self):
            return self.getTypedRuleContext(govdslParser.TaskContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_tsk

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTsk" ):
                listener.enterTsk(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTsk" ):
                listener.exitTsk(self)




    def tsk(self):

        localctx = govdslParser.TskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_tsk)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.match(govdslParser.T__19)
            self.state = 250
            self.task()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self.match(govdslParser.ID)
            self.state = 255
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 253
                self.match(govdslParser.T__10)
                self.state = 254
                self.taskType()


            self.state = 261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 257
                self.match(govdslParser.T__0)
                self.state = 258
                self.taskContent()
                self.state = 259
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 14680064) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_taskContent)
        try:
            self.state = 268
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 265
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 266
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 267
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.action()
            self.state = 271
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 273
            self.match(govdslParser.T__23)
            self.state = 274
            self.match(govdslParser.T__10)
            self.state = 275
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 234881024) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 279
            self.match(govdslParser.T__27)
            self.state = 280
            self.match(govdslParser.T__10)
            self.state = 281
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3758096384) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self.match(govdslParser.T__31)
            self.state = 286
            self.match(govdslParser.T__10)
            self.state = 287
            self.match(govdslParser.ID)
            self.state = 292
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==33:
                self.state = 288
                self.match(govdslParser.T__32)
                self.state = 289
                self.match(govdslParser.ID)
                self.state = 294
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecisionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanDecision(self):
            return self.getTypedRuleContext(govdslParser.BooleanDecisionContext,0)


        def stringList(self):
            return self.getTypedRuleContext(govdslParser.StringListContext,0)


        def elementList(self):
            return self.getTypedRuleContext(govdslParser.ElementListContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_decisionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecisionType" ):
                listener.enterDecisionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecisionType" ):
                listener.exitDecisionType(self)




    def decisionType(self):

        localctx = govdslParser.DecisionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_decisionType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self.match(govdslParser.T__33)
            self.state = 296
            self.match(govdslParser.T__34)
            self.state = 300
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [36]:
                self.state = 297
                self.booleanDecision()
                pass
            elif token in [37]:
                self.state = 298
                self.stringList()
                pass
            elif token in [38]:
                self.state = 299
                self.elementList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanDecision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDecision" ):
                listener.enterBooleanDecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDecision" ):
                listener.exitBooleanDecision(self)




    def booleanDecision(self):

        localctx = govdslParser.BooleanDecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_booleanDecision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.match(govdslParser.T__35)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_stringList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringList" ):
                listener.enterStringList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringList" ):
                listener.exitStringList(self)




    def stringList(self):

        localctx = govdslParser.StringListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_stringList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(govdslParser.T__36)
            self.state = 305
            self.match(govdslParser.T__10)
            self.state = 306
            self.match(govdslParser.ID)
            self.state = 311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==33:
                self.state = 307
                self.match(govdslParser.T__32)
                self.state = 308
                self.match(govdslParser.ID)
                self.state = 313
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_elementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementList" ):
                listener.enterElementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementList" ):
                listener.exitElementList(self)




    def elementList(self):

        localctx = govdslParser.ElementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_elementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 314
            self.match(govdslParser.T__37)
            self.state = 315
            self.match(govdslParser.T__10)
            self.state = 316
            self.match(govdslParser.ID)
            self.state = 321
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==33:
                self.state = 317
                self.match(govdslParser.T__32)
                self.state = 318
                self.match(govdslParser.ID)
                self.state = 323
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self):
            return self.getTypedRuleContext(govdslParser.RolesContext,0)


        def individuals(self):
            return self.getTypedRuleContext(govdslParser.IndividualsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_participants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(govdslParser.T__38)
            self.state = 325
            self.match(govdslParser.T__10)
            self.state = 334
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [41]:
                self.state = 326
                self.roles()
                self.state = 328
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==44:
                    self.state = 327
                    self.individuals()


                pass
            elif token in [44]:
                self.state = 330
                self.individuals()
                self.state = 332
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==41:
                    self.state = 331
                    self.roles()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def partID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PartIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.PartIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_policyParticipants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyParticipants" ):
                listener.enterPolicyParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyParticipants" ):
                listener.exitPolicyParticipants(self)




    def policyParticipants(self):

        localctx = govdslParser.PolicyParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_policyParticipants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.match(govdslParser.T__39)
            self.state = 337
            self.match(govdslParser.T__10)
            self.state = 338
            self.partID()
            self.state = 343
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==33:
                self.state = 339
                self.match(govdslParser.T__32)
                self.state = 340
                self.partID()
                self.state = 345
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_partID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartID" ):
                listener.enterPartID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartID" ):
                listener.exitPartID(self)




    def partID(self):

        localctx = govdslParser.PartIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_partID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 346
            self.match(govdslParser.ID)
            self.state = 348
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 347
                self.hasRole()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roleID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.RoleIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.RoleIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.match(govdslParser.T__40)
            self.state = 351
            self.match(govdslParser.T__10)
            self.state = 352
            self.roleID()
            self.state = 357
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==42:
                self.state = 353
                self.match(govdslParser.T__41)
                self.state = 354
                self.roleID()
                self.state = 359
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roleID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleID" ):
                listener.enterRoleID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleID" ):
                listener.exitRoleID(self)




    def roleID(self):

        localctx = govdslParser.RoleIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_roleID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.match(govdslParser.ID)
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==43:
                self.state = 361
                self.match(govdslParser.T__42)
                self.state = 362
                self.match(govdslParser.T__10)
                self.state = 363
                self.participantID()
                self.state = 368
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==33:
                    self.state = 364
                    self.match(govdslParser.T__32)
                    self.state = 365
                    self.participantID()
                    self.state = 370
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_participantID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantID" ):
                listener.enterParticipantID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantID" ):
                listener.exitParticipantID(self)




    def participantID(self):

        localctx = govdslParser.ParticipantIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_participantID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individualEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualEntryContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualEntryContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 375
            self.match(govdslParser.T__43)
            self.state = 376
            self.match(govdslParser.T__10)
            self.state = 377
            self.individualEntry()
            self.state = 382
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==33:
                self.state = 378
                self.match(govdslParser.T__32)
                self.state = 379
                self.individualEntry()
                self.state = 384
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individual(self):
            return self.getTypedRuleContext(govdslParser.IndividualContext,0)


        def agent(self):
            return self.getTypedRuleContext(govdslParser.AgentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individualEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividualEntry" ):
                listener.enterIndividualEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividualEntry" ):
                listener.exitIndividualEntry(self)




    def individualEntry(self):

        localctx = govdslParser.IndividualEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_individualEntry)
        try:
            self.state = 387
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [76]:
                self.enterOuterAlt(localctx, 1)
                self.state = 385
                self.individual()
                pass
            elif token in [46]:
                self.enterOuterAlt(localctx, 2)
                self.state = 386
                self.agent()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividual" ):
                listener.enterIndividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividual" ):
                listener.exitIndividual(self)




    def individual(self):

        localctx = govdslParser.IndividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_individual)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 389
            self.participantID()
            self.state = 391
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 390
                self.voteValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 393
            self.match(govdslParser.T__34)
            self.state = 394
            self.participantID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoteValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_voteValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoteValue" ):
                listener.enterVoteValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoteValue" ):
                listener.exitVoteValue(self)




    def voteValue(self):

        localctx = govdslParser.VoteValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_voteValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            self.match(govdslParser.T__44)
            self.state = 397
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AgentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def confidence(self):
            return self.getTypedRuleContext(govdslParser.ConfidenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_agent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent" ):
                listener.enterAgent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent" ):
                listener.exitAgent(self)




    def agent(self):

        localctx = govdslParser.AgentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_agent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 399
            self.match(govdslParser.T__45)
            self.state = 400
            self.participantID()
            self.state = 402
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 401
                self.voteValue()


            self.state = 405
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==47:
                self.state = 404
                self.confidence()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfidenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_confidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfidence" ):
                listener.enterConfidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfidence" ):
                listener.exitConfidence(self)




    def confidence(self):

        localctx = govdslParser.ConfidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_confidence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 407
            self.match(govdslParser.T__46)
            self.state = 408
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def participantExclusion(self):
            return self.getTypedRuleContext(govdslParser.ParticipantExclusionContext,0)


        def minParticipant(self):
            return self.getTypedRuleContext(govdslParser.MinParticipantContext,0)


        def vetoRight(self):
            return self.getTypedRuleContext(govdslParser.VetoRightContext,0)


        def passedTests(self):
            return self.getTypedRuleContext(govdslParser.PassedTestsContext,0)


        def labelsCondition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.LabelsConditionContext)
            else:
                return self.getTypedRuleContext(govdslParser.LabelsConditionContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.match(govdslParser.T__47)
            self.state = 411
            self.match(govdslParser.T__10)
            self.state = 413
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 412
                self.deadline()


            self.state = 416
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==54:
                self.state = 415
                self.participantExclusion()


            self.state = 419
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==55:
                self.state = 418
                self.minParticipant()


            self.state = 422
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56:
                self.state = 421
                self.vetoRight()


            self.state = 425
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==57:
                self.state = 424
                self.passedTests()


            self.state = 430
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==61:
                self.state = 427
                self.labelsCondition()
                self.state = 432
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_deadline)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            self.match(govdslParser.T__48)
            self.state = 434
            self.deadlineID()
            self.state = 435
            self.match(govdslParser.T__10)
            self.state = 442
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.state = 436
                self.offset()
                pass

            elif la_ == 2:
                self.state = 437
                self.date()
                pass

            elif la_ == 3:
                self.state = 438
                self.offset()
                self.state = 439
                self.match(govdslParser.T__32)
                self.state = 440
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self.match(govdslParser.SIGNED_INT)
            self.state = 445
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 447
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 449
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 16888498602639360) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 451
            self.match(govdslParser.SIGNED_INT)
            self.state = 452
            self.match(govdslParser.T__16)
            self.state = 453
            self.match(govdslParser.SIGNED_INT)
            self.state = 454
            self.match(govdslParser.T__16)
            self.state = 455
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_participantExclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantExclusion" ):
                listener.enterParticipantExclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantExclusion" ):
                listener.exitParticipantExclusion(self)




    def participantExclusion(self):

        localctx = govdslParser.ParticipantExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_participantExclusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 457
            self.match(govdslParser.T__53)
            self.state = 458
            self.match(govdslParser.T__10)
            self.state = 459
            self.participantID()
            self.state = 464
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==33:
                self.state = 460
                self.match(govdslParser.T__32)
                self.state = 461
                self.participantID()
                self.state = 466
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinParticipantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minParticipant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinParticipant" ):
                listener.enterMinParticipant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinParticipant" ):
                listener.exitMinParticipant(self)




    def minParticipant(self):

        localctx = govdslParser.MinParticipantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_minParticipant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 467
            self.match(govdslParser.T__54)
            self.state = 468
            self.match(govdslParser.T__10)
            self.state = 469
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VetoRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_vetoRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVetoRight" ):
                listener.enterVetoRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVetoRight" ):
                listener.exitVetoRight(self)




    def vetoRight(self):

        localctx = govdslParser.VetoRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_vetoRight)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.match(govdslParser.T__55)
            self.state = 472
            self.match(govdslParser.T__10)
            self.state = 473
            self.participantID()
            self.state = 478
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==33:
                self.state = 474
                self.match(govdslParser.T__32)
                self.state = 475
                self.participantID()
                self.state = 480
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PassedTestsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_passedTests

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPassedTests" ):
                listener.enterPassedTests(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPassedTests" ):
                listener.exitPassedTests(self)




    def passedTests(self):

        localctx = govdslParser.PassedTestsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_passedTests)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 481
            self.match(govdslParser.T__56)
            self.state = 483
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2017612633061982208) != 0):
                self.state = 482
                self.evaluationMode()


            self.state = 485
            self.match(govdslParser.T__10)
            self.state = 486
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EvaluationModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_evaluationMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvaluationMode" ):
                listener.enterEvaluationMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvaluationMode" ):
                listener.exitEvaluationMode(self)




    def evaluationMode(self):

        localctx = govdslParser.EvaluationModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_evaluationMode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 488
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2017612633061982208) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def include(self):
            return self.getTypedRuleContext(govdslParser.IncludeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_labelsCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelsCondition" ):
                listener.enterLabelsCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelsCondition" ):
                listener.exitLabelsCondition(self)




    def labelsCondition(self):

        localctx = govdslParser.LabelsConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_labelsCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 490
            self.match(govdslParser.T__60)
            self.state = 492
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2017612633061982208) != 0):
                self.state = 491
                self.evaluationMode()


            self.state = 495
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==62 or _la==63:
                self.state = 494
                self.include()


            self.state = 497
            self.match(govdslParser.T__10)
            self.state = 498
            self.match(govdslParser.ID)
            self.state = 503
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==33:
                self.state = 499
                self.match(govdslParser.T__32)
                self.state = 500
                self.match(govdslParser.ID)
                self.state = 505
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_include

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude" ):
                listener.enterInclude(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude" ):
                listener.exitInclude(self)




    def include(self):

        localctx = govdslParser.IncludeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_include)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 506
            _la = self._input.LA(1)
            if not(_la==62 or _la==63):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 508
            self.match(govdslParser.T__63)
            self.state = 509
            self.match(govdslParser.T__10)
            self.state = 512
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [65]:
                self.state = 510
                self.votParams()
                pass
            elif token in [66]:
                self.state = 511
                self.default()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_votParams)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 514
            self.ratio()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 516
            self.match(govdslParser.T__64)
            self.state = 517
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 519
            self.match(govdslParser.T__65)
            self.state = 520
            self.nestedPolicy()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def carryOver(self):
            return self.getTypedRuleContext(govdslParser.CarryOverContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            self.match(govdslParser.T__66)
            self.state = 523
            self.match(govdslParser.T__10)

            self.state = 524
            self.orderType()
            self.state = 525
            self.orderMode()
            self.state = 527
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==72:
                self.state = 526
                self.carryOver()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderTypeValue(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_orderType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 529
            self.match(govdslParser.T__67)
            self.state = 530
            self.match(govdslParser.T__10)
            self.state = 531
            self.orderTypeValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderTypeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderTypeValue" ):
                listener.enterOrderTypeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderTypeValue" ):
                listener.exitOrderTypeValue(self)




    def orderTypeValue(self):

        localctx = govdslParser.OrderTypeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_orderTypeValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 533
            _la = self._input.LA(1)
            if not(_la==69 or _la==70):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_orderMode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 535
            self.match(govdslParser.T__70)
            self.state = 536
            self.match(govdslParser.T__10)
            self.state = 537
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CarryOverContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_carryOver

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCarryOver" ):
                listener.enterCarryOver(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCarryOver" ):
                listener.exitCarryOver(self)




    def carryOver(self):

        localctx = govdslParser.CarryOverContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_carryOver)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 539
            self.match(govdslParser.T__71)
            self.state = 540
            self.match(govdslParser.T__10)
            self.state = 541
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = govdslParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            _la = self._input.LA(1)
            if not(_la==73 or _la==74):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.NestedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.NestedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 545
            self.match(govdslParser.T__74)
            self.state = 546
            self.match(govdslParser.T__0)
            self.state = 548 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 547
                self.nestedPolicy()
                self.state = 550 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 552
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedSinglePolicyContext,0)


        def nestedComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPolicy" ):
                listener.enterNestedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPolicy" ):
                listener.exitNestedPolicy(self)




    def nestedPolicy(self):

        localctx = govdslParser.NestedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_nestedPolicy)
        try:
            self.state = 556
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 554
                self.nestedSinglePolicy()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 555
                self.nestedComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





