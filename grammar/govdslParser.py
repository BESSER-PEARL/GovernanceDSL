# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,67,470,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,1,0,1,0,1,0,1,0,1,0,1,0,
        1,1,1,1,3,1,123,8,1,1,2,1,2,1,2,1,2,1,2,3,2,130,8,2,1,2,3,2,133,
        8,2,1,2,3,2,136,8,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,3,3,145,8,3,1,3,
        1,3,1,3,1,4,1,4,1,4,1,4,3,4,154,8,4,1,4,3,4,157,8,4,1,4,3,4,160,
        8,4,1,4,1,4,1,5,1,5,1,5,1,5,3,5,168,8,5,1,5,1,5,1,5,1,6,1,6,1,7,
        1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,3,9,190,
        8,9,1,9,1,9,1,9,1,9,4,9,196,8,9,11,9,12,9,197,1,9,1,9,3,9,202,8,
        9,1,10,1,10,1,11,1,11,1,11,3,11,209,8,11,1,12,1,12,1,12,1,12,1,12,
        4,12,216,8,12,11,12,12,12,217,1,12,1,12,3,12,222,8,12,1,13,1,13,
        1,13,3,13,227,8,13,1,13,1,13,1,13,1,13,1,14,1,14,1,15,1,15,1,15,
        3,15,238,8,15,1,16,1,16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,1,19,
        1,19,1,19,1,19,1,20,1,20,1,21,1,21,1,21,1,21,1,21,5,21,260,8,21,
        10,21,12,21,263,9,21,1,22,1,22,1,22,1,22,3,22,269,8,22,1,22,1,22,
        3,22,273,8,22,3,22,275,8,22,1,23,1,23,1,23,1,23,1,23,5,23,282,8,
        23,10,23,12,23,285,9,23,1,24,1,24,3,24,289,8,24,1,25,1,25,1,25,1,
        25,1,25,5,25,296,8,25,10,25,12,25,299,9,25,1,26,1,26,1,26,1,26,1,
        26,1,26,5,26,307,8,26,10,26,12,26,310,9,26,3,26,312,8,26,1,27,1,
        27,1,28,1,28,1,28,1,28,1,28,5,28,321,8,28,10,28,12,28,324,9,28,1,
        29,1,29,3,29,328,8,29,1,30,1,30,3,30,332,8,30,1,31,1,31,1,31,1,32,
        1,32,1,32,1,33,1,33,1,33,3,33,343,8,33,1,33,3,33,346,8,33,1,34,1,
        34,1,34,1,35,1,35,1,35,3,35,354,8,35,1,35,3,35,357,8,35,1,35,3,35,
        360,8,35,1,35,3,35,363,8,35,1,35,3,35,366,8,35,1,36,1,36,1,36,1,
        36,1,36,1,36,1,36,1,36,1,36,3,36,377,8,36,1,37,1,37,1,37,1,38,1,
        38,1,39,1,39,1,40,1,40,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,1,
        41,5,41,397,8,41,10,41,12,41,400,9,41,1,42,1,42,1,42,1,42,1,43,1,
        43,1,43,1,43,1,43,5,43,411,8,43,10,43,12,43,414,9,43,1,44,1,44,1,
        44,1,44,1,45,1,45,1,45,1,45,3,45,424,8,45,1,46,1,46,1,47,1,47,1,
        47,1,48,1,48,1,48,1,49,1,49,1,49,1,49,1,49,3,49,439,8,49,1,50,1,
        50,1,50,1,50,1,51,1,51,1,52,1,52,1,52,1,52,1,53,1,53,1,53,1,53,1,
        54,1,54,1,55,1,55,1,55,4,55,460,8,55,11,55,12,55,461,1,55,1,55,1,
        56,1,56,3,56,468,8,56,1,56,0,0,57,0,2,4,6,8,10,12,14,16,18,20,22,
        24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
        68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,
        108,110,112,0,7,1,0,4,9,1,0,19,21,1,0,23,25,1,0,27,29,1,0,44,47,
        1,0,57,58,1,0,61,62,457,0,114,1,0,0,0,2,122,1,0,0,0,4,124,1,0,0,
        0,6,139,1,0,0,0,8,149,1,0,0,0,10,163,1,0,0,0,12,172,1,0,0,0,14,174,
        1,0,0,0,16,178,1,0,0,0,18,182,1,0,0,0,20,203,1,0,0,0,22,205,1,0,
        0,0,24,210,1,0,0,0,26,223,1,0,0,0,28,232,1,0,0,0,30,237,1,0,0,0,
        32,239,1,0,0,0,34,242,1,0,0,0,36,246,1,0,0,0,38,248,1,0,0,0,40,252,
        1,0,0,0,42,254,1,0,0,0,44,264,1,0,0,0,46,276,1,0,0,0,48,286,1,0,
        0,0,50,290,1,0,0,0,52,300,1,0,0,0,54,313,1,0,0,0,56,315,1,0,0,0,
        58,327,1,0,0,0,60,329,1,0,0,0,62,333,1,0,0,0,64,336,1,0,0,0,66,339,
        1,0,0,0,68,347,1,0,0,0,70,350,1,0,0,0,72,367,1,0,0,0,74,378,1,0,
        0,0,76,381,1,0,0,0,78,383,1,0,0,0,80,385,1,0,0,0,82,391,1,0,0,0,
        84,401,1,0,0,0,86,405,1,0,0,0,88,415,1,0,0,0,90,419,1,0,0,0,92,425,
        1,0,0,0,94,427,1,0,0,0,96,430,1,0,0,0,98,433,1,0,0,0,100,440,1,0,
        0,0,102,444,1,0,0,0,104,446,1,0,0,0,106,450,1,0,0,0,108,454,1,0,
        0,0,110,456,1,0,0,0,112,467,1,0,0,0,114,115,3,14,7,0,115,116,3,44,
        22,0,116,117,3,2,1,0,117,118,1,0,0,0,118,119,5,0,0,1,119,1,1,0,0,
        0,120,123,3,4,2,0,121,123,3,6,3,0,122,120,1,0,0,0,122,121,1,0,0,
        0,123,3,1,0,0,0,124,125,3,12,6,0,125,126,5,64,0,0,126,127,5,1,0,
        0,127,129,3,16,8,0,128,130,3,46,23,0,129,128,1,0,0,0,129,130,1,0,
        0,0,130,132,1,0,0,0,131,133,3,70,35,0,132,131,1,0,0,0,132,133,1,
        0,0,0,133,135,1,0,0,0,134,136,3,90,45,0,135,134,1,0,0,0,135,136,
        1,0,0,0,136,137,1,0,0,0,137,138,5,2,0,0,138,5,1,0,0,0,139,140,5,
        3,0,0,140,141,5,64,0,0,141,142,5,1,0,0,142,144,3,16,8,0,143,145,
        3,98,49,0,144,143,1,0,0,0,144,145,1,0,0,0,145,146,1,0,0,0,146,147,
        3,110,55,0,147,148,5,2,0,0,148,7,1,0,0,0,149,150,3,12,6,0,150,151,
        5,64,0,0,151,153,5,1,0,0,152,154,3,46,23,0,153,152,1,0,0,0,153,154,
        1,0,0,0,154,156,1,0,0,0,155,157,3,70,35,0,156,155,1,0,0,0,156,157,
        1,0,0,0,157,159,1,0,0,0,158,160,3,90,45,0,159,158,1,0,0,0,159,160,
        1,0,0,0,160,161,1,0,0,0,161,162,5,2,0,0,162,9,1,0,0,0,163,164,5,
        3,0,0,164,165,5,64,0,0,165,167,5,1,0,0,166,168,3,98,49,0,167,166,
        1,0,0,0,167,168,1,0,0,0,168,169,1,0,0,0,169,170,3,110,55,0,170,171,
        5,2,0,0,171,11,1,0,0,0,172,173,7,0,0,0,173,13,1,0,0,0,174,175,5,
        10,0,0,175,176,5,11,0,0,176,177,3,18,9,0,177,15,1,0,0,0,178,179,
        5,12,0,0,179,180,5,11,0,0,180,181,5,64,0,0,181,17,1,0,0,0,182,183,
        5,13,0,0,183,189,5,64,0,0,184,185,5,14,0,0,185,186,3,20,10,0,186,
        187,5,11,0,0,187,188,3,22,11,0,188,190,1,0,0,0,189,184,1,0,0,0,189,
        190,1,0,0,0,190,201,1,0,0,0,191,192,5,1,0,0,192,193,5,15,0,0,193,
        195,5,11,0,0,194,196,3,24,12,0,195,194,1,0,0,0,196,197,1,0,0,0,197,
        195,1,0,0,0,197,198,1,0,0,0,198,199,1,0,0,0,199,200,5,2,0,0,200,
        202,1,0,0,0,201,191,1,0,0,0,201,202,1,0,0,0,202,19,1,0,0,0,203,204,
        5,16,0,0,204,21,1,0,0,0,205,208,5,64,0,0,206,207,5,17,0,0,207,209,
        5,64,0,0,208,206,1,0,0,0,208,209,1,0,0,0,209,23,1,0,0,0,210,221,
        5,64,0,0,211,212,5,1,0,0,212,213,5,18,0,0,213,215,5,11,0,0,214,216,
        3,26,13,0,215,214,1,0,0,0,216,217,1,0,0,0,217,215,1,0,0,0,217,218,
        1,0,0,0,218,219,1,0,0,0,219,220,5,2,0,0,220,222,1,0,0,0,221,211,
        1,0,0,0,221,222,1,0,0,0,222,25,1,0,0,0,223,226,5,64,0,0,224,225,
        5,11,0,0,225,227,3,28,14,0,226,224,1,0,0,0,226,227,1,0,0,0,227,228,
        1,0,0,0,228,229,5,1,0,0,229,230,3,30,15,0,230,231,5,2,0,0,231,27,
        1,0,0,0,232,233,7,1,0,0,233,29,1,0,0,0,234,238,3,34,17,0,235,238,
        3,38,19,0,236,238,3,32,16,0,237,234,1,0,0,0,237,235,1,0,0,0,237,
        236,1,0,0,0,238,31,1,0,0,0,239,240,3,38,19,0,240,241,3,42,21,0,241,
        33,1,0,0,0,242,243,5,22,0,0,243,244,5,11,0,0,244,245,3,36,18,0,245,
        35,1,0,0,0,246,247,7,2,0,0,247,37,1,0,0,0,248,249,5,26,0,0,249,250,
        5,11,0,0,250,251,3,40,20,0,251,39,1,0,0,0,252,253,7,3,0,0,253,41,
        1,0,0,0,254,255,5,30,0,0,255,256,5,11,0,0,256,261,5,64,0,0,257,258,
        5,31,0,0,258,260,5,64,0,0,259,257,1,0,0,0,260,263,1,0,0,0,261,259,
        1,0,0,0,261,262,1,0,0,0,262,43,1,0,0,0,263,261,1,0,0,0,264,265,5,
        32,0,0,265,274,5,11,0,0,266,268,3,50,25,0,267,269,3,56,28,0,268,
        267,1,0,0,0,268,269,1,0,0,0,269,275,1,0,0,0,270,272,3,56,28,0,271,
        273,3,50,25,0,272,271,1,0,0,0,272,273,1,0,0,0,273,275,1,0,0,0,274,
        266,1,0,0,0,274,270,1,0,0,0,275,45,1,0,0,0,276,277,5,33,0,0,277,
        278,5,11,0,0,278,283,3,48,24,0,279,280,5,31,0,0,280,282,3,48,24,
        0,281,279,1,0,0,0,282,285,1,0,0,0,283,281,1,0,0,0,283,284,1,0,0,
        0,284,47,1,0,0,0,285,283,1,0,0,0,286,288,5,64,0,0,287,289,3,62,31,
        0,288,287,1,0,0,0,288,289,1,0,0,0,289,49,1,0,0,0,290,291,5,34,0,
        0,291,292,5,11,0,0,292,297,3,52,26,0,293,294,5,35,0,0,294,296,3,
        52,26,0,295,293,1,0,0,0,296,299,1,0,0,0,297,295,1,0,0,0,297,298,
        1,0,0,0,298,51,1,0,0,0,299,297,1,0,0,0,300,311,5,64,0,0,301,302,
        5,36,0,0,302,303,5,11,0,0,303,308,3,54,27,0,304,305,5,31,0,0,305,
        307,3,54,27,0,306,304,1,0,0,0,307,310,1,0,0,0,308,306,1,0,0,0,308,
        309,1,0,0,0,309,312,1,0,0,0,310,308,1,0,0,0,311,301,1,0,0,0,311,
        312,1,0,0,0,312,53,1,0,0,0,313,314,5,64,0,0,314,55,1,0,0,0,315,316,
        5,37,0,0,316,317,5,11,0,0,317,322,3,58,29,0,318,319,5,31,0,0,319,
        321,3,58,29,0,320,318,1,0,0,0,321,324,1,0,0,0,322,320,1,0,0,0,322,
        323,1,0,0,0,323,57,1,0,0,0,324,322,1,0,0,0,325,328,3,60,30,0,326,
        328,3,66,33,0,327,325,1,0,0,0,327,326,1,0,0,0,328,59,1,0,0,0,329,
        331,3,54,27,0,330,332,3,64,32,0,331,330,1,0,0,0,331,332,1,0,0,0,
        332,61,1,0,0,0,333,334,5,38,0,0,334,335,3,54,27,0,335,63,1,0,0,0,
        336,337,5,39,0,0,337,338,5,66,0,0,338,65,1,0,0,0,339,340,5,40,0,
        0,340,342,3,54,27,0,341,343,3,64,32,0,342,341,1,0,0,0,342,343,1,
        0,0,0,343,345,1,0,0,0,344,346,3,68,34,0,345,344,1,0,0,0,345,346,
        1,0,0,0,346,67,1,0,0,0,347,348,5,41,0,0,348,349,5,66,0,0,349,69,
        1,0,0,0,350,351,5,42,0,0,351,353,5,11,0,0,352,354,3,72,36,0,353,
        352,1,0,0,0,353,354,1,0,0,0,354,356,1,0,0,0,355,357,3,82,41,0,356,
        355,1,0,0,0,356,357,1,0,0,0,357,359,1,0,0,0,358,360,3,84,42,0,359,
        358,1,0,0,0,359,360,1,0,0,0,360,362,1,0,0,0,361,363,3,86,43,0,362,
        361,1,0,0,0,362,363,1,0,0,0,363,365,1,0,0,0,364,366,3,88,44,0,365,
        364,1,0,0,0,365,366,1,0,0,0,366,71,1,0,0,0,367,368,5,43,0,0,368,
        369,3,76,38,0,369,376,5,11,0,0,370,377,3,74,37,0,371,377,3,80,40,
        0,372,373,3,74,37,0,373,374,5,31,0,0,374,375,3,80,40,0,375,377,1,
        0,0,0,376,370,1,0,0,0,376,371,1,0,0,0,376,372,1,0,0,0,377,73,1,0,
        0,0,378,379,5,65,0,0,379,380,3,78,39,0,380,75,1,0,0,0,381,382,5,
        64,0,0,382,77,1,0,0,0,383,384,7,4,0,0,384,79,1,0,0,0,385,386,5,65,
        0,0,386,387,5,17,0,0,387,388,5,65,0,0,388,389,5,17,0,0,389,390,5,
        65,0,0,390,81,1,0,0,0,391,392,5,48,0,0,392,393,5,11,0,0,393,398,
        3,54,27,0,394,395,5,31,0,0,395,397,3,54,27,0,396,394,1,0,0,0,397,
        400,1,0,0,0,398,396,1,0,0,0,398,399,1,0,0,0,399,83,1,0,0,0,400,398,
        1,0,0,0,401,402,5,49,0,0,402,403,5,11,0,0,403,404,5,65,0,0,404,85,
        1,0,0,0,405,406,5,50,0,0,406,407,5,11,0,0,407,412,3,54,27,0,408,
        409,5,31,0,0,409,411,3,54,27,0,410,408,1,0,0,0,411,414,1,0,0,0,412,
        410,1,0,0,0,412,413,1,0,0,0,413,87,1,0,0,0,414,412,1,0,0,0,415,416,
        5,51,0,0,416,417,5,11,0,0,417,418,3,108,54,0,418,89,1,0,0,0,419,
        420,5,52,0,0,420,423,5,11,0,0,421,424,3,92,46,0,422,424,3,96,48,
        0,423,421,1,0,0,0,423,422,1,0,0,0,424,91,1,0,0,0,425,426,3,94,47,
        0,426,93,1,0,0,0,427,428,5,53,0,0,428,429,5,66,0,0,429,95,1,0,0,
        0,430,431,5,54,0,0,431,432,3,112,56,0,432,97,1,0,0,0,433,434,5,55,
        0,0,434,435,5,11,0,0,435,436,3,100,50,0,436,438,3,104,52,0,437,439,
        3,106,53,0,438,437,1,0,0,0,438,439,1,0,0,0,439,99,1,0,0,0,440,441,
        5,56,0,0,441,442,5,11,0,0,442,443,3,102,51,0,443,101,1,0,0,0,444,
        445,7,5,0,0,445,103,1,0,0,0,446,447,5,59,0,0,447,448,5,11,0,0,448,
        449,3,108,54,0,449,105,1,0,0,0,450,451,5,60,0,0,451,452,5,11,0,0,
        452,453,3,108,54,0,453,107,1,0,0,0,454,455,7,6,0,0,455,109,1,0,0,
        0,456,457,5,63,0,0,457,459,5,1,0,0,458,460,3,112,56,0,459,458,1,
        0,0,0,460,461,1,0,0,0,461,459,1,0,0,0,461,462,1,0,0,0,462,463,1,
        0,0,0,463,464,5,2,0,0,464,111,1,0,0,0,465,468,3,8,4,0,466,468,3,
        10,5,0,467,465,1,0,0,0,467,466,1,0,0,0,468,113,1,0,0,0,43,122,129,
        132,135,144,153,156,159,167,189,197,201,208,217,221,226,237,261,
        268,272,274,283,288,297,308,311,322,327,331,342,345,353,356,359,
        362,365,376,398,412,423,438,461,467
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'ComposedPolicy'", "'MajorityPolicy'", 
                     "'LeaderDrivenPolicy'", "'AbsoluteMajorityPolicy'", 
                     "'ConsensusPolicy'", "'LazyConsensusPolicy'", "'VotingPolicy'", 
                     "'Scopes'", "':'", "'Scope'", "'Project'", "'from'", 
                     "'activities'", "'GitHub'", "'/'", "'tasks'", "'Issue'", 
                     "'Pull request'", "'All'", "'Status'", "'completed'", 
                     "'accepted'", "'partial'", "'Action'", "'merge'", "'review'", 
                     "'release'", "'Labels'", "','", "'Participants'", "'Participant list'", 
                     "'Roles'", "';'", "'composed of'", "'Individuals'", 
                     "'as'", "'with vote value'", "'(Agent)'", "'with confidence'", 
                     "'Conditions'", "'Deadline'", "'days'", "'weeks'", 
                     "'months'", "'years'", "'ParticipantExclusion'", "'MinParticipants'", 
                     "'VetoRight'", "'PassedTests'", "'Parameters'", "'ratio'", 
                     "'default'", "'Order'", "'Execution'", "'sequential'", 
                     "'parallel'", "'RequireAll'", "'CarryOver'", "'true'", 
                     "'false'", "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "ID", "SIGNED_INT", "FLOAT", "WS" ]

    RULE_governance = 0
    RULE_policy = 1
    RULE_topLevelSinglePolicy = 2
    RULE_topLevelComposedPolicy = 3
    RULE_nestedSinglePolicy = 4
    RULE_nestedComposedPolicy = 5
    RULE_policyType = 6
    RULE_scopes = 7
    RULE_scope = 8
    RULE_project = 9
    RULE_platform = 10
    RULE_repoID = 11
    RULE_activity = 12
    RULE_task = 13
    RULE_taskType = 14
    RULE_taskContent = 15
    RULE_actionWithLabels = 16
    RULE_status = 17
    RULE_statusEnum = 18
    RULE_action = 19
    RULE_actionEnum = 20
    RULE_labels = 21
    RULE_participants = 22
    RULE_policyParticipants = 23
    RULE_partID = 24
    RULE_roles = 25
    RULE_roleID = 26
    RULE_participantID = 27
    RULE_individuals = 28
    RULE_individualEntry = 29
    RULE_individual = 30
    RULE_hasRole = 31
    RULE_voteValue = 32
    RULE_agent = 33
    RULE_confidence = 34
    RULE_conditions = 35
    RULE_deadline = 36
    RULE_offset = 37
    RULE_deadlineID = 38
    RULE_timeUnit = 39
    RULE_date = 40
    RULE_participantExclusion = 41
    RULE_minParticipant = 42
    RULE_vetoRight = 43
    RULE_passedTests = 44
    RULE_parameters = 45
    RULE_votParams = 46
    RULE_ratio = 47
    RULE_default = 48
    RULE_order = 49
    RULE_orderType = 50
    RULE_orderTypeValue = 51
    RULE_orderMode = 52
    RULE_carryOver = 53
    RULE_booleanValue = 54
    RULE_phases = 55
    RULE_nestedPolicy = 56

    ruleNames =  [ "governance", "policy", "topLevelSinglePolicy", "topLevelComposedPolicy", 
                   "nestedSinglePolicy", "nestedComposedPolicy", "policyType", 
                   "scopes", "scope", "project", "platform", "repoID", "activity", 
                   "task", "taskType", "taskContent", "actionWithLabels", 
                   "status", "statusEnum", "action", "actionEnum", "labels", 
                   "participants", "policyParticipants", "partID", "roles", 
                   "roleID", "participantID", "individuals", "individualEntry", 
                   "individual", "hasRole", "voteValue", "agent", "confidence", 
                   "conditions", "deadline", "offset", "deadlineID", "timeUnit", 
                   "date", "participantExclusion", "minParticipant", "vetoRight", 
                   "passedTests", "parameters", "votParams", "ratio", "default", 
                   "order", "orderType", "orderTypeValue", "orderMode", 
                   "carryOver", "booleanValue", "phases", "nestedPolicy" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    ID=64
    SIGNED_INT=65
    FLOAT=66
    WS=67

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class GovernanceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def scopes(self):
            return self.getTypedRuleContext(govdslParser.ScopesContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def policy(self):
            return self.getTypedRuleContext(govdslParser.PolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_governance

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGovernance" ):
                listener.enterGovernance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGovernance" ):
                listener.exitGovernance(self)




    def governance(self):

        localctx = govdslParser.GovernanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_governance)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.scopes()
            self.state = 115
            self.participants()
            self.state = 116
            self.policy()
            self.state = 118
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def topLevelSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelSinglePolicyContext,0)


        def topLevelComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.state = 120
                self.topLevelSinglePolicy()
                pass
            elif token in [3]:
                self.state = 121
                self.topLevelComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSinglePolicy" ):
                listener.enterTopLevelSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSinglePolicy" ):
                listener.exitTopLevelSinglePolicy(self)




    def topLevelSinglePolicy(self):

        localctx = govdslParser.TopLevelSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topLevelSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 124
            self.policyType()
            self.state = 125
            self.match(govdslParser.ID)
            self.state = 126
            self.match(govdslParser.T__0)
            self.state = 127
            self.scope()
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 128
                self.policyParticipants()


            self.state = 132
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 131
                self.conditions()


            self.state = 135
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 134
                self.parameters()


            self.state = 137
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelComposedPolicy" ):
                listener.enterTopLevelComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelComposedPolicy" ):
                listener.exitTopLevelComposedPolicy(self)




    def topLevelComposedPolicy(self):

        localctx = govdslParser.TopLevelComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_topLevelComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.match(govdslParser.T__2)
            self.state = 140
            self.match(govdslParser.ID)
            self.state = 141
            self.match(govdslParser.T__0)
            self.state = 142
            self.scope()
            self.state = 144
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==55:
                self.state = 143
                self.order()


            self.state = 146
            self.phases()
            self.state = 147
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedSinglePolicy" ):
                listener.enterNestedSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedSinglePolicy" ):
                listener.exitNestedSinglePolicy(self)




    def nestedSinglePolicy(self):

        localctx = govdslParser.NestedSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_nestedSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            self.policyType()
            self.state = 150
            self.match(govdslParser.ID)
            self.state = 151
            self.match(govdslParser.T__0)
            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 152
                self.policyParticipants()


            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 155
                self.conditions()


            self.state = 159
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 158
                self.parameters()


            self.state = 161
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedComposedPolicy" ):
                listener.enterNestedComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedComposedPolicy" ):
                listener.exitNestedComposedPolicy(self)




    def nestedComposedPolicy(self):

        localctx = govdslParser.NestedComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_nestedComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(govdslParser.T__2)
            self.state = 164
            self.match(govdslParser.ID)
            self.state = 165
            self.match(govdslParser.T__0)
            self.state = 167
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==55:
                self.state = 166
                self.order()


            self.state = 169
            self.phases()
            self.state = 170
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1008) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self):
            return self.getTypedRuleContext(govdslParser.ProjectContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_scopes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopes" ):
                listener.enterScopes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopes" ):
                listener.exitScopes(self)




    def scopes(self):

        localctx = govdslParser.ScopesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_scopes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(govdslParser.T__9)
            self.state = 175
            self.match(govdslParser.T__10)
            self.state = 176
            self.project()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.match(govdslParser.T__11)
            self.state = 179
            self.match(govdslParser.T__10)
            self.state = 180
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(govdslParser.T__12)
            self.state = 183
            self.match(govdslParser.ID)
            self.state = 189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 184
                self.match(govdslParser.T__13)
                self.state = 185
                self.platform()
                self.state = 186
                self.match(govdslParser.T__10)
                self.state = 187
                self.repoID()


            self.state = 201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 191
                self.match(govdslParser.T__0)
                self.state = 192
                self.match(govdslParser.T__14)
                self.state = 193
                self.match(govdslParser.T__10)
                self.state = 195 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 194
                    self.activity()
                    self.state = 197 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==64):
                        break

                self.state = 199
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.match(govdslParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self.match(govdslParser.ID)
            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 206
                self.match(govdslParser.T__16)
                self.state = 207
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_activity)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self.match(govdslParser.ID)
            self.state = 221
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 211
                self.match(govdslParser.T__0)
                self.state = 212
                self.match(govdslParser.T__17)
                self.state = 213
                self.match(govdslParser.T__10)
                self.state = 215 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 214
                    self.task()
                    self.state = 217 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==64):
                        break

                self.state = 219
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 223
            self.match(govdslParser.ID)
            self.state = 226
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 224
                self.match(govdslParser.T__10)
                self.state = 225
                self.taskType()


            self.state = 228
            self.match(govdslParser.T__0)
            self.state = 229
            self.taskContent()
            self.state = 230
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_taskContent)
        try:
            self.state = 237
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 234
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 235
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 236
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self.action()
            self.state = 240
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            self.match(govdslParser.T__21)
            self.state = 243
            self.match(govdslParser.T__10)
            self.state = 244
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 58720256) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            self.match(govdslParser.T__25)
            self.state = 249
            self.match(govdslParser.T__10)
            self.state = 250
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 939524096) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.match(govdslParser.T__29)
            self.state = 255
            self.match(govdslParser.T__10)
            self.state = 256
            self.match(govdslParser.ID)
            self.state = 261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 257
                self.match(govdslParser.T__30)
                self.state = 258
                self.match(govdslParser.ID)
                self.state = 263
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self):
            return self.getTypedRuleContext(govdslParser.RolesContext,0)


        def individuals(self):
            return self.getTypedRuleContext(govdslParser.IndividualsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_participants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(govdslParser.T__31)
            self.state = 265
            self.match(govdslParser.T__10)
            self.state = 274
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 266
                self.roles()
                self.state = 268
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==37:
                    self.state = 267
                    self.individuals()


                pass
            elif token in [37]:
                self.state = 270
                self.individuals()
                self.state = 272
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==34:
                    self.state = 271
                    self.roles()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def partID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PartIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.PartIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_policyParticipants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyParticipants" ):
                listener.enterPolicyParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyParticipants" ):
                listener.exitPolicyParticipants(self)




    def policyParticipants(self):

        localctx = govdslParser.PolicyParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_policyParticipants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.match(govdslParser.T__32)
            self.state = 277
            self.match(govdslParser.T__10)
            self.state = 278
            self.partID()
            self.state = 283
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 279
                self.match(govdslParser.T__30)
                self.state = 280
                self.partID()
                self.state = 285
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_partID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartID" ):
                listener.enterPartID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartID" ):
                listener.exitPartID(self)




    def partID(self):

        localctx = govdslParser.PartIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_partID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.match(govdslParser.ID)
            self.state = 288
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38:
                self.state = 287
                self.hasRole()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roleID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.RoleIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.RoleIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.match(govdslParser.T__33)
            self.state = 291
            self.match(govdslParser.T__10)
            self.state = 292
            self.roleID()
            self.state = 297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 293
                self.match(govdslParser.T__34)
                self.state = 294
                self.roleID()
                self.state = 299
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roleID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleID" ):
                listener.enterRoleID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleID" ):
                listener.exitRoleID(self)




    def roleID(self):

        localctx = govdslParser.RoleIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_roleID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(govdslParser.ID)
            self.state = 311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==36:
                self.state = 301
                self.match(govdslParser.T__35)
                self.state = 302
                self.match(govdslParser.T__10)
                self.state = 303
                self.participantID()
                self.state = 308
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==31:
                    self.state = 304
                    self.match(govdslParser.T__30)
                    self.state = 305
                    self.participantID()
                    self.state = 310
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_participantID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantID" ):
                listener.enterParticipantID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantID" ):
                listener.exitParticipantID(self)




    def participantID(self):

        localctx = govdslParser.ParticipantIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_participantID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 313
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individualEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualEntryContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualEntryContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 315
            self.match(govdslParser.T__36)
            self.state = 316
            self.match(govdslParser.T__10)
            self.state = 317
            self.individualEntry()
            self.state = 322
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 318
                self.match(govdslParser.T__30)
                self.state = 319
                self.individualEntry()
                self.state = 324
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individual(self):
            return self.getTypedRuleContext(govdslParser.IndividualContext,0)


        def agent(self):
            return self.getTypedRuleContext(govdslParser.AgentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individualEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividualEntry" ):
                listener.enterIndividualEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividualEntry" ):
                listener.exitIndividualEntry(self)




    def individualEntry(self):

        localctx = govdslParser.IndividualEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_individualEntry)
        try:
            self.state = 327
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [64]:
                self.enterOuterAlt(localctx, 1)
                self.state = 325
                self.individual()
                pass
            elif token in [40]:
                self.enterOuterAlt(localctx, 2)
                self.state = 326
                self.agent()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividual" ):
                listener.enterIndividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividual" ):
                listener.exitIndividual(self)




    def individual(self):

        localctx = govdslParser.IndividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_individual)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 329
            self.participantID()
            self.state = 331
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 330
                self.voteValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 333
            self.match(govdslParser.T__37)
            self.state = 334
            self.participantID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoteValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_voteValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoteValue" ):
                listener.enterVoteValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoteValue" ):
                listener.exitVoteValue(self)




    def voteValue(self):

        localctx = govdslParser.VoteValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_voteValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.match(govdslParser.T__38)
            self.state = 337
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AgentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def confidence(self):
            return self.getTypedRuleContext(govdslParser.ConfidenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_agent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent" ):
                listener.enterAgent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent" ):
                listener.exitAgent(self)




    def agent(self):

        localctx = govdslParser.AgentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_agent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 339
            self.match(govdslParser.T__39)
            self.state = 340
            self.participantID()
            self.state = 342
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 341
                self.voteValue()


            self.state = 345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 344
                self.confidence()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfidenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_confidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfidence" ):
                listener.enterConfidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfidence" ):
                listener.exitConfidence(self)




    def confidence(self):

        localctx = govdslParser.ConfidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_confidence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 347
            self.match(govdslParser.T__40)
            self.state = 348
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def participantExclusion(self):
            return self.getTypedRuleContext(govdslParser.ParticipantExclusionContext,0)


        def minParticipant(self):
            return self.getTypedRuleContext(govdslParser.MinParticipantContext,0)


        def vetoRight(self):
            return self.getTypedRuleContext(govdslParser.VetoRightContext,0)


        def passedTests(self):
            return self.getTypedRuleContext(govdslParser.PassedTestsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.match(govdslParser.T__41)
            self.state = 351
            self.match(govdslParser.T__10)
            self.state = 353
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==43:
                self.state = 352
                self.deadline()


            self.state = 356
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 355
                self.participantExclusion()


            self.state = 359
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 358
                self.minParticipant()


            self.state = 362
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==50:
                self.state = 361
                self.vetoRight()


            self.state = 365
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==51:
                self.state = 364
                self.passedTests()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_deadline)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 367
            self.match(govdslParser.T__42)
            self.state = 368
            self.deadlineID()
            self.state = 369
            self.match(govdslParser.T__10)
            self.state = 376
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.state = 370
                self.offset()
                pass

            elif la_ == 2:
                self.state = 371
                self.date()
                pass

            elif la_ == 3:
                self.state = 372
                self.offset()
                self.state = 373
                self.match(govdslParser.T__30)
                self.state = 374
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 378
            self.match(govdslParser.SIGNED_INT)
            self.state = 379
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 381
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 263882790666240) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            self.match(govdslParser.SIGNED_INT)
            self.state = 386
            self.match(govdslParser.T__16)
            self.state = 387
            self.match(govdslParser.SIGNED_INT)
            self.state = 388
            self.match(govdslParser.T__16)
            self.state = 389
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_participantExclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantExclusion" ):
                listener.enterParticipantExclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantExclusion" ):
                listener.exitParticipantExclusion(self)




    def participantExclusion(self):

        localctx = govdslParser.ParticipantExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_participantExclusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 391
            self.match(govdslParser.T__47)
            self.state = 392
            self.match(govdslParser.T__10)
            self.state = 393
            self.participantID()
            self.state = 398
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 394
                self.match(govdslParser.T__30)
                self.state = 395
                self.participantID()
                self.state = 400
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinParticipantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minParticipant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinParticipant" ):
                listener.enterMinParticipant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinParticipant" ):
                listener.exitMinParticipant(self)




    def minParticipant(self):

        localctx = govdslParser.MinParticipantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_minParticipant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 401
            self.match(govdslParser.T__48)
            self.state = 402
            self.match(govdslParser.T__10)
            self.state = 403
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VetoRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_vetoRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVetoRight" ):
                listener.enterVetoRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVetoRight" ):
                listener.exitVetoRight(self)




    def vetoRight(self):

        localctx = govdslParser.VetoRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_vetoRight)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 405
            self.match(govdslParser.T__49)
            self.state = 406
            self.match(govdslParser.T__10)
            self.state = 407
            self.participantID()
            self.state = 412
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 408
                self.match(govdslParser.T__30)
                self.state = 409
                self.participantID()
                self.state = 414
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PassedTestsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_passedTests

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPassedTests" ):
                listener.enterPassedTests(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPassedTests" ):
                listener.exitPassedTests(self)




    def passedTests(self):

        localctx = govdslParser.PassedTestsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_passedTests)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 415
            self.match(govdslParser.T__50)
            self.state = 416
            self.match(govdslParser.T__10)
            self.state = 417
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 419
            self.match(govdslParser.T__51)
            self.state = 420
            self.match(govdslParser.T__10)
            self.state = 423
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [53]:
                self.state = 421
                self.votParams()
                pass
            elif token in [54]:
                self.state = 422
                self.default()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_votParams)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 425
            self.ratio()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 427
            self.match(govdslParser.T__52)
            self.state = 428
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            self.match(govdslParser.T__53)
            self.state = 431
            self.nestedPolicy()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def carryOver(self):
            return self.getTypedRuleContext(govdslParser.CarryOverContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            self.match(govdslParser.T__54)
            self.state = 434
            self.match(govdslParser.T__10)

            self.state = 435
            self.orderType()
            self.state = 436
            self.orderMode()
            self.state = 438
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==60:
                self.state = 437
                self.carryOver()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderTypeValue(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_orderType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 440
            self.match(govdslParser.T__55)
            self.state = 441
            self.match(govdslParser.T__10)
            self.state = 442
            self.orderTypeValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderTypeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderTypeValue" ):
                listener.enterOrderTypeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderTypeValue" ):
                listener.exitOrderTypeValue(self)




    def orderTypeValue(self):

        localctx = govdslParser.OrderTypeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_orderTypeValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            _la = self._input.LA(1)
            if not(_la==57 or _la==58):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_orderMode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 446
            self.match(govdslParser.T__58)
            self.state = 447
            self.match(govdslParser.T__10)
            self.state = 448
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CarryOverContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_carryOver

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCarryOver" ):
                listener.enterCarryOver(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCarryOver" ):
                listener.exitCarryOver(self)




    def carryOver(self):

        localctx = govdslParser.CarryOverContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_carryOver)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 450
            self.match(govdslParser.T__59)
            self.state = 451
            self.match(govdslParser.T__10)
            self.state = 452
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = govdslParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 454
            _la = self._input.LA(1)
            if not(_la==61 or _la==62):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.NestedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.NestedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 456
            self.match(govdslParser.T__62)
            self.state = 457
            self.match(govdslParser.T__0)
            self.state = 459 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 458
                self.nestedPolicy()
                self.state = 461 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 463
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedSinglePolicyContext,0)


        def nestedComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPolicy" ):
                listener.enterNestedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPolicy" ):
                listener.exitNestedPolicy(self)




    def nestedPolicy(self):

        localctx = govdslParser.NestedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_nestedPolicy)
        try:
            self.state = 467
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 465
                self.nestedSinglePolicy()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 466
                self.nestedComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





