# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,84,712,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,65,
        2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,72,
        7,72,2,73,7,73,2,74,7,74,2,75,7,75,1,0,1,0,1,0,4,0,156,8,0,11,0,
        12,0,157,1,0,1,0,1,1,1,1,3,1,164,8,1,1,2,1,2,1,2,1,2,1,2,1,2,3,2,
        172,8,2,1,2,3,2,175,8,2,1,2,3,2,178,8,2,1,2,1,2,1,3,1,3,1,3,1,3,
        1,3,3,3,187,8,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,4,3,4,197,8,4,1,4,
        3,4,200,8,4,1,4,3,4,203,8,4,1,4,1,4,1,5,1,5,1,5,1,5,3,5,211,8,5,
        1,5,1,5,1,5,1,6,1,6,1,7,1,7,1,7,1,7,1,7,4,7,223,8,7,11,7,12,7,224,
        1,8,1,8,1,8,1,8,1,9,1,9,1,9,4,9,234,8,9,11,9,12,9,235,1,10,1,10,
        1,10,1,10,1,10,1,10,3,10,244,8,10,1,10,1,10,1,10,1,10,4,10,250,8,
        10,11,10,12,10,251,1,10,1,10,3,10,256,8,10,1,11,1,11,1,12,1,12,1,
        12,3,12,263,8,12,1,13,1,13,1,13,4,13,268,8,13,11,13,12,13,269,1,
        14,1,14,1,14,1,14,1,14,4,14,277,8,14,11,14,12,14,278,1,14,1,14,3,
        14,283,8,14,1,15,1,15,1,15,4,15,288,8,15,11,15,12,15,289,1,16,1,
        16,1,16,3,16,295,8,16,1,16,1,16,1,16,1,16,3,16,301,8,16,1,17,1,17,
        1,18,1,18,1,18,3,18,308,8,18,1,19,1,19,1,19,1,20,1,20,1,20,1,20,
        1,21,1,21,1,22,1,22,1,22,1,22,1,23,1,23,1,24,1,24,1,24,1,24,1,24,
        5,24,330,8,24,10,24,12,24,333,9,24,1,25,1,25,1,25,1,25,1,25,3,25,
        340,8,25,1,26,1,26,1,27,1,27,1,27,1,27,1,27,5,27,349,8,27,10,27,
        12,27,352,9,27,1,28,1,28,1,28,1,28,1,28,5,28,359,8,28,10,28,12,28,
        362,9,28,1,29,1,29,1,29,1,29,1,29,4,29,369,8,29,11,29,12,29,370,
        1,30,1,30,1,30,1,30,1,30,5,30,378,8,30,10,30,12,30,381,9,30,1,31,
        1,31,1,31,1,31,3,31,387,8,31,1,31,5,31,390,8,31,10,31,12,31,393,
        9,31,1,32,1,32,3,32,397,8,32,1,33,1,33,1,33,3,33,402,8,33,1,33,3,
        33,405,8,33,1,33,3,33,408,8,33,1,33,3,33,411,8,33,1,33,3,33,414,
        8,33,1,33,3,33,417,8,33,1,34,1,34,1,34,1,34,1,35,1,35,1,35,1,35,
        1,36,1,36,1,36,1,36,1,37,1,37,1,37,1,37,3,37,435,8,37,1,37,3,37,
        438,8,37,1,37,3,37,441,8,37,1,37,3,37,444,8,37,1,37,3,37,447,8,37,
        1,37,3,37,450,8,37,1,37,3,37,453,8,37,1,37,3,37,456,8,37,1,37,3,
        37,459,8,37,1,37,3,37,462,8,37,1,38,1,38,1,38,1,38,1,39,1,39,1,39,
        1,39,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,3,41,480,8,41,1,41,
        5,41,483,8,41,10,41,12,41,486,9,41,1,42,1,42,1,42,1,42,3,42,492,
        8,42,1,42,3,42,495,8,42,1,42,1,42,3,42,499,8,42,1,42,3,42,502,8,
        42,3,42,504,8,42,1,42,1,42,1,43,1,43,1,43,1,43,1,44,1,44,1,44,1,
        44,1,45,1,45,1,45,1,45,1,45,5,45,521,8,45,10,45,12,45,524,9,45,1,
        46,1,46,3,46,528,8,46,1,47,1,47,1,47,1,48,1,48,1,48,3,48,536,8,48,
        1,48,3,48,539,8,48,1,48,3,48,542,8,48,1,48,3,48,545,8,48,1,48,3,
        48,548,8,48,1,48,3,48,551,8,48,1,48,5,48,554,8,48,10,48,12,48,557,
        9,48,1,49,1,49,3,49,561,8,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,
        3,49,570,8,49,1,50,1,50,3,50,574,8,50,1,50,1,50,1,50,1,50,1,50,1,
        50,1,50,3,50,583,8,50,1,51,1,51,1,51,1,52,1,52,1,53,1,53,1,54,1,
        54,1,54,1,54,1,54,1,54,1,55,1,55,1,55,1,55,1,55,5,55,603,8,55,10,
        55,12,55,606,9,55,1,56,1,56,1,56,1,56,1,57,1,57,1,57,1,57,1,57,5,
        57,617,8,57,10,57,12,57,620,9,57,1,58,1,58,3,58,624,8,58,1,58,1,
        58,1,58,1,59,1,59,1,60,1,60,3,60,633,8,60,1,60,3,60,636,8,60,1,60,
        1,60,1,60,1,60,5,60,642,8,60,10,60,12,60,645,9,60,1,61,1,61,1,62,
        1,62,1,62,1,62,1,62,3,62,654,8,62,1,63,1,63,1,64,1,64,1,64,1,64,
        1,65,1,65,1,65,1,65,3,65,666,8,65,1,66,1,66,1,66,1,66,3,66,672,8,
        66,1,67,1,67,1,68,1,68,1,68,1,68,1,68,3,68,681,8,68,1,69,1,69,1,
        69,1,69,1,70,1,70,1,71,1,71,1,71,1,71,1,72,1,72,1,72,1,72,1,73,1,
        73,1,74,1,74,1,74,4,74,702,8,74,11,74,12,74,703,1,74,1,74,1,75,1,
        75,3,75,710,8,75,1,75,0,0,76,0,2,4,6,8,10,12,14,16,18,20,22,24,26,
        28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,
        72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
        112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,
        144,146,148,150,0,9,1,0,4,9,1,0,19,21,1,0,23,25,1,0,27,29,1,0,54,
        57,1,0,62,64,1,0,66,67,1,0,74,75,1,0,78,79,724,0,152,1,0,0,0,2,163,
        1,0,0,0,4,165,1,0,0,0,6,181,1,0,0,0,8,191,1,0,0,0,10,206,1,0,0,0,
        12,215,1,0,0,0,14,217,1,0,0,0,16,226,1,0,0,0,18,230,1,0,0,0,20,237,
        1,0,0,0,22,257,1,0,0,0,24,259,1,0,0,0,26,264,1,0,0,0,28,271,1,0,
        0,0,30,284,1,0,0,0,32,291,1,0,0,0,34,302,1,0,0,0,36,307,1,0,0,0,
        38,309,1,0,0,0,40,312,1,0,0,0,42,316,1,0,0,0,44,318,1,0,0,0,46,322,
        1,0,0,0,48,324,1,0,0,0,50,334,1,0,0,0,52,341,1,0,0,0,54,343,1,0,
        0,0,56,353,1,0,0,0,58,363,1,0,0,0,60,372,1,0,0,0,62,382,1,0,0,0,
        64,396,1,0,0,0,66,398,1,0,0,0,68,418,1,0,0,0,70,422,1,0,0,0,72,426,
        1,0,0,0,74,430,1,0,0,0,76,463,1,0,0,0,78,467,1,0,0,0,80,471,1,0,
        0,0,82,475,1,0,0,0,84,487,1,0,0,0,86,507,1,0,0,0,88,511,1,0,0,0,
        90,515,1,0,0,0,92,525,1,0,0,0,94,529,1,0,0,0,96,532,1,0,0,0,98,558,
        1,0,0,0,100,571,1,0,0,0,102,584,1,0,0,0,104,587,1,0,0,0,106,589,
        1,0,0,0,108,591,1,0,0,0,110,597,1,0,0,0,112,607,1,0,0,0,114,611,
        1,0,0,0,116,621,1,0,0,0,118,628,1,0,0,0,120,630,1,0,0,0,122,646,
        1,0,0,0,124,648,1,0,0,0,126,655,1,0,0,0,128,657,1,0,0,0,130,661,
        1,0,0,0,132,667,1,0,0,0,134,673,1,0,0,0,136,675,1,0,0,0,138,682,
        1,0,0,0,140,686,1,0,0,0,142,688,1,0,0,0,144,692,1,0,0,0,146,696,
        1,0,0,0,148,698,1,0,0,0,150,709,1,0,0,0,152,153,3,14,7,0,153,155,
        3,58,29,0,154,156,3,2,1,0,155,154,1,0,0,0,156,157,1,0,0,0,157,155,
        1,0,0,0,157,158,1,0,0,0,158,159,1,0,0,0,159,160,5,0,0,1,160,1,1,
        0,0,0,161,164,3,4,2,0,162,164,3,6,3,0,163,161,1,0,0,0,163,162,1,
        0,0,0,164,3,1,0,0,0,165,166,3,12,6,0,166,167,5,81,0,0,167,168,5,
        1,0,0,168,169,3,16,8,0,169,171,3,50,25,0,170,172,3,90,45,0,171,170,
        1,0,0,0,171,172,1,0,0,0,172,174,1,0,0,0,173,175,3,96,48,0,174,173,
        1,0,0,0,174,175,1,0,0,0,175,177,1,0,0,0,176,178,3,124,62,0,177,176,
        1,0,0,0,177,178,1,0,0,0,178,179,1,0,0,0,179,180,5,2,0,0,180,5,1,
        0,0,0,181,182,5,3,0,0,182,183,5,81,0,0,183,184,5,1,0,0,184,186,3,
        16,8,0,185,187,3,136,68,0,186,185,1,0,0,0,186,187,1,0,0,0,187,188,
        1,0,0,0,188,189,3,148,74,0,189,190,5,2,0,0,190,7,1,0,0,0,191,192,
        3,12,6,0,192,193,5,81,0,0,193,194,5,1,0,0,194,196,3,50,25,0,195,
        197,3,90,45,0,196,195,1,0,0,0,196,197,1,0,0,0,197,199,1,0,0,0,198,
        200,3,96,48,0,199,198,1,0,0,0,199,200,1,0,0,0,200,202,1,0,0,0,201,
        203,3,124,62,0,202,201,1,0,0,0,202,203,1,0,0,0,203,204,1,0,0,0,204,
        205,5,2,0,0,205,9,1,0,0,0,206,207,5,3,0,0,207,208,5,81,0,0,208,210,
        5,1,0,0,209,211,3,136,68,0,210,209,1,0,0,0,210,211,1,0,0,0,211,212,
        1,0,0,0,212,213,3,148,74,0,213,214,5,2,0,0,214,11,1,0,0,0,215,216,
        7,0,0,0,216,13,1,0,0,0,217,218,5,10,0,0,218,222,5,11,0,0,219,223,
        3,18,9,0,220,223,3,26,13,0,221,223,3,30,15,0,222,219,1,0,0,0,222,
        220,1,0,0,0,222,221,1,0,0,0,223,224,1,0,0,0,224,222,1,0,0,0,224,
        225,1,0,0,0,225,15,1,0,0,0,226,227,5,12,0,0,227,228,5,11,0,0,228,
        229,5,81,0,0,229,17,1,0,0,0,230,231,5,13,0,0,231,233,5,11,0,0,232,
        234,3,20,10,0,233,232,1,0,0,0,234,235,1,0,0,0,235,233,1,0,0,0,235,
        236,1,0,0,0,236,19,1,0,0,0,237,243,5,81,0,0,238,239,5,14,0,0,239,
        240,3,22,11,0,240,241,5,11,0,0,241,242,3,24,12,0,242,244,1,0,0,0,
        243,238,1,0,0,0,243,244,1,0,0,0,244,255,1,0,0,0,245,246,5,1,0,0,
        246,247,5,15,0,0,247,249,5,11,0,0,248,250,3,28,14,0,249,248,1,0,
        0,0,250,251,1,0,0,0,251,249,1,0,0,0,251,252,1,0,0,0,252,253,1,0,
        0,0,253,254,5,2,0,0,254,256,1,0,0,0,255,245,1,0,0,0,255,256,1,0,
        0,0,256,21,1,0,0,0,257,258,5,16,0,0,258,23,1,0,0,0,259,262,5,81,
        0,0,260,261,5,17,0,0,261,263,5,81,0,0,262,260,1,0,0,0,262,263,1,
        0,0,0,263,25,1,0,0,0,264,265,5,15,0,0,265,267,5,11,0,0,266,268,3,
        28,14,0,267,266,1,0,0,0,268,269,1,0,0,0,269,267,1,0,0,0,269,270,
        1,0,0,0,270,27,1,0,0,0,271,282,5,81,0,0,272,273,5,1,0,0,273,274,
        5,18,0,0,274,276,5,11,0,0,275,277,3,32,16,0,276,275,1,0,0,0,277,
        278,1,0,0,0,278,276,1,0,0,0,278,279,1,0,0,0,279,280,1,0,0,0,280,
        281,5,2,0,0,281,283,1,0,0,0,282,272,1,0,0,0,282,283,1,0,0,0,283,
        29,1,0,0,0,284,285,5,18,0,0,285,287,5,11,0,0,286,288,3,32,16,0,287,
        286,1,0,0,0,288,289,1,0,0,0,289,287,1,0,0,0,289,290,1,0,0,0,290,
        31,1,0,0,0,291,294,5,81,0,0,292,293,5,11,0,0,293,295,3,34,17,0,294,
        292,1,0,0,0,294,295,1,0,0,0,295,300,1,0,0,0,296,297,5,1,0,0,297,
        298,3,36,18,0,298,299,5,2,0,0,299,301,1,0,0,0,300,296,1,0,0,0,300,
        301,1,0,0,0,301,33,1,0,0,0,302,303,7,1,0,0,303,35,1,0,0,0,304,308,
        3,40,20,0,305,308,3,44,22,0,306,308,3,38,19,0,307,304,1,0,0,0,307,
        305,1,0,0,0,307,306,1,0,0,0,308,37,1,0,0,0,309,310,3,44,22,0,310,
        311,3,48,24,0,311,39,1,0,0,0,312,313,5,22,0,0,313,314,5,11,0,0,314,
        315,3,42,21,0,315,41,1,0,0,0,316,317,7,2,0,0,317,43,1,0,0,0,318,
        319,5,26,0,0,319,320,5,11,0,0,320,321,3,46,23,0,321,45,1,0,0,0,322,
        323,7,3,0,0,323,47,1,0,0,0,324,325,5,30,0,0,325,326,5,11,0,0,326,
        331,5,81,0,0,327,328,5,31,0,0,328,330,5,81,0,0,329,327,1,0,0,0,330,
        333,1,0,0,0,331,329,1,0,0,0,331,332,1,0,0,0,332,49,1,0,0,0,333,331,
        1,0,0,0,334,335,5,32,0,0,335,339,5,33,0,0,336,340,3,52,26,0,337,
        340,3,54,27,0,338,340,3,56,28,0,339,336,1,0,0,0,339,337,1,0,0,0,
        339,338,1,0,0,0,340,51,1,0,0,0,341,342,5,34,0,0,342,53,1,0,0,0,343,
        344,5,35,0,0,344,345,5,11,0,0,345,350,5,81,0,0,346,347,5,31,0,0,
        347,349,5,81,0,0,348,346,1,0,0,0,349,352,1,0,0,0,350,348,1,0,0,0,
        350,351,1,0,0,0,351,55,1,0,0,0,352,350,1,0,0,0,353,354,5,36,0,0,
        354,355,5,11,0,0,355,360,5,81,0,0,356,357,5,31,0,0,357,359,5,81,
        0,0,358,356,1,0,0,0,359,362,1,0,0,0,360,358,1,0,0,0,360,361,1,0,
        0,0,361,57,1,0,0,0,362,360,1,0,0,0,363,364,5,37,0,0,364,368,5,11,
        0,0,365,369,3,60,30,0,366,369,3,62,31,0,367,369,3,82,41,0,368,365,
        1,0,0,0,368,366,1,0,0,0,368,367,1,0,0,0,369,370,1,0,0,0,370,368,
        1,0,0,0,370,371,1,0,0,0,371,59,1,0,0,0,372,373,5,38,0,0,373,374,
        5,11,0,0,374,379,5,81,0,0,375,376,5,31,0,0,376,378,5,81,0,0,377,
        375,1,0,0,0,378,381,1,0,0,0,379,377,1,0,0,0,379,380,1,0,0,0,380,
        61,1,0,0,0,381,379,1,0,0,0,382,383,5,39,0,0,383,384,5,11,0,0,384,
        391,3,64,32,0,385,387,5,31,0,0,386,385,1,0,0,0,386,387,1,0,0,0,387,
        388,1,0,0,0,388,390,3,64,32,0,389,386,1,0,0,0,390,393,1,0,0,0,391,
        389,1,0,0,0,391,392,1,0,0,0,392,63,1,0,0,0,393,391,1,0,0,0,394,397,
        3,66,33,0,395,397,3,74,37,0,396,394,1,0,0,0,396,395,1,0,0,0,397,
        65,1,0,0,0,398,416,5,81,0,0,399,401,5,1,0,0,400,402,3,68,34,0,401,
        400,1,0,0,0,401,402,1,0,0,0,402,404,1,0,0,0,403,405,5,31,0,0,404,
        403,1,0,0,0,404,405,1,0,0,0,405,407,1,0,0,0,406,408,3,70,35,0,407,
        406,1,0,0,0,407,408,1,0,0,0,408,410,1,0,0,0,409,411,5,31,0,0,410,
        409,1,0,0,0,410,411,1,0,0,0,411,413,1,0,0,0,412,414,3,72,36,0,413,
        412,1,0,0,0,413,414,1,0,0,0,414,415,1,0,0,0,415,417,5,2,0,0,416,
        399,1,0,0,0,416,417,1,0,0,0,417,67,1,0,0,0,418,419,5,40,0,0,419,
        420,5,11,0,0,420,421,5,83,0,0,421,69,1,0,0,0,422,423,5,41,0,0,423,
        424,5,11,0,0,424,425,5,81,0,0,425,71,1,0,0,0,426,427,5,42,0,0,427,
        428,5,11,0,0,428,429,5,81,0,0,429,73,1,0,0,0,430,431,5,43,0,0,431,
        461,5,81,0,0,432,434,5,1,0,0,433,435,3,68,34,0,434,433,1,0,0,0,434,
        435,1,0,0,0,435,437,1,0,0,0,436,438,5,31,0,0,437,436,1,0,0,0,437,
        438,1,0,0,0,438,440,1,0,0,0,439,441,3,76,38,0,440,439,1,0,0,0,440,
        441,1,0,0,0,441,443,1,0,0,0,442,444,5,31,0,0,443,442,1,0,0,0,443,
        444,1,0,0,0,444,446,1,0,0,0,445,447,3,78,39,0,446,445,1,0,0,0,446,
        447,1,0,0,0,447,449,1,0,0,0,448,450,5,31,0,0,449,448,1,0,0,0,449,
        450,1,0,0,0,450,452,1,0,0,0,451,453,3,80,40,0,452,451,1,0,0,0,452,
        453,1,0,0,0,453,455,1,0,0,0,454,456,5,31,0,0,455,454,1,0,0,0,455,
        456,1,0,0,0,456,458,1,0,0,0,457,459,3,72,36,0,458,457,1,0,0,0,458,
        459,1,0,0,0,459,460,1,0,0,0,460,462,5,2,0,0,461,432,1,0,0,0,461,
        462,1,0,0,0,462,75,1,0,0,0,463,464,5,44,0,0,464,465,5,11,0,0,465,
        466,5,83,0,0,466,77,1,0,0,0,467,468,5,45,0,0,468,469,5,11,0,0,469,
        470,5,83,0,0,470,79,1,0,0,0,471,472,5,46,0,0,472,473,5,11,0,0,473,
        474,5,83,0,0,474,81,1,0,0,0,475,476,5,47,0,0,476,477,5,11,0,0,477,
        484,3,84,42,0,478,480,5,31,0,0,479,478,1,0,0,0,479,480,1,0,0,0,480,
        481,1,0,0,0,481,483,3,84,42,0,482,479,1,0,0,0,483,486,1,0,0,0,484,
        482,1,0,0,0,484,485,1,0,0,0,485,83,1,0,0,0,486,484,1,0,0,0,487,488,
        5,81,0,0,488,503,5,1,0,0,489,491,3,86,43,0,490,492,5,31,0,0,491,
        490,1,0,0,0,491,492,1,0,0,0,492,494,1,0,0,0,493,495,3,88,44,0,494,
        493,1,0,0,0,494,495,1,0,0,0,495,504,1,0,0,0,496,498,3,88,44,0,497,
        499,5,31,0,0,498,497,1,0,0,0,498,499,1,0,0,0,499,501,1,0,0,0,500,
        502,3,86,43,0,501,500,1,0,0,0,501,502,1,0,0,0,502,504,1,0,0,0,503,
        489,1,0,0,0,503,496,1,0,0,0,504,505,1,0,0,0,505,506,5,2,0,0,506,
        85,1,0,0,0,507,508,5,48,0,0,508,509,5,11,0,0,509,510,5,81,0,0,510,
        87,1,0,0,0,511,512,5,49,0,0,512,513,5,11,0,0,513,514,5,81,0,0,514,
        89,1,0,0,0,515,516,5,50,0,0,516,517,5,11,0,0,517,522,3,92,46,0,518,
        519,5,31,0,0,519,521,3,92,46,0,520,518,1,0,0,0,521,524,1,0,0,0,522,
        520,1,0,0,0,522,523,1,0,0,0,523,91,1,0,0,0,524,522,1,0,0,0,525,527,
        5,81,0,0,526,528,3,94,47,0,527,526,1,0,0,0,527,528,1,0,0,0,528,93,
        1,0,0,0,529,530,5,33,0,0,530,531,5,81,0,0,531,95,1,0,0,0,532,533,
        5,51,0,0,533,535,5,11,0,0,534,536,3,98,49,0,535,534,1,0,0,0,535,
        536,1,0,0,0,536,538,1,0,0,0,537,539,3,100,50,0,538,537,1,0,0,0,538,
        539,1,0,0,0,539,541,1,0,0,0,540,542,3,110,55,0,541,540,1,0,0,0,541,
        542,1,0,0,0,542,544,1,0,0,0,543,545,3,112,56,0,544,543,1,0,0,0,544,
        545,1,0,0,0,545,547,1,0,0,0,546,548,3,114,57,0,547,546,1,0,0,0,547,
        548,1,0,0,0,548,550,1,0,0,0,549,551,3,116,58,0,550,549,1,0,0,0,550,
        551,1,0,0,0,551,555,1,0,0,0,552,554,3,120,60,0,553,552,1,0,0,0,554,
        557,1,0,0,0,555,553,1,0,0,0,555,556,1,0,0,0,556,97,1,0,0,0,557,555,
        1,0,0,0,558,560,5,52,0,0,559,561,3,104,52,0,560,559,1,0,0,0,560,
        561,1,0,0,0,561,562,1,0,0,0,562,569,5,11,0,0,563,570,3,102,51,0,
        564,570,3,108,54,0,565,566,3,102,51,0,566,567,5,31,0,0,567,568,3,
        108,54,0,568,570,1,0,0,0,569,563,1,0,0,0,569,564,1,0,0,0,569,565,
        1,0,0,0,570,99,1,0,0,0,571,573,5,53,0,0,572,574,5,81,0,0,573,572,
        1,0,0,0,573,574,1,0,0,0,574,575,1,0,0,0,575,582,5,11,0,0,576,583,
        3,102,51,0,577,583,3,108,54,0,578,579,3,102,51,0,579,580,5,31,0,
        0,580,581,3,108,54,0,581,583,1,0,0,0,582,576,1,0,0,0,582,577,1,0,
        0,0,582,578,1,0,0,0,583,101,1,0,0,0,584,585,5,82,0,0,585,586,3,106,
        53,0,586,103,1,0,0,0,587,588,5,81,0,0,588,105,1,0,0,0,589,590,7,
        4,0,0,590,107,1,0,0,0,591,592,5,82,0,0,592,593,5,17,0,0,593,594,
        5,82,0,0,594,595,5,17,0,0,595,596,5,82,0,0,596,109,1,0,0,0,597,598,
        5,58,0,0,598,599,5,11,0,0,599,604,5,81,0,0,600,601,5,31,0,0,601,
        603,5,81,0,0,602,600,1,0,0,0,603,606,1,0,0,0,604,602,1,0,0,0,604,
        605,1,0,0,0,605,111,1,0,0,0,606,604,1,0,0,0,607,608,5,59,0,0,608,
        609,5,11,0,0,609,610,5,82,0,0,610,113,1,0,0,0,611,612,5,60,0,0,612,
        613,5,11,0,0,613,618,5,81,0,0,614,615,5,31,0,0,615,617,5,81,0,0,
        616,614,1,0,0,0,617,620,1,0,0,0,618,616,1,0,0,0,618,619,1,0,0,0,
        619,115,1,0,0,0,620,618,1,0,0,0,621,623,5,61,0,0,622,624,3,118,59,
        0,623,622,1,0,0,0,623,624,1,0,0,0,624,625,1,0,0,0,625,626,5,11,0,
        0,626,627,3,146,73,0,627,117,1,0,0,0,628,629,7,5,0,0,629,119,1,0,
        0,0,630,632,5,65,0,0,631,633,3,118,59,0,632,631,1,0,0,0,632,633,
        1,0,0,0,633,635,1,0,0,0,634,636,3,122,61,0,635,634,1,0,0,0,635,636,
        1,0,0,0,636,637,1,0,0,0,637,638,5,11,0,0,638,643,5,81,0,0,639,640,
        5,31,0,0,640,642,5,81,0,0,641,639,1,0,0,0,642,645,1,0,0,0,643,641,
        1,0,0,0,643,644,1,0,0,0,644,121,1,0,0,0,645,643,1,0,0,0,646,647,
        7,6,0,0,647,123,1,0,0,0,648,649,5,68,0,0,649,653,5,11,0,0,650,654,
        3,126,63,0,651,654,3,130,65,0,652,654,3,132,66,0,653,650,1,0,0,0,
        653,651,1,0,0,0,653,652,1,0,0,0,654,125,1,0,0,0,655,656,3,128,64,
        0,656,127,1,0,0,0,657,658,5,69,0,0,658,659,5,11,0,0,659,660,5,83,
        0,0,660,129,1,0,0,0,661,662,5,70,0,0,662,665,5,11,0,0,663,666,3,
        150,75,0,664,666,3,134,67,0,665,663,1,0,0,0,665,664,1,0,0,0,666,
        131,1,0,0,0,667,668,5,71,0,0,668,671,5,11,0,0,669,672,3,150,75,0,
        670,672,3,134,67,0,671,669,1,0,0,0,671,670,1,0,0,0,672,133,1,0,0,
        0,673,674,5,81,0,0,674,135,1,0,0,0,675,676,5,72,0,0,676,677,5,11,
        0,0,677,678,3,138,69,0,678,680,3,142,71,0,679,681,3,144,72,0,680,
        679,1,0,0,0,680,681,1,0,0,0,681,137,1,0,0,0,682,683,5,73,0,0,683,
        684,5,11,0,0,684,685,3,140,70,0,685,139,1,0,0,0,686,687,7,7,0,0,
        687,141,1,0,0,0,688,689,5,76,0,0,689,690,5,11,0,0,690,691,3,146,
        73,0,691,143,1,0,0,0,692,693,5,77,0,0,693,694,5,11,0,0,694,695,3,
        146,73,0,695,145,1,0,0,0,696,697,7,8,0,0,697,147,1,0,0,0,698,699,
        5,80,0,0,699,701,5,1,0,0,700,702,3,150,75,0,701,700,1,0,0,0,702,
        703,1,0,0,0,703,701,1,0,0,0,703,704,1,0,0,0,704,705,1,0,0,0,705,
        706,5,2,0,0,706,149,1,0,0,0,707,710,3,8,4,0,708,710,3,10,5,0,709,
        707,1,0,0,0,709,708,1,0,0,0,710,151,1,0,0,0,82,157,163,171,174,177,
        186,196,199,202,210,222,224,235,243,251,255,262,269,278,282,289,
        294,300,307,331,339,350,360,368,370,379,386,391,396,401,404,407,
        410,413,416,434,437,440,443,446,449,452,455,458,461,479,484,491,
        494,498,501,503,522,527,535,538,541,544,547,550,555,560,569,573,
        582,604,618,623,632,635,643,653,665,671,680,703,709
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'ComposedPolicy'", "'MajorityPolicy'", 
                     "'LeaderDrivenPolicy'", "'AbsoluteMajorityPolicy'", 
                     "'ConsensusPolicy'", "'LazyConsensusPolicy'", "'VotingPolicy'", 
                     "'Scopes'", "':'", "'Scope'", "'Projects'", "'from'", 
                     "'Activities'", "'GitHub'", "'/'", "'Tasks'", "'Issue'", 
                     "'Pull request'", "'All'", "'Status'", "'completed'", 
                     "'accepted'", "'partial'", "'Action'", "'merge'", "'review'", 
                     "'release'", "'Labels'", "','", "'DecisionType'", "'as'", 
                     "'BooleanDecision'", "'StringList'", "'ElementList'", 
                     "'Participants'", "'Roles'", "'Individuals'", "'vote value'", 
                     "'profile'", "'role'", "'(Agent)'", "'confidence'", 
                     "'autonomy level'", "'explainability'", "'Profiles'", 
                     "'gender'", "'race'", "'Participant list'", "'Conditions'", 
                     "'Deadline'", "'MinDecisionTime'", "'days'", "'weeks'", 
                     "'months'", "'years'", "'ParticipantExclusion'", "'MinParticipants'", 
                     "'VetoRight'", "'PassedTests'", "'pre'", "'post'", 
                     "'concurrent'", "'LabelCondition'", "'include'", "'not'", 
                     "'Parameters'", "'ratio'", "'default'", "'fallback'", 
                     "'Order'", "'Execution'", "'sequential'", "'parallel'", 
                     "'RequireAll'", "'CarryOver'", "'true'", "'false'", 
                     "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "ID", "SIGNED_INT", "FLOAT", "WS" ]

    RULE_governance = 0
    RULE_policy = 1
    RULE_topLevelSinglePolicy = 2
    RULE_topLevelComposedPolicy = 3
    RULE_nestedSinglePolicy = 4
    RULE_nestedComposedPolicy = 5
    RULE_policyType = 6
    RULE_scopes = 7
    RULE_scope = 8
    RULE_projects = 9
    RULE_project = 10
    RULE_platform = 11
    RULE_repoID = 12
    RULE_activities = 13
    RULE_activity = 14
    RULE_tasks = 15
    RULE_task = 16
    RULE_taskType = 17
    RULE_taskContent = 18
    RULE_actionWithLabels = 19
    RULE_status = 20
    RULE_statusEnum = 21
    RULE_action = 22
    RULE_actionEnum = 23
    RULE_labels = 24
    RULE_decisionType = 25
    RULE_booleanDecision = 26
    RULE_stringList = 27
    RULE_elementList = 28
    RULE_participants = 29
    RULE_roles = 30
    RULE_individuals = 31
    RULE_individualEntry = 32
    RULE_individual = 33
    RULE_voteValue = 34
    RULE_withProfile = 35
    RULE_withRole = 36
    RULE_agent = 37
    RULE_confidence = 38
    RULE_autonomyLevel = 39
    RULE_explainability = 40
    RULE_profiles = 41
    RULE_profile = 42
    RULE_gender = 43
    RULE_race = 44
    RULE_policyParticipants = 45
    RULE_partID = 46
    RULE_hasRole = 47
    RULE_conditions = 48
    RULE_deadline = 49
    RULE_minDecisionTime = 50
    RULE_offset = 51
    RULE_deadlineID = 52
    RULE_timeUnit = 53
    RULE_date = 54
    RULE_participantExclusion = 55
    RULE_minParticipant = 56
    RULE_vetoRight = 57
    RULE_passedTests = 58
    RULE_evaluationMode = 59
    RULE_labelsCondition = 60
    RULE_include = 61
    RULE_parameters = 62
    RULE_votParams = 63
    RULE_ratio = 64
    RULE_default = 65
    RULE_fallback = 66
    RULE_policyReference = 67
    RULE_order = 68
    RULE_orderType = 69
    RULE_orderTypeValue = 70
    RULE_orderMode = 71
    RULE_carryOver = 72
    RULE_booleanValue = 73
    RULE_phases = 74
    RULE_nestedPolicy = 75

    ruleNames =  [ "governance", "policy", "topLevelSinglePolicy", "topLevelComposedPolicy", 
                   "nestedSinglePolicy", "nestedComposedPolicy", "policyType", 
                   "scopes", "scope", "projects", "project", "platform", 
                   "repoID", "activities", "activity", "tasks", "task", 
                   "taskType", "taskContent", "actionWithLabels", "status", 
                   "statusEnum", "action", "actionEnum", "labels", "decisionType", 
                   "booleanDecision", "stringList", "elementList", "participants", 
                   "roles", "individuals", "individualEntry", "individual", 
                   "voteValue", "withProfile", "withRole", "agent", "confidence", 
                   "autonomyLevel", "explainability", "profiles", "profile", 
                   "gender", "race", "policyParticipants", "partID", "hasRole", 
                   "conditions", "deadline", "minDecisionTime", "offset", 
                   "deadlineID", "timeUnit", "date", "participantExclusion", 
                   "minParticipant", "vetoRight", "passedTests", "evaluationMode", 
                   "labelsCondition", "include", "parameters", "votParams", 
                   "ratio", "default", "fallback", "policyReference", "order", 
                   "orderType", "orderTypeValue", "orderMode", "carryOver", 
                   "booleanValue", "phases", "nestedPolicy" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    ID=81
    SIGNED_INT=82
    FLOAT=83
    WS=84

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class GovernanceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def scopes(self):
            return self.getTypedRuleContext(govdslParser.ScopesContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def policy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.PolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_governance

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGovernance" ):
                listener.enterGovernance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGovernance" ):
                listener.exitGovernance(self)




    def governance(self):

        localctx = govdslParser.GovernanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_governance)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self.scopes()
            self.state = 153
            self.participants()
            self.state = 155 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 154
                self.policy()
                self.state = 157 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 159
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def topLevelSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelSinglePolicyContext,0)


        def topLevelComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.state = 161
                self.topLevelSinglePolicy()
                pass
            elif token in [3]:
                self.state = 162
                self.topLevelComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSinglePolicy" ):
                listener.enterTopLevelSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSinglePolicy" ):
                listener.exitTopLevelSinglePolicy(self)




    def topLevelSinglePolicy(self):

        localctx = govdslParser.TopLevelSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topLevelSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.policyType()
            self.state = 166
            self.match(govdslParser.ID)
            self.state = 167
            self.match(govdslParser.T__0)
            self.state = 168
            self.scope()
            self.state = 169
            self.decisionType()
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==50:
                self.state = 170
                self.policyParticipants()


            self.state = 174
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==51:
                self.state = 173
                self.conditions()


            self.state = 177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==68:
                self.state = 176
                self.parameters()


            self.state = 179
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelComposedPolicy" ):
                listener.enterTopLevelComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelComposedPolicy" ):
                listener.exitTopLevelComposedPolicy(self)




    def topLevelComposedPolicy(self):

        localctx = govdslParser.TopLevelComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_topLevelComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.match(govdslParser.T__2)
            self.state = 182
            self.match(govdslParser.ID)
            self.state = 183
            self.match(govdslParser.T__0)
            self.state = 184
            self.scope()
            self.state = 186
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==72:
                self.state = 185
                self.order()


            self.state = 188
            self.phases()
            self.state = 189
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedSinglePolicy" ):
                listener.enterNestedSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedSinglePolicy" ):
                listener.exitNestedSinglePolicy(self)




    def nestedSinglePolicy(self):

        localctx = govdslParser.NestedSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_nestedSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self.policyType()
            self.state = 192
            self.match(govdslParser.ID)
            self.state = 193
            self.match(govdslParser.T__0)
            self.state = 194
            self.decisionType()
            self.state = 196
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==50:
                self.state = 195
                self.policyParticipants()


            self.state = 199
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==51:
                self.state = 198
                self.conditions()


            self.state = 202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==68:
                self.state = 201
                self.parameters()


            self.state = 204
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedComposedPolicy" ):
                listener.enterNestedComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedComposedPolicy" ):
                listener.exitNestedComposedPolicy(self)




    def nestedComposedPolicy(self):

        localctx = govdslParser.NestedComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_nestedComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.match(govdslParser.T__2)
            self.state = 207
            self.match(govdslParser.ID)
            self.state = 208
            self.match(govdslParser.T__0)
            self.state = 210
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==72:
                self.state = 209
                self.order()


            self.state = 212
            self.phases()
            self.state = 213
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1008) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def projects(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProjectsContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProjectsContext,i)


        def activities(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivitiesContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivitiesContext,i)


        def tasks(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TasksContext)
            else:
                return self.getTypedRuleContext(govdslParser.TasksContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_scopes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopes" ):
                listener.enterScopes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopes" ):
                listener.exitScopes(self)




    def scopes(self):

        localctx = govdslParser.ScopesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_scopes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 217
            self.match(govdslParser.T__9)
            self.state = 218
            self.match(govdslParser.T__10)
            self.state = 222 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 222
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13]:
                    self.state = 219
                    self.projects()
                    pass
                elif token in [15]:
                    self.state = 220
                    self.activities()
                    pass
                elif token in [18]:
                    self.state = 221
                    self.tasks()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 224 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 303104) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self.match(govdslParser.T__11)
            self.state = 227
            self.match(govdslParser.T__10)
            self.state = 228
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProjectContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProjectContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_projects

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProjects" ):
                listener.enterProjects(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProjects" ):
                listener.exitProjects(self)




    def projects(self):

        localctx = govdslParser.ProjectsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_projects)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(govdslParser.T__12)
            self.state = 231
            self.match(govdslParser.T__10)
            self.state = 233 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 232
                self.project()
                self.state = 235 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==81):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 237
            self.match(govdslParser.ID)
            self.state = 243
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 238
                self.match(govdslParser.T__13)
                self.state = 239
                self.platform()
                self.state = 240
                self.match(govdslParser.T__10)
                self.state = 241
                self.repoID()


            self.state = 255
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 245
                self.match(govdslParser.T__0)
                self.state = 246
                self.match(govdslParser.T__14)
                self.state = 247
                self.match(govdslParser.T__10)
                self.state = 249 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 248
                    self.activity()
                    self.state = 251 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==81):
                        break

                self.state = 253
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self.match(govdslParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 259
            self.match(govdslParser.ID)
            self.state = 262
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 260
                self.match(govdslParser.T__16)
                self.state = 261
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivitiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_activities

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivities" ):
                listener.enterActivities(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivities" ):
                listener.exitActivities(self)




    def activities(self):

        localctx = govdslParser.ActivitiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_activities)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(govdslParser.T__14)
            self.state = 265
            self.match(govdslParser.T__10)
            self.state = 267 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 266
                self.activity()
                self.state = 269 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==81):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_activity)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.match(govdslParser.ID)
            self.state = 282
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 272
                self.match(govdslParser.T__0)
                self.state = 273
                self.match(govdslParser.T__17)
                self.state = 274
                self.match(govdslParser.T__10)
                self.state = 276 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 275
                    self.task()
                    self.state = 278 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==81):
                        break

                self.state = 280
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TasksContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_tasks

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTasks" ):
                listener.enterTasks(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTasks" ):
                listener.exitTasks(self)




    def tasks(self):

        localctx = govdslParser.TasksContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_tasks)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self.match(govdslParser.T__17)
            self.state = 285
            self.match(govdslParser.T__10)
            self.state = 287 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 286
                self.task()
                self.state = 289 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==81):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            self.match(govdslParser.ID)
            self.state = 294
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 292
                self.match(govdslParser.T__10)
                self.state = 293
                self.taskType()


            self.state = 300
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 296
                self.match(govdslParser.T__0)
                self.state = 297
                self.taskContent()
                self.state = 298
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_taskContent)
        try:
            self.state = 307
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 304
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 305
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 306
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self.action()
            self.state = 310
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 312
            self.match(govdslParser.T__21)
            self.state = 313
            self.match(govdslParser.T__10)
            self.state = 314
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 58720256) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.match(govdslParser.T__25)
            self.state = 319
            self.match(govdslParser.T__10)
            self.state = 320
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 939524096) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(govdslParser.T__29)
            self.state = 325
            self.match(govdslParser.T__10)
            self.state = 326
            self.match(govdslParser.ID)
            self.state = 331
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 327
                self.match(govdslParser.T__30)
                self.state = 328
                self.match(govdslParser.ID)
                self.state = 333
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecisionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanDecision(self):
            return self.getTypedRuleContext(govdslParser.BooleanDecisionContext,0)


        def stringList(self):
            return self.getTypedRuleContext(govdslParser.StringListContext,0)


        def elementList(self):
            return self.getTypedRuleContext(govdslParser.ElementListContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_decisionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecisionType" ):
                listener.enterDecisionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecisionType" ):
                listener.exitDecisionType(self)




    def decisionType(self):

        localctx = govdslParser.DecisionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_decisionType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            self.match(govdslParser.T__31)
            self.state = 335
            self.match(govdslParser.T__32)
            self.state = 339
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 336
                self.booleanDecision()
                pass
            elif token in [35]:
                self.state = 337
                self.stringList()
                pass
            elif token in [36]:
                self.state = 338
                self.elementList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanDecision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDecision" ):
                listener.enterBooleanDecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDecision" ):
                listener.exitBooleanDecision(self)




    def booleanDecision(self):

        localctx = govdslParser.BooleanDecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_booleanDecision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341
            self.match(govdslParser.T__33)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_stringList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringList" ):
                listener.enterStringList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringList" ):
                listener.exitStringList(self)




    def stringList(self):

        localctx = govdslParser.StringListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_stringList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 343
            self.match(govdslParser.T__34)
            self.state = 344
            self.match(govdslParser.T__10)
            self.state = 345
            self.match(govdslParser.ID)
            self.state = 350
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 346
                self.match(govdslParser.T__30)
                self.state = 347
                self.match(govdslParser.ID)
                self.state = 352
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_elementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementList" ):
                listener.enterElementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementList" ):
                listener.exitElementList(self)




    def elementList(self):

        localctx = govdslParser.ElementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_elementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 353
            self.match(govdslParser.T__35)
            self.state = 354
            self.match(govdslParser.T__10)
            self.state = 355
            self.match(govdslParser.ID)
            self.state = 360
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 356
                self.match(govdslParser.T__30)
                self.state = 357
                self.match(govdslParser.ID)
                self.state = 362
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.RolesContext)
            else:
                return self.getTypedRuleContext(govdslParser.RolesContext,i)


        def individuals(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualsContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualsContext,i)


        def profiles(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProfilesContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProfilesContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_participants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            self.match(govdslParser.T__36)
            self.state = 364
            self.match(govdslParser.T__10)
            self.state = 368 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 368
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [38]:
                    self.state = 365
                    self.roles()
                    pass
                elif token in [39]:
                    self.state = 366
                    self.individuals()
                    pass
                elif token in [47]:
                    self.state = 367
                    self.profiles()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 370 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 141562122076160) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 372
            self.match(govdslParser.T__37)
            self.state = 373
            self.match(govdslParser.T__10)
            self.state = 374
            self.match(govdslParser.ID)
            self.state = 379
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 375
                self.match(govdslParser.T__30)
                self.state = 376
                self.match(govdslParser.ID)
                self.state = 381
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individualEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualEntryContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualEntryContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 382
            self.match(govdslParser.T__38)
            self.state = 383
            self.match(govdslParser.T__10)
            self.state = 384
            self.individualEntry()
            self.state = 391
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 31)) & ~0x3f) == 0 and ((1 << (_la - 31)) & 1125899906846721) != 0):
                self.state = 386
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 385
                    self.match(govdslParser.T__30)


                self.state = 388
                self.individualEntry()
                self.state = 393
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individual(self):
            return self.getTypedRuleContext(govdslParser.IndividualContext,0)


        def agent(self):
            return self.getTypedRuleContext(govdslParser.AgentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individualEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividualEntry" ):
                listener.enterIndividualEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividualEntry" ):
                listener.exitIndividualEntry(self)




    def individualEntry(self):

        localctx = govdslParser.IndividualEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_individualEntry)
        try:
            self.state = 396
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [81]:
                self.enterOuterAlt(localctx, 1)
                self.state = 394
                self.individual()
                pass
            elif token in [43]:
                self.enterOuterAlt(localctx, 2)
                self.state = 395
                self.agent()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def withProfile(self):
            return self.getTypedRuleContext(govdslParser.WithProfileContext,0)


        def withRole(self):
            return self.getTypedRuleContext(govdslParser.WithRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividual" ):
                listener.enterIndividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividual" ):
                listener.exitIndividual(self)




    def individual(self):

        localctx = govdslParser.IndividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_individual)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            self.match(govdslParser.ID)
            self.state = 416
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 399
                self.match(govdslParser.T__0)
                self.state = 401
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==40:
                    self.state = 400
                    self.voteValue()


                self.state = 404
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
                if la_ == 1:
                    self.state = 403
                    self.match(govdslParser.T__30)


                self.state = 407
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==41:
                    self.state = 406
                    self.withProfile()


                self.state = 410
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 409
                    self.match(govdslParser.T__30)


                self.state = 413
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==42:
                    self.state = 412
                    self.withRole()


                self.state = 415
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoteValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_voteValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoteValue" ):
                listener.enterVoteValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoteValue" ):
                listener.exitVoteValue(self)




    def voteValue(self):

        localctx = govdslParser.VoteValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_voteValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            self.match(govdslParser.T__39)
            self.state = 419
            self.match(govdslParser.T__10)
            self.state = 420
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithProfileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_withProfile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithProfile" ):
                listener.enterWithProfile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithProfile" ):
                listener.exitWithProfile(self)




    def withProfile(self):

        localctx = govdslParser.WithProfileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_withProfile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            self.match(govdslParser.T__40)
            self.state = 423
            self.match(govdslParser.T__10)
            self.state = 424
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_withRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithRole" ):
                listener.enterWithRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithRole" ):
                listener.exitWithRole(self)




    def withRole(self):

        localctx = govdslParser.WithRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_withRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 426
            self.match(govdslParser.T__41)
            self.state = 427
            self.match(govdslParser.T__10)
            self.state = 428
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AgentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def confidence(self):
            return self.getTypedRuleContext(govdslParser.ConfidenceContext,0)


        def autonomyLevel(self):
            return self.getTypedRuleContext(govdslParser.AutonomyLevelContext,0)


        def explainability(self):
            return self.getTypedRuleContext(govdslParser.ExplainabilityContext,0)


        def withRole(self):
            return self.getTypedRuleContext(govdslParser.WithRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_agent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent" ):
                listener.enterAgent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent" ):
                listener.exitAgent(self)




    def agent(self):

        localctx = govdslParser.AgentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_agent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            self.match(govdslParser.T__42)
            self.state = 431
            self.match(govdslParser.ID)
            self.state = 461
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 432
                self.match(govdslParser.T__0)
                self.state = 434
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==40:
                    self.state = 433
                    self.voteValue()


                self.state = 437
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
                if la_ == 1:
                    self.state = 436
                    self.match(govdslParser.T__30)


                self.state = 440
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==44:
                    self.state = 439
                    self.confidence()


                self.state = 443
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
                if la_ == 1:
                    self.state = 442
                    self.match(govdslParser.T__30)


                self.state = 446
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==45:
                    self.state = 445
                    self.autonomyLevel()


                self.state = 449
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                if la_ == 1:
                    self.state = 448
                    self.match(govdslParser.T__30)


                self.state = 452
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==46:
                    self.state = 451
                    self.explainability()


                self.state = 455
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 454
                    self.match(govdslParser.T__30)


                self.state = 458
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==42:
                    self.state = 457
                    self.withRole()


                self.state = 460
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfidenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_confidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfidence" ):
                listener.enterConfidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfidence" ):
                listener.exitConfidence(self)




    def confidence(self):

        localctx = govdslParser.ConfidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_confidence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self.match(govdslParser.T__43)
            self.state = 464
            self.match(govdslParser.T__10)
            self.state = 465
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutonomyLevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_autonomyLevel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutonomyLevel" ):
                listener.enterAutonomyLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutonomyLevel" ):
                listener.exitAutonomyLevel(self)




    def autonomyLevel(self):

        localctx = govdslParser.AutonomyLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_autonomyLevel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 467
            self.match(govdslParser.T__44)
            self.state = 468
            self.match(govdslParser.T__10)
            self.state = 469
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplainabilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_explainability

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplainability" ):
                listener.enterExplainability(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplainability" ):
                listener.exitExplainability(self)




    def explainability(self):

        localctx = govdslParser.ExplainabilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_explainability)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.match(govdslParser.T__45)
            self.state = 472
            self.match(govdslParser.T__10)
            self.state = 473
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProfilesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def profile(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProfileContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProfileContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_profiles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProfiles" ):
                listener.enterProfiles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProfiles" ):
                listener.exitProfiles(self)




    def profiles(self):

        localctx = govdslParser.ProfilesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_profiles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            self.match(govdslParser.T__46)
            self.state = 476
            self.match(govdslParser.T__10)
            self.state = 477
            self.profile()
            self.state = 484
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31 or _la==81:
                self.state = 479
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 478
                    self.match(govdslParser.T__30)


                self.state = 481
                self.profile()
                self.state = 486
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProfileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def gender(self):
            return self.getTypedRuleContext(govdslParser.GenderContext,0)


        def race(self):
            return self.getTypedRuleContext(govdslParser.RaceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_profile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProfile" ):
                listener.enterProfile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProfile" ):
                listener.exitProfile(self)




    def profile(self):

        localctx = govdslParser.ProfileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_profile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 487
            self.match(govdslParser.ID)
            self.state = 488
            self.match(govdslParser.T__0)
            self.state = 503
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48]:
                self.state = 489
                self.gender()
                self.state = 491
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 490
                    self.match(govdslParser.T__30)


                self.state = 494
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==49:
                    self.state = 493
                    self.race()


                pass
            elif token in [49]:
                self.state = 496
                self.race()
                self.state = 498
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 497
                    self.match(govdslParser.T__30)


                self.state = 501
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==48:
                    self.state = 500
                    self.gender()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 505
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_gender

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGender" ):
                listener.enterGender(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGender" ):
                listener.exitGender(self)




    def gender(self):

        localctx = govdslParser.GenderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_gender)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 507
            self.match(govdslParser.T__47)
            self.state = 508
            self.match(govdslParser.T__10)
            self.state = 509
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_race

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRace" ):
                listener.enterRace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRace" ):
                listener.exitRace(self)




    def race(self):

        localctx = govdslParser.RaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_race)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 511
            self.match(govdslParser.T__48)
            self.state = 512
            self.match(govdslParser.T__10)
            self.state = 513
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def partID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PartIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.PartIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_policyParticipants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyParticipants" ):
                listener.enterPolicyParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyParticipants" ):
                listener.exitPolicyParticipants(self)




    def policyParticipants(self):

        localctx = govdslParser.PolicyParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_policyParticipants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            self.match(govdslParser.T__49)
            self.state = 516
            self.match(govdslParser.T__10)
            self.state = 517
            self.partID()
            self.state = 522
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 518
                self.match(govdslParser.T__30)
                self.state = 519
                self.partID()
                self.state = 524
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_partID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartID" ):
                listener.enterPartID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartID" ):
                listener.exitPartID(self)




    def partID(self):

        localctx = govdslParser.PartIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_partID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 525
            self.match(govdslParser.ID)
            self.state = 527
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 526
                self.hasRole()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 529
            self.match(govdslParser.T__32)
            self.state = 530
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def minDecisionTime(self):
            return self.getTypedRuleContext(govdslParser.MinDecisionTimeContext,0)


        def participantExclusion(self):
            return self.getTypedRuleContext(govdslParser.ParticipantExclusionContext,0)


        def minParticipant(self):
            return self.getTypedRuleContext(govdslParser.MinParticipantContext,0)


        def vetoRight(self):
            return self.getTypedRuleContext(govdslParser.VetoRightContext,0)


        def passedTests(self):
            return self.getTypedRuleContext(govdslParser.PassedTestsContext,0)


        def labelsCondition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.LabelsConditionContext)
            else:
                return self.getTypedRuleContext(govdslParser.LabelsConditionContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 532
            self.match(govdslParser.T__50)
            self.state = 533
            self.match(govdslParser.T__10)
            self.state = 535
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 534
                self.deadline()


            self.state = 538
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==53:
                self.state = 537
                self.minDecisionTime()


            self.state = 541
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==58:
                self.state = 540
                self.participantExclusion()


            self.state = 544
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==59:
                self.state = 543
                self.minParticipant()


            self.state = 547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==60:
                self.state = 546
                self.vetoRight()


            self.state = 550
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==61:
                self.state = 549
                self.passedTests()


            self.state = 555
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==65:
                self.state = 552
                self.labelsCondition()
                self.state = 557
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_deadline)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 558
            self.match(govdslParser.T__51)
            self.state = 560
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==81:
                self.state = 559
                self.deadlineID()


            self.state = 562
            self.match(govdslParser.T__10)
            self.state = 569
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.state = 563
                self.offset()
                pass

            elif la_ == 2:
                self.state = 564
                self.date()
                pass

            elif la_ == 3:
                self.state = 565
                self.offset()
                self.state = 566
                self.match(govdslParser.T__30)
                self.state = 567
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinDecisionTimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minDecisionTime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinDecisionTime" ):
                listener.enterMinDecisionTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinDecisionTime" ):
                listener.exitMinDecisionTime(self)




    def minDecisionTime(self):

        localctx = govdslParser.MinDecisionTimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_minDecisionTime)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 571
            self.match(govdslParser.T__52)
            self.state = 573
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==81:
                self.state = 572
                self.match(govdslParser.ID)


            self.state = 575
            self.match(govdslParser.T__10)
            self.state = 582
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.state = 576
                self.offset()
                pass

            elif la_ == 2:
                self.state = 577
                self.date()
                pass

            elif la_ == 3:
                self.state = 578
                self.offset()
                self.state = 579
                self.match(govdslParser.T__30)
                self.state = 580
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 584
            self.match(govdslParser.SIGNED_INT)
            self.state = 585
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 587
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 589
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 270215977642229760) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 591
            self.match(govdslParser.SIGNED_INT)
            self.state = 592
            self.match(govdslParser.T__16)
            self.state = 593
            self.match(govdslParser.SIGNED_INT)
            self.state = 594
            self.match(govdslParser.T__16)
            self.state = 595
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_participantExclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantExclusion" ):
                listener.enterParticipantExclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantExclusion" ):
                listener.exitParticipantExclusion(self)




    def participantExclusion(self):

        localctx = govdslParser.ParticipantExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_participantExclusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 597
            self.match(govdslParser.T__57)
            self.state = 598
            self.match(govdslParser.T__10)
            self.state = 599
            self.match(govdslParser.ID)
            self.state = 604
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 600
                self.match(govdslParser.T__30)
                self.state = 601
                self.match(govdslParser.ID)
                self.state = 606
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinParticipantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minParticipant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinParticipant" ):
                listener.enterMinParticipant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinParticipant" ):
                listener.exitMinParticipant(self)




    def minParticipant(self):

        localctx = govdslParser.MinParticipantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_minParticipant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 607
            self.match(govdslParser.T__58)
            self.state = 608
            self.match(govdslParser.T__10)
            self.state = 609
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VetoRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_vetoRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVetoRight" ):
                listener.enterVetoRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVetoRight" ):
                listener.exitVetoRight(self)




    def vetoRight(self):

        localctx = govdslParser.VetoRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_vetoRight)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 611
            self.match(govdslParser.T__59)
            self.state = 612
            self.match(govdslParser.T__10)
            self.state = 613
            self.match(govdslParser.ID)
            self.state = 618
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 614
                self.match(govdslParser.T__30)
                self.state = 615
                self.match(govdslParser.ID)
                self.state = 620
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PassedTestsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_passedTests

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPassedTests" ):
                listener.enterPassedTests(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPassedTests" ):
                listener.exitPassedTests(self)




    def passedTests(self):

        localctx = govdslParser.PassedTestsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_passedTests)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 621
            self.match(govdslParser.T__60)
            self.state = 623
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 62)) & ~0x3f) == 0 and ((1 << (_la - 62)) & 7) != 0):
                self.state = 622
                self.evaluationMode()


            self.state = 625
            self.match(govdslParser.T__10)
            self.state = 626
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EvaluationModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_evaluationMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvaluationMode" ):
                listener.enterEvaluationMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvaluationMode" ):
                listener.exitEvaluationMode(self)




    def evaluationMode(self):

        localctx = govdslParser.EvaluationModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_evaluationMode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 628
            _la = self._input.LA(1)
            if not(((((_la - 62)) & ~0x3f) == 0 and ((1 << (_la - 62)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def include(self):
            return self.getTypedRuleContext(govdslParser.IncludeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_labelsCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelsCondition" ):
                listener.enterLabelsCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelsCondition" ):
                listener.exitLabelsCondition(self)




    def labelsCondition(self):

        localctx = govdslParser.LabelsConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_labelsCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 630
            self.match(govdslParser.T__64)
            self.state = 632
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 62)) & ~0x3f) == 0 and ((1 << (_la - 62)) & 7) != 0):
                self.state = 631
                self.evaluationMode()


            self.state = 635
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66 or _la==67:
                self.state = 634
                self.include()


            self.state = 637
            self.match(govdslParser.T__10)
            self.state = 638
            self.match(govdslParser.ID)
            self.state = 643
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 639
                self.match(govdslParser.T__30)
                self.state = 640
                self.match(govdslParser.ID)
                self.state = 645
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_include

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude" ):
                listener.enterInclude(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude" ):
                listener.exitInclude(self)




    def include(self):

        localctx = govdslParser.IncludeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_include)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 646
            _la = self._input.LA(1)
            if not(_la==66 or _la==67):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def fallback(self):
            return self.getTypedRuleContext(govdslParser.FallbackContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 648
            self.match(govdslParser.T__67)
            self.state = 649
            self.match(govdslParser.T__10)
            self.state = 653
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [69]:
                self.state = 650
                self.votParams()
                pass
            elif token in [70]:
                self.state = 651
                self.default()
                pass
            elif token in [71]:
                self.state = 652
                self.fallback()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_votParams)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 655
            self.ratio()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 657
            self.match(govdslParser.T__68)
            self.state = 658
            self.match(govdslParser.T__10)
            self.state = 659
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def policyReference(self):
            return self.getTypedRuleContext(govdslParser.PolicyReferenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 661
            self.match(govdslParser.T__69)
            self.state = 662
            self.match(govdslParser.T__10)
            self.state = 665
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 6, 7, 8, 9]:
                self.state = 663
                self.nestedPolicy()
                pass
            elif token in [81]:
                self.state = 664
                self.policyReference()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FallbackContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def policyReference(self):
            return self.getTypedRuleContext(govdslParser.PolicyReferenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_fallback

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFallback" ):
                listener.enterFallback(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFallback" ):
                listener.exitFallback(self)




    def fallback(self):

        localctx = govdslParser.FallbackContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_fallback)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 667
            self.match(govdslParser.T__70)
            self.state = 668
            self.match(govdslParser.T__10)
            self.state = 671
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 6, 7, 8, 9]:
                self.state = 669
                self.nestedPolicy()
                pass
            elif token in [81]:
                self.state = 670
                self.policyReference()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_policyReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyReference" ):
                listener.enterPolicyReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyReference" ):
                listener.exitPolicyReference(self)




    def policyReference(self):

        localctx = govdslParser.PolicyReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_policyReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 673
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def carryOver(self):
            return self.getTypedRuleContext(govdslParser.CarryOverContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 675
            self.match(govdslParser.T__71)
            self.state = 676
            self.match(govdslParser.T__10)

            self.state = 677
            self.orderType()
            self.state = 678
            self.orderMode()
            self.state = 680
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==77:
                self.state = 679
                self.carryOver()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderTypeValue(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_orderType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 682
            self.match(govdslParser.T__72)
            self.state = 683
            self.match(govdslParser.T__10)
            self.state = 684
            self.orderTypeValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderTypeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderTypeValue" ):
                listener.enterOrderTypeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderTypeValue" ):
                listener.exitOrderTypeValue(self)




    def orderTypeValue(self):

        localctx = govdslParser.OrderTypeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_orderTypeValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 686
            _la = self._input.LA(1)
            if not(_la==74 or _la==75):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_orderMode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 688
            self.match(govdslParser.T__75)
            self.state = 689
            self.match(govdslParser.T__10)
            self.state = 690
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CarryOverContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_carryOver

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCarryOver" ):
                listener.enterCarryOver(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCarryOver" ):
                listener.exitCarryOver(self)




    def carryOver(self):

        localctx = govdslParser.CarryOverContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_carryOver)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self.match(govdslParser.T__76)
            self.state = 693
            self.match(govdslParser.T__10)
            self.state = 694
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = govdslParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 696
            _la = self._input.LA(1)
            if not(_la==78 or _la==79):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.NestedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.NestedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 698
            self.match(govdslParser.T__79)
            self.state = 699
            self.match(govdslParser.T__0)
            self.state = 701 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 700
                self.nestedPolicy()
                self.state = 703 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 705
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedSinglePolicyContext,0)


        def nestedComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPolicy" ):
                listener.enterNestedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPolicy" ):
                listener.exitNestedPolicy(self)




    def nestedPolicy(self):

        localctx = govdslParser.NestedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_nestedPolicy)
        try:
            self.state = 709
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 707
                self.nestedSinglePolicy()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 708
                self.nestedComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





