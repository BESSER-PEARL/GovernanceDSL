# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,52,336,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,1,0,1,0,3,0,89,8,0,1,0,1,0,1,1,1,1,
        1,1,1,1,1,1,3,1,98,8,1,1,1,3,1,101,8,1,1,1,3,1,104,8,1,1,1,1,1,1,
        2,1,2,1,2,1,2,1,2,3,2,113,8,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,3,3,122,
        8,3,1,3,3,3,125,8,3,1,3,3,3,128,8,3,1,3,1,3,1,4,1,4,1,4,1,4,3,4,
        136,8,4,1,4,1,4,1,4,1,5,1,5,1,6,1,6,1,6,1,6,1,6,3,6,148,8,6,1,7,
        1,7,1,7,1,7,1,7,1,7,1,7,3,7,157,8,7,1,8,1,8,1,9,1,9,1,9,3,9,164,
        8,9,1,10,1,10,1,10,1,11,1,11,1,11,1,11,3,11,173,8,11,1,11,1,11,1,
        11,1,11,1,12,1,12,1,13,1,13,1,13,3,13,184,8,13,1,14,1,14,1,14,1,
        15,1,15,1,15,1,15,1,16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,1,19,1,
        19,1,19,1,19,1,19,5,19,206,8,19,10,19,12,19,209,9,19,1,20,1,20,1,
        20,1,20,3,20,215,8,20,1,20,1,20,3,20,219,8,20,3,20,221,8,20,1,21,
        1,21,1,21,1,21,1,21,5,21,228,8,21,10,21,12,21,231,9,21,1,22,1,22,
        1,23,1,23,1,23,1,23,1,23,5,23,240,8,23,10,23,12,23,243,9,23,1,24,
        1,24,3,24,247,8,24,1,24,3,24,250,8,24,1,25,1,25,1,25,1,26,1,26,1,
        26,1,27,1,27,1,27,3,27,261,8,27,1,28,1,28,1,28,1,28,1,28,1,28,1,
        28,1,28,1,28,3,28,272,8,28,1,29,1,29,1,29,1,30,1,30,1,31,1,31,1,
        32,1,32,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,33,3,33,291,8,33,1,
        34,1,34,1,34,1,34,1,34,1,34,3,34,299,8,34,1,35,1,35,1,35,1,36,1,
        36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,317,
        8,38,1,39,1,39,1,40,1,40,1,41,1,41,1,41,4,41,326,8,41,11,41,12,41,
        327,1,41,1,41,1,42,1,42,3,42,334,8,42,1,42,0,0,43,0,2,4,6,8,10,12,
        14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,
        58,60,62,64,66,68,70,72,74,76,78,80,82,84,0,7,1,0,4,6,1,0,15,17,
        1,0,19,21,1,0,23,25,1,0,35,38,1,0,44,45,1,0,46,47,325,0,88,1,0,0,
        0,2,92,1,0,0,0,4,107,1,0,0,0,6,117,1,0,0,0,8,131,1,0,0,0,10,140,
        1,0,0,0,12,142,1,0,0,0,14,149,1,0,0,0,16,158,1,0,0,0,18,160,1,0,
        0,0,20,165,1,0,0,0,22,168,1,0,0,0,24,178,1,0,0,0,26,183,1,0,0,0,
        28,185,1,0,0,0,30,188,1,0,0,0,32,192,1,0,0,0,34,194,1,0,0,0,36,198,
        1,0,0,0,38,200,1,0,0,0,40,210,1,0,0,0,42,222,1,0,0,0,44,232,1,0,
        0,0,46,234,1,0,0,0,48,244,1,0,0,0,50,251,1,0,0,0,52,254,1,0,0,0,
        54,257,1,0,0,0,56,262,1,0,0,0,58,273,1,0,0,0,60,276,1,0,0,0,62,278,
        1,0,0,0,64,280,1,0,0,0,66,286,1,0,0,0,68,298,1,0,0,0,70,300,1,0,
        0,0,72,303,1,0,0,0,74,306,1,0,0,0,76,309,1,0,0,0,78,318,1,0,0,0,
        80,320,1,0,0,0,82,322,1,0,0,0,84,333,1,0,0,0,86,89,3,2,1,0,87,89,
        3,4,2,0,88,86,1,0,0,0,88,87,1,0,0,0,89,90,1,0,0,0,90,91,5,0,0,1,
        91,1,1,0,0,0,92,93,3,10,5,0,93,94,5,49,0,0,94,95,5,1,0,0,95,97,3,
        12,6,0,96,98,3,40,20,0,97,96,1,0,0,0,97,98,1,0,0,0,98,100,1,0,0,
        0,99,101,3,54,27,0,100,99,1,0,0,0,100,101,1,0,0,0,101,103,1,0,0,
        0,102,104,3,66,33,0,103,102,1,0,0,0,103,104,1,0,0,0,104,105,1,0,
        0,0,105,106,5,2,0,0,106,3,1,0,0,0,107,108,5,3,0,0,108,109,5,49,0,
        0,109,110,5,1,0,0,110,112,3,12,6,0,111,113,3,76,38,0,112,111,1,0,
        0,0,112,113,1,0,0,0,113,114,1,0,0,0,114,115,3,82,41,0,115,116,5,
        2,0,0,116,5,1,0,0,0,117,118,3,10,5,0,118,119,5,49,0,0,119,121,5,
        1,0,0,120,122,3,40,20,0,121,120,1,0,0,0,121,122,1,0,0,0,122,124,
        1,0,0,0,123,125,3,54,27,0,124,123,1,0,0,0,124,125,1,0,0,0,125,127,
        1,0,0,0,126,128,3,66,33,0,127,126,1,0,0,0,127,128,1,0,0,0,128,129,
        1,0,0,0,129,130,5,2,0,0,130,7,1,0,0,0,131,132,5,3,0,0,132,133,5,
        49,0,0,133,135,5,1,0,0,134,136,3,76,38,0,135,134,1,0,0,0,135,136,
        1,0,0,0,136,137,1,0,0,0,137,138,3,82,41,0,138,139,5,2,0,0,139,9,
        1,0,0,0,140,141,7,0,0,0,141,11,1,0,0,0,142,143,5,7,0,0,143,147,5,
        8,0,0,144,148,3,14,7,0,145,148,3,20,10,0,146,148,3,22,11,0,147,144,
        1,0,0,0,147,145,1,0,0,0,147,146,1,0,0,0,148,13,1,0,0,0,149,150,5,
        9,0,0,150,156,5,49,0,0,151,152,5,10,0,0,152,153,3,16,8,0,153,154,
        5,8,0,0,154,155,3,18,9,0,155,157,1,0,0,0,156,151,1,0,0,0,156,157,
        1,0,0,0,157,15,1,0,0,0,158,159,5,11,0,0,159,17,1,0,0,0,160,163,5,
        49,0,0,161,162,5,12,0,0,162,164,5,49,0,0,163,161,1,0,0,0,163,164,
        1,0,0,0,164,19,1,0,0,0,165,166,5,13,0,0,166,167,5,49,0,0,167,21,
        1,0,0,0,168,169,5,14,0,0,169,172,5,49,0,0,170,171,5,8,0,0,171,173,
        3,24,12,0,172,170,1,0,0,0,172,173,1,0,0,0,173,174,1,0,0,0,174,175,
        5,1,0,0,175,176,3,26,13,0,176,177,5,2,0,0,177,23,1,0,0,0,178,179,
        7,1,0,0,179,25,1,0,0,0,180,184,3,30,15,0,181,184,3,34,17,0,182,184,
        3,28,14,0,183,180,1,0,0,0,183,181,1,0,0,0,183,182,1,0,0,0,184,27,
        1,0,0,0,185,186,3,34,17,0,186,187,3,38,19,0,187,29,1,0,0,0,188,189,
        5,18,0,0,189,190,5,8,0,0,190,191,3,32,16,0,191,31,1,0,0,0,192,193,
        7,2,0,0,193,33,1,0,0,0,194,195,5,22,0,0,195,196,5,8,0,0,196,197,
        3,36,18,0,197,35,1,0,0,0,198,199,7,3,0,0,199,37,1,0,0,0,200,201,
        5,26,0,0,201,202,5,8,0,0,202,207,5,49,0,0,203,204,5,27,0,0,204,206,
        5,49,0,0,205,203,1,0,0,0,206,209,1,0,0,0,207,205,1,0,0,0,207,208,
        1,0,0,0,208,39,1,0,0,0,209,207,1,0,0,0,210,211,5,28,0,0,211,220,
        5,8,0,0,212,214,3,42,21,0,213,215,3,46,23,0,214,213,1,0,0,0,214,
        215,1,0,0,0,215,221,1,0,0,0,216,218,3,46,23,0,217,219,3,42,21,0,
        218,217,1,0,0,0,218,219,1,0,0,0,219,221,1,0,0,0,220,212,1,0,0,0,
        220,216,1,0,0,0,221,41,1,0,0,0,222,223,5,29,0,0,223,224,5,8,0,0,
        224,229,3,44,22,0,225,226,5,27,0,0,226,228,3,44,22,0,227,225,1,0,
        0,0,228,231,1,0,0,0,229,227,1,0,0,0,229,230,1,0,0,0,230,43,1,0,0,
        0,231,229,1,0,0,0,232,233,5,49,0,0,233,45,1,0,0,0,234,235,5,30,0,
        0,235,236,5,8,0,0,236,241,3,48,24,0,237,238,5,27,0,0,238,240,3,48,
        24,0,239,237,1,0,0,0,240,243,1,0,0,0,241,239,1,0,0,0,241,242,1,0,
        0,0,242,47,1,0,0,0,243,241,1,0,0,0,244,246,3,44,22,0,245,247,3,50,
        25,0,246,245,1,0,0,0,246,247,1,0,0,0,247,249,1,0,0,0,248,250,3,52,
        26,0,249,248,1,0,0,0,249,250,1,0,0,0,250,49,1,0,0,0,251,252,5,31,
        0,0,252,253,3,44,22,0,253,51,1,0,0,0,254,255,5,32,0,0,255,256,5,
        51,0,0,256,53,1,0,0,0,257,258,5,33,0,0,258,260,5,8,0,0,259,261,3,
        56,28,0,260,259,1,0,0,0,260,261,1,0,0,0,261,55,1,0,0,0,262,263,5,
        34,0,0,263,264,3,60,30,0,264,271,5,8,0,0,265,272,3,58,29,0,266,272,
        3,64,32,0,267,268,3,58,29,0,268,269,5,27,0,0,269,270,3,64,32,0,270,
        272,1,0,0,0,271,265,1,0,0,0,271,266,1,0,0,0,271,267,1,0,0,0,272,
        57,1,0,0,0,273,274,5,50,0,0,274,275,3,62,31,0,275,59,1,0,0,0,276,
        277,5,49,0,0,277,61,1,0,0,0,278,279,7,4,0,0,279,63,1,0,0,0,280,281,
        5,50,0,0,281,282,5,12,0,0,282,283,5,50,0,0,283,284,5,12,0,0,284,
        285,5,50,0,0,285,65,1,0,0,0,286,287,5,39,0,0,287,290,5,8,0,0,288,
        291,3,68,34,0,289,291,3,74,37,0,290,288,1,0,0,0,290,289,1,0,0,0,
        291,67,1,0,0,0,292,299,3,70,35,0,293,299,3,72,36,0,294,295,3,70,
        35,0,295,296,5,27,0,0,296,297,3,72,36,0,297,299,1,0,0,0,298,292,
        1,0,0,0,298,293,1,0,0,0,298,294,1,0,0,0,299,69,1,0,0,0,300,301,5,
        40,0,0,301,302,5,50,0,0,302,71,1,0,0,0,303,304,5,41,0,0,304,305,
        5,51,0,0,305,73,1,0,0,0,306,307,5,42,0,0,307,308,3,84,42,0,308,75,
        1,0,0,0,309,310,5,43,0,0,310,311,5,8,0,0,311,316,3,78,39,0,312,313,
        5,1,0,0,313,314,3,80,40,0,314,315,5,2,0,0,315,317,1,0,0,0,316,312,
        1,0,0,0,316,317,1,0,0,0,317,77,1,0,0,0,318,319,7,5,0,0,319,79,1,
        0,0,0,320,321,7,6,0,0,321,81,1,0,0,0,322,323,5,48,0,0,323,325,5,
        1,0,0,324,326,3,84,42,0,325,324,1,0,0,0,326,327,1,0,0,0,327,325,
        1,0,0,0,327,328,1,0,0,0,328,329,1,0,0,0,329,330,5,2,0,0,330,83,1,
        0,0,0,331,334,3,6,3,0,332,334,3,8,4,0,333,331,1,0,0,0,333,332,1,
        0,0,0,334,85,1,0,0,0,29,88,97,100,103,112,121,124,127,135,147,156,
        163,172,183,207,214,218,220,229,241,246,249,260,271,290,298,316,
        327,333
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'PhasedPolicy'", "'MajorityPolicy'", 
                     "'LeaderDrivenPolicy'", "'AbsoluteMajorityPolicy'", 
                     "'Scope'", "':'", "'Project'", "'from'", "'GitHub'", 
                     "'/'", "'Activity'", "'Task'", "'Issue'", "'Pull request'", 
                     "'All'", "'Status'", "'completed'", "'accepted'", "'partial'", 
                     "'Action'", "'merge'", "'review'", "'release'", "'Labels'", 
                     "','", "'Participants'", "'Roles'", "'Individuals'", 
                     "'as'", "'with confidence'", "'Conditions'", "'Deadline'", 
                     "'days'", "'weeks'", "'months'", "'years'", "'Parameters'", 
                     "'minVotes'", "'ratio'", "'default'", "'Order'", "'Sequential'", 
                     "'Parallel'", "'exclusive'", "'inclusive'", "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "ID", "SIGNED_INT", "FLOAT", "WS" ]

    RULE_policy = 0
    RULE_topLevelSinglePolicy = 1
    RULE_topLevelPhasedPolicy = 2
    RULE_nestedSinglePolicy = 3
    RULE_nestedPhasedPolicy = 4
    RULE_policyType = 5
    RULE_scope = 6
    RULE_project = 7
    RULE_platform = 8
    RULE_repoID = 9
    RULE_activity = 10
    RULE_task = 11
    RULE_taskType = 12
    RULE_taskContent = 13
    RULE_actionWithLabels = 14
    RULE_status = 15
    RULE_statusEnum = 16
    RULE_action = 17
    RULE_actionEnum = 18
    RULE_labels = 19
    RULE_participants = 20
    RULE_roles = 21
    RULE_participantID = 22
    RULE_individuals = 23
    RULE_individualID = 24
    RULE_hasRole = 25
    RULE_confidence = 26
    RULE_conditions = 27
    RULE_deadline = 28
    RULE_offset = 29
    RULE_deadlineID = 30
    RULE_timeUnit = 31
    RULE_date = 32
    RULE_parameters = 33
    RULE_votParams = 34
    RULE_minVotes = 35
    RULE_ratio = 36
    RULE_default = 37
    RULE_order = 38
    RULE_orderType = 39
    RULE_orderMode = 40
    RULE_phases = 41
    RULE_nestedPolicy = 42

    ruleNames =  [ "policy", "topLevelSinglePolicy", "topLevelPhasedPolicy", 
                   "nestedSinglePolicy", "nestedPhasedPolicy", "policyType", 
                   "scope", "project", "platform", "repoID", "activity", 
                   "task", "taskType", "taskContent", "actionWithLabels", 
                   "status", "statusEnum", "action", "actionEnum", "labels", 
                   "participants", "roles", "participantID", "individuals", 
                   "individualID", "hasRole", "confidence", "conditions", 
                   "deadline", "offset", "deadlineID", "timeUnit", "date", 
                   "parameters", "votParams", "minVotes", "ratio", "default", 
                   "order", "orderType", "orderMode", "phases", "nestedPolicy" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    ID=49
    SIGNED_INT=50
    FLOAT=51
    WS=52

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def topLevelSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelSinglePolicyContext,0)


        def topLevelPhasedPolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelPhasedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6]:
                self.state = 86
                self.topLevelSinglePolicy()
                pass
            elif token in [3]:
                self.state = 87
                self.topLevelPhasedPolicy()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 90
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSinglePolicy" ):
                listener.enterTopLevelSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSinglePolicy" ):
                listener.exitTopLevelSinglePolicy(self)




    def topLevelSinglePolicy(self):

        localctx = govdslParser.TopLevelSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_topLevelSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.policyType()
            self.state = 93
            self.match(govdslParser.ID)
            self.state = 94
            self.match(govdslParser.T__0)
            self.state = 95
            self.scope()
            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 96
                self.participants()


            self.state = 100
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 99
                self.conditions()


            self.state = 103
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 102
                self.parameters()


            self.state = 105
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelPhasedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelPhasedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelPhasedPolicy" ):
                listener.enterTopLevelPhasedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelPhasedPolicy" ):
                listener.exitTopLevelPhasedPolicy(self)




    def topLevelPhasedPolicy(self):

        localctx = govdslParser.TopLevelPhasedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topLevelPhasedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self.match(govdslParser.T__2)
            self.state = 108
            self.match(govdslParser.ID)
            self.state = 109
            self.match(govdslParser.T__0)
            self.state = 110
            self.scope()
            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==43:
                self.state = 111
                self.order()


            self.state = 114
            self.phases()
            self.state = 115
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedSinglePolicy" ):
                listener.enterNestedSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedSinglePolicy" ):
                listener.exitNestedSinglePolicy(self)




    def nestedSinglePolicy(self):

        localctx = govdslParser.NestedSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_nestedSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.policyType()
            self.state = 118
            self.match(govdslParser.ID)
            self.state = 119
            self.match(govdslParser.T__0)
            self.state = 121
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 120
                self.participants()


            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 123
                self.conditions()


            self.state = 127
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 126
                self.parameters()


            self.state = 129
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPhasedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPhasedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPhasedPolicy" ):
                listener.enterNestedPhasedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPhasedPolicy" ):
                listener.exitNestedPhasedPolicy(self)




    def nestedPhasedPolicy(self):

        localctx = govdslParser.NestedPhasedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_nestedPhasedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(govdslParser.T__2)
            self.state = 132
            self.match(govdslParser.ID)
            self.state = 133
            self.match(govdslParser.T__0)
            self.state = 135
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==43:
                self.state = 134
                self.order()


            self.state = 137
            self.phases()
            self.state = 138
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 112) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self):
            return self.getTypedRuleContext(govdslParser.ProjectContext,0)


        def activity(self):
            return self.getTypedRuleContext(govdslParser.ActivityContext,0)


        def task(self):
            return self.getTypedRuleContext(govdslParser.TaskContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(govdslParser.T__6)
            self.state = 143
            self.match(govdslParser.T__7)
            self.state = 147
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9]:
                self.state = 144
                self.project()
                pass
            elif token in [13]:
                self.state = 145
                self.activity()
                pass
            elif token in [14]:
                self.state = 146
                self.task()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            self.match(govdslParser.T__8)
            self.state = 150
            self.match(govdslParser.ID)
            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==10:
                self.state = 151
                self.match(govdslParser.T__9)
                self.state = 152
                self.platform()
                self.state = 153
                self.match(govdslParser.T__7)
                self.state = 154
                self.repoID()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(govdslParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.match(govdslParser.ID)
            self.state = 163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 161
                self.match(govdslParser.T__11)
                self.state = 162
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_activity)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.match(govdslParser.T__12)
            self.state = 166
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(govdslParser.T__13)
            self.state = 169
            self.match(govdslParser.ID)
            self.state = 172
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 170
                self.match(govdslParser.T__7)
                self.state = 171
                self.taskType()


            self.state = 174
            self.match(govdslParser.T__0)
            self.state = 175
            self.taskContent()
            self.state = 176
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 229376) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_taskContent)
        try:
            self.state = 183
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 180
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 181
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 182
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.action()
            self.state = 186
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 188
            self.match(govdslParser.T__17)
            self.state = 189
            self.match(govdslParser.T__7)
            self.state = 190
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            self.match(govdslParser.T__21)
            self.state = 195
            self.match(govdslParser.T__7)
            self.state = 196
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 58720256) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(govdslParser.T__25)
            self.state = 201
            self.match(govdslParser.T__7)
            self.state = 202
            self.match(govdslParser.ID)
            self.state = 207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 203
                self.match(govdslParser.T__26)
                self.state = 204
                self.match(govdslParser.ID)
                self.state = 209
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self):
            return self.getTypedRuleContext(govdslParser.RolesContext,0)


        def individuals(self):
            return self.getTypedRuleContext(govdslParser.IndividualsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_participants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self.match(govdslParser.T__27)
            self.state = 211
            self.match(govdslParser.T__7)
            self.state = 220
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [29]:
                self.state = 212
                self.roles()
                self.state = 214
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==30:
                    self.state = 213
                    self.individuals()


                pass
            elif token in [30]:
                self.state = 216
                self.individuals()
                self.state = 218
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 217
                    self.roles()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ParticipantIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.ParticipantIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.match(govdslParser.T__28)
            self.state = 223
            self.match(govdslParser.T__7)
            self.state = 224
            self.participantID()
            self.state = 229
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 225
                self.match(govdslParser.T__26)
                self.state = 226
                self.participantID()
                self.state = 231
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_participantID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantID" ):
                listener.enterParticipantID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantID" ):
                listener.exitParticipantID(self)




    def participantID(self):

        localctx = govdslParser.ParticipantIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_participantID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individualID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.match(govdslParser.T__29)
            self.state = 235
            self.match(govdslParser.T__7)
            self.state = 236
            self.individualID()
            self.state = 241
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 237
                self.match(govdslParser.T__26)
                self.state = 238
                self.individualID()
                self.state = 243
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def confidence(self):
            return self.getTypedRuleContext(govdslParser.ConfidenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individualID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividualID" ):
                listener.enterIndividualID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividualID" ):
                listener.exitIndividualID(self)




    def individualID(self):

        localctx = govdslParser.IndividualIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_individualID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self.participantID()
            self.state = 246
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==31:
                self.state = 245
                self.hasRole()


            self.state = 249
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 248
                self.confidence()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participantID(self):
            return self.getTypedRuleContext(govdslParser.ParticipantIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self.match(govdslParser.T__30)
            self.state = 252
            self.participantID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfidenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_confidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfidence" ):
                listener.enterConfidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfidence" ):
                listener.exitConfidence(self)




    def confidence(self):

        localctx = govdslParser.ConfidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_confidence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.match(govdslParser.T__31)
            self.state = 255
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self.match(govdslParser.T__32)
            self.state = 258
            self.match(govdslParser.T__7)
            self.state = 260
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 259
                self.deadline()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_deadline)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(govdslParser.T__33)
            self.state = 263
            self.deadlineID()
            self.state = 264
            self.match(govdslParser.T__7)
            self.state = 271
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.state = 265
                self.offset()
                pass

            elif la_ == 2:
                self.state = 266
                self.date()
                pass

            elif la_ == 3:
                self.state = 267
                self.offset()
                self.state = 268
                self.match(govdslParser.T__26)
                self.state = 269
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 273
            self.match(govdslParser.SIGNED_INT)
            self.state = 274
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 515396075520) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.match(govdslParser.SIGNED_INT)
            self.state = 281
            self.match(govdslParser.T__11)
            self.state = 282
            self.match(govdslParser.SIGNED_INT)
            self.state = 283
            self.match(govdslParser.T__11)
            self.state = 284
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.match(govdslParser.T__38)
            self.state = 287
            self.match(govdslParser.T__7)
            self.state = 290
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [40, 41]:
                self.state = 288
                self.votParams()
                pass
            elif token in [42]:
                self.state = 289
                self.default()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def minVotes(self):
            return self.getTypedRuleContext(govdslParser.MinVotesContext,0)


        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_votParams)
        try:
            self.state = 298
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 292
                self.minVotes()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 293
                self.ratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 294
                self.minVotes()
                self.state = 295
                self.match(govdslParser.T__26)
                self.state = 296
                self.ratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinVotesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minVotes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinVotes" ):
                listener.enterMinVotes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinVotes" ):
                listener.exitMinVotes(self)




    def minVotes(self):

        localctx = govdslParser.MinVotesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_minVotes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(govdslParser.T__39)
            self.state = 301
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.match(govdslParser.T__40)
            self.state = 304
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            self.match(govdslParser.T__41)
            self.state = 307
            self.nestedPolicy()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self.match(govdslParser.T__42)
            self.state = 310
            self.match(govdslParser.T__7)
            self.state = 311
            self.orderType()
            self.state = 316
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 312
                self.match(govdslParser.T__0)
                self.state = 313
                self.orderMode()
                self.state = 314
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_orderType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            _la = self._input.LA(1)
            if not(_la==44 or _la==45):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_orderMode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            _la = self._input.LA(1)
            if not(_la==46 or _la==47):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.NestedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.NestedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            self.match(govdslParser.T__47)
            self.state = 323
            self.match(govdslParser.T__0)
            self.state = 325 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 324
                self.nestedPolicy()
                self.state = 327 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 120) != 0)):
                    break

            self.state = 329
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedSinglePolicyContext,0)


        def nestedPhasedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPhasedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPolicy" ):
                listener.enterNestedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPolicy" ):
                listener.exitNestedPolicy(self)




    def nestedPolicy(self):

        localctx = govdslParser.NestedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_nestedPolicy)
        try:
            self.state = 333
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 331
                self.nestedSinglePolicy()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 332
                self.nestedPhasedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





