# Generated from govdsl.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,85,737,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,65,
        2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,72,
        7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,1,0,1,0,1,
        0,4,0,160,8,0,11,0,12,0,161,1,0,1,0,1,1,1,1,3,1,168,8,1,1,2,1,2,
        1,2,1,2,1,2,1,2,3,2,176,8,2,1,2,3,2,179,8,2,1,2,3,2,182,8,2,1,2,
        1,2,1,3,1,3,1,3,1,3,1,3,3,3,191,8,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
        1,4,3,4,201,8,4,1,4,3,4,204,8,4,1,4,3,4,207,8,4,1,4,1,4,1,5,1,5,
        1,5,1,5,3,5,215,8,5,1,5,1,5,1,5,1,6,1,6,1,7,1,7,1,7,1,7,1,7,4,7,
        227,8,7,11,7,12,7,228,1,8,1,8,1,8,1,8,1,9,1,9,1,9,4,9,238,8,9,11,
        9,12,9,239,1,10,1,10,1,10,1,10,1,10,1,10,3,10,248,8,10,1,10,1,10,
        1,10,1,10,4,10,254,8,10,11,10,12,10,255,1,10,1,10,3,10,260,8,10,
        1,11,1,11,1,12,1,12,1,12,3,12,267,8,12,1,13,1,13,1,13,4,13,272,8,
        13,11,13,12,13,273,1,14,1,14,1,14,1,14,1,14,4,14,281,8,14,11,14,
        12,14,282,1,14,1,14,3,14,287,8,14,1,15,1,15,1,15,4,15,292,8,15,11,
        15,12,15,293,1,16,1,16,1,16,3,16,299,8,16,1,16,1,16,1,16,1,16,3,
        16,305,8,16,1,17,1,17,1,18,1,18,1,18,3,18,312,8,18,1,19,1,19,1,19,
        1,20,1,20,1,20,1,20,1,21,1,21,1,22,1,22,1,22,1,22,1,23,1,23,1,24,
        1,24,1,24,1,24,1,24,5,24,334,8,24,10,24,12,24,337,9,24,1,25,1,25,
        1,25,1,25,1,25,3,25,344,8,25,1,26,1,26,1,27,1,27,1,27,1,27,1,27,
        5,27,353,8,27,10,27,12,27,356,9,27,1,28,1,28,1,28,1,28,1,28,5,28,
        363,8,28,10,28,12,28,366,9,28,1,29,1,29,1,29,1,29,1,29,4,29,373,
        8,29,11,29,12,29,374,1,30,1,30,1,30,1,30,1,30,5,30,382,8,30,10,30,
        12,30,385,9,30,1,31,1,31,1,31,3,31,390,8,31,1,31,3,31,393,8,31,1,
        32,1,32,1,32,1,32,3,32,399,8,32,1,32,5,32,402,8,32,10,32,12,32,405,
        9,32,1,33,1,33,3,33,409,8,33,1,34,1,34,1,34,3,34,414,8,34,1,34,3,
        34,417,8,34,1,34,3,34,420,8,34,1,34,3,34,423,8,34,1,34,3,34,426,
        8,34,1,34,3,34,429,8,34,1,35,1,35,1,35,1,35,1,36,1,36,1,36,1,36,
        1,37,1,37,1,37,1,37,1,38,1,38,1,38,1,38,3,38,447,8,38,1,38,3,38,
        450,8,38,1,38,3,38,453,8,38,1,38,3,38,456,8,38,1,38,3,38,459,8,38,
        1,38,3,38,462,8,38,1,38,3,38,465,8,38,1,38,3,38,468,8,38,1,38,3,
        38,471,8,38,1,38,3,38,474,8,38,1,39,1,39,1,39,1,39,1,40,1,40,1,40,
        1,40,1,41,1,41,1,41,1,41,1,42,1,42,1,42,1,42,3,42,492,8,42,1,42,
        5,42,495,8,42,10,42,12,42,498,9,42,1,43,1,43,1,43,1,43,3,43,504,
        8,43,1,43,3,43,507,8,43,1,43,1,43,3,43,511,8,43,1,43,3,43,514,8,
        43,3,43,516,8,43,1,43,1,43,1,44,1,44,1,44,1,44,1,45,1,45,1,45,1,
        45,1,46,1,46,1,46,1,46,1,46,5,46,533,8,46,10,46,12,46,536,9,46,1,
        47,1,47,3,47,540,8,47,1,48,1,48,1,48,1,49,1,49,1,49,3,49,548,8,49,
        1,49,3,49,551,8,49,1,49,3,49,554,8,49,1,49,3,49,557,8,49,1,49,3,
        49,560,8,49,1,49,3,49,563,8,49,1,49,3,49,566,8,49,1,49,5,49,569,
        8,49,10,49,12,49,572,9,49,1,50,1,50,3,50,576,8,50,1,50,1,50,1,50,
        1,50,1,50,1,50,1,50,3,50,585,8,50,1,51,1,51,3,51,589,8,51,1,51,1,
        51,1,51,1,51,1,51,1,51,1,51,3,51,598,8,51,1,52,1,52,1,52,1,53,1,
        53,1,54,1,54,1,55,1,55,1,55,1,55,1,55,1,55,1,56,1,56,1,56,1,56,1,
        56,5,56,618,8,56,10,56,12,56,621,9,56,1,57,1,57,1,57,1,57,1,58,1,
        58,1,58,1,58,1,58,5,58,632,8,58,10,58,12,58,635,9,58,1,59,1,59,1,
        59,1,59,1,59,5,59,642,8,59,10,59,12,59,645,9,59,1,60,1,60,3,60,649,
        8,60,1,60,1,60,1,60,1,61,1,61,1,62,1,62,3,62,658,8,62,1,62,3,62,
        661,8,62,1,62,1,62,1,62,1,62,5,62,667,8,62,10,62,12,62,670,9,62,
        1,63,1,63,1,64,1,64,1,64,1,64,1,64,3,64,679,8,64,1,65,1,65,1,66,
        1,66,1,66,1,66,1,67,1,67,1,67,1,67,3,67,691,8,67,1,68,1,68,1,68,
        1,68,3,68,697,8,68,1,69,1,69,1,70,1,70,1,70,1,70,1,70,3,70,706,8,
        70,1,71,1,71,1,71,1,71,1,72,1,72,1,73,1,73,1,73,1,73,1,74,1,74,1,
        74,1,74,1,75,1,75,1,76,1,76,1,76,4,76,727,8,76,11,76,12,76,728,1,
        76,1,76,1,77,1,77,3,77,735,8,77,1,77,0,0,78,0,2,4,6,8,10,12,14,16,
        18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,
        62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,
        104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,
        136,138,140,142,144,146,148,150,152,154,0,9,1,0,4,9,1,0,19,21,1,
        0,23,25,1,0,27,29,1,0,54,57,1,0,63,65,1,0,67,68,1,0,75,76,1,0,79,
        80,751,0,156,1,0,0,0,2,167,1,0,0,0,4,169,1,0,0,0,6,185,1,0,0,0,8,
        195,1,0,0,0,10,210,1,0,0,0,12,219,1,0,0,0,14,221,1,0,0,0,16,230,
        1,0,0,0,18,234,1,0,0,0,20,241,1,0,0,0,22,261,1,0,0,0,24,263,1,0,
        0,0,26,268,1,0,0,0,28,275,1,0,0,0,30,288,1,0,0,0,32,295,1,0,0,0,
        34,306,1,0,0,0,36,311,1,0,0,0,38,313,1,0,0,0,40,316,1,0,0,0,42,320,
        1,0,0,0,44,322,1,0,0,0,46,326,1,0,0,0,48,328,1,0,0,0,50,338,1,0,
        0,0,52,345,1,0,0,0,54,347,1,0,0,0,56,357,1,0,0,0,58,367,1,0,0,0,
        60,376,1,0,0,0,62,386,1,0,0,0,64,394,1,0,0,0,66,408,1,0,0,0,68,410,
        1,0,0,0,70,430,1,0,0,0,72,434,1,0,0,0,74,438,1,0,0,0,76,442,1,0,
        0,0,78,475,1,0,0,0,80,479,1,0,0,0,82,483,1,0,0,0,84,487,1,0,0,0,
        86,499,1,0,0,0,88,519,1,0,0,0,90,523,1,0,0,0,92,527,1,0,0,0,94,537,
        1,0,0,0,96,541,1,0,0,0,98,544,1,0,0,0,100,573,1,0,0,0,102,586,1,
        0,0,0,104,599,1,0,0,0,106,602,1,0,0,0,108,604,1,0,0,0,110,606,1,
        0,0,0,112,612,1,0,0,0,114,622,1,0,0,0,116,626,1,0,0,0,118,636,1,
        0,0,0,120,646,1,0,0,0,122,653,1,0,0,0,124,655,1,0,0,0,126,671,1,
        0,0,0,128,673,1,0,0,0,130,680,1,0,0,0,132,682,1,0,0,0,134,686,1,
        0,0,0,136,692,1,0,0,0,138,698,1,0,0,0,140,700,1,0,0,0,142,707,1,
        0,0,0,144,711,1,0,0,0,146,713,1,0,0,0,148,717,1,0,0,0,150,721,1,
        0,0,0,152,723,1,0,0,0,154,734,1,0,0,0,156,157,3,14,7,0,157,159,3,
        58,29,0,158,160,3,2,1,0,159,158,1,0,0,0,160,161,1,0,0,0,161,159,
        1,0,0,0,161,162,1,0,0,0,162,163,1,0,0,0,163,164,5,0,0,1,164,1,1,
        0,0,0,165,168,3,4,2,0,166,168,3,6,3,0,167,165,1,0,0,0,167,166,1,
        0,0,0,168,3,1,0,0,0,169,170,3,12,6,0,170,171,5,82,0,0,171,172,5,
        1,0,0,172,173,3,16,8,0,173,175,3,50,25,0,174,176,3,92,46,0,175,174,
        1,0,0,0,175,176,1,0,0,0,176,178,1,0,0,0,177,179,3,98,49,0,178,177,
        1,0,0,0,178,179,1,0,0,0,179,181,1,0,0,0,180,182,3,128,64,0,181,180,
        1,0,0,0,181,182,1,0,0,0,182,183,1,0,0,0,183,184,5,2,0,0,184,5,1,
        0,0,0,185,186,5,3,0,0,186,187,5,82,0,0,187,188,5,1,0,0,188,190,3,
        16,8,0,189,191,3,140,70,0,190,189,1,0,0,0,190,191,1,0,0,0,191,192,
        1,0,0,0,192,193,3,152,76,0,193,194,5,2,0,0,194,7,1,0,0,0,195,196,
        3,12,6,0,196,197,5,82,0,0,197,198,5,1,0,0,198,200,3,50,25,0,199,
        201,3,92,46,0,200,199,1,0,0,0,200,201,1,0,0,0,201,203,1,0,0,0,202,
        204,3,98,49,0,203,202,1,0,0,0,203,204,1,0,0,0,204,206,1,0,0,0,205,
        207,3,128,64,0,206,205,1,0,0,0,206,207,1,0,0,0,207,208,1,0,0,0,208,
        209,5,2,0,0,209,9,1,0,0,0,210,211,5,3,0,0,211,212,5,82,0,0,212,214,
        5,1,0,0,213,215,3,140,70,0,214,213,1,0,0,0,214,215,1,0,0,0,215,216,
        1,0,0,0,216,217,3,152,76,0,217,218,5,2,0,0,218,11,1,0,0,0,219,220,
        7,0,0,0,220,13,1,0,0,0,221,222,5,10,0,0,222,226,5,11,0,0,223,227,
        3,18,9,0,224,227,3,26,13,0,225,227,3,30,15,0,226,223,1,0,0,0,226,
        224,1,0,0,0,226,225,1,0,0,0,227,228,1,0,0,0,228,226,1,0,0,0,228,
        229,1,0,0,0,229,15,1,0,0,0,230,231,5,12,0,0,231,232,5,11,0,0,232,
        233,5,82,0,0,233,17,1,0,0,0,234,235,5,13,0,0,235,237,5,11,0,0,236,
        238,3,20,10,0,237,236,1,0,0,0,238,239,1,0,0,0,239,237,1,0,0,0,239,
        240,1,0,0,0,240,19,1,0,0,0,241,247,5,82,0,0,242,243,5,14,0,0,243,
        244,3,22,11,0,244,245,5,11,0,0,245,246,3,24,12,0,246,248,1,0,0,0,
        247,242,1,0,0,0,247,248,1,0,0,0,248,259,1,0,0,0,249,250,5,1,0,0,
        250,251,5,15,0,0,251,253,5,11,0,0,252,254,3,28,14,0,253,252,1,0,
        0,0,254,255,1,0,0,0,255,253,1,0,0,0,255,256,1,0,0,0,256,257,1,0,
        0,0,257,258,5,2,0,0,258,260,1,0,0,0,259,249,1,0,0,0,259,260,1,0,
        0,0,260,21,1,0,0,0,261,262,5,16,0,0,262,23,1,0,0,0,263,266,5,82,
        0,0,264,265,5,17,0,0,265,267,5,82,0,0,266,264,1,0,0,0,266,267,1,
        0,0,0,267,25,1,0,0,0,268,269,5,15,0,0,269,271,5,11,0,0,270,272,3,
        28,14,0,271,270,1,0,0,0,272,273,1,0,0,0,273,271,1,0,0,0,273,274,
        1,0,0,0,274,27,1,0,0,0,275,286,5,82,0,0,276,277,5,1,0,0,277,278,
        5,18,0,0,278,280,5,11,0,0,279,281,3,32,16,0,280,279,1,0,0,0,281,
        282,1,0,0,0,282,280,1,0,0,0,282,283,1,0,0,0,283,284,1,0,0,0,284,
        285,5,2,0,0,285,287,1,0,0,0,286,276,1,0,0,0,286,287,1,0,0,0,287,
        29,1,0,0,0,288,289,5,18,0,0,289,291,5,11,0,0,290,292,3,32,16,0,291,
        290,1,0,0,0,292,293,1,0,0,0,293,291,1,0,0,0,293,294,1,0,0,0,294,
        31,1,0,0,0,295,298,5,82,0,0,296,297,5,11,0,0,297,299,3,34,17,0,298,
        296,1,0,0,0,298,299,1,0,0,0,299,304,1,0,0,0,300,301,5,1,0,0,301,
        302,3,36,18,0,302,303,5,2,0,0,303,305,1,0,0,0,304,300,1,0,0,0,304,
        305,1,0,0,0,305,33,1,0,0,0,306,307,7,1,0,0,307,35,1,0,0,0,308,312,
        3,40,20,0,309,312,3,44,22,0,310,312,3,38,19,0,311,308,1,0,0,0,311,
        309,1,0,0,0,311,310,1,0,0,0,312,37,1,0,0,0,313,314,3,44,22,0,314,
        315,3,48,24,0,315,39,1,0,0,0,316,317,5,22,0,0,317,318,5,11,0,0,318,
        319,3,42,21,0,319,41,1,0,0,0,320,321,7,2,0,0,321,43,1,0,0,0,322,
        323,5,26,0,0,323,324,5,11,0,0,324,325,3,46,23,0,325,45,1,0,0,0,326,
        327,7,3,0,0,327,47,1,0,0,0,328,329,5,30,0,0,329,330,5,11,0,0,330,
        335,5,82,0,0,331,332,5,31,0,0,332,334,5,82,0,0,333,331,1,0,0,0,334,
        337,1,0,0,0,335,333,1,0,0,0,335,336,1,0,0,0,336,49,1,0,0,0,337,335,
        1,0,0,0,338,339,5,32,0,0,339,343,5,33,0,0,340,344,3,52,26,0,341,
        344,3,54,27,0,342,344,3,56,28,0,343,340,1,0,0,0,343,341,1,0,0,0,
        343,342,1,0,0,0,344,51,1,0,0,0,345,346,5,34,0,0,346,53,1,0,0,0,347,
        348,5,35,0,0,348,349,5,11,0,0,349,354,5,82,0,0,350,351,5,31,0,0,
        351,353,5,82,0,0,352,350,1,0,0,0,353,356,1,0,0,0,354,352,1,0,0,0,
        354,355,1,0,0,0,355,55,1,0,0,0,356,354,1,0,0,0,357,358,5,36,0,0,
        358,359,5,11,0,0,359,364,5,82,0,0,360,361,5,31,0,0,361,363,5,82,
        0,0,362,360,1,0,0,0,363,366,1,0,0,0,364,362,1,0,0,0,364,365,1,0,
        0,0,365,57,1,0,0,0,366,364,1,0,0,0,367,368,5,37,0,0,368,372,5,11,
        0,0,369,373,3,60,30,0,370,373,3,64,32,0,371,373,3,84,42,0,372,369,
        1,0,0,0,372,370,1,0,0,0,372,371,1,0,0,0,373,374,1,0,0,0,374,372,
        1,0,0,0,374,375,1,0,0,0,375,59,1,0,0,0,376,377,5,38,0,0,377,378,
        5,11,0,0,378,383,3,62,31,0,379,380,5,31,0,0,380,382,3,62,31,0,381,
        379,1,0,0,0,382,385,1,0,0,0,383,381,1,0,0,0,383,384,1,0,0,0,384,
        61,1,0,0,0,385,383,1,0,0,0,386,392,5,82,0,0,387,389,5,1,0,0,388,
        390,3,70,35,0,389,388,1,0,0,0,389,390,1,0,0,0,390,391,1,0,0,0,391,
        393,5,2,0,0,392,387,1,0,0,0,392,393,1,0,0,0,393,63,1,0,0,0,394,395,
        5,39,0,0,395,396,5,11,0,0,396,403,3,66,33,0,397,399,5,31,0,0,398,
        397,1,0,0,0,398,399,1,0,0,0,399,400,1,0,0,0,400,402,3,66,33,0,401,
        398,1,0,0,0,402,405,1,0,0,0,403,401,1,0,0,0,403,404,1,0,0,0,404,
        65,1,0,0,0,405,403,1,0,0,0,406,409,3,68,34,0,407,409,3,76,38,0,408,
        406,1,0,0,0,408,407,1,0,0,0,409,67,1,0,0,0,410,428,5,82,0,0,411,
        413,5,1,0,0,412,414,3,70,35,0,413,412,1,0,0,0,413,414,1,0,0,0,414,
        416,1,0,0,0,415,417,5,31,0,0,416,415,1,0,0,0,416,417,1,0,0,0,417,
        419,1,0,0,0,418,420,3,72,36,0,419,418,1,0,0,0,419,420,1,0,0,0,420,
        422,1,0,0,0,421,423,5,31,0,0,422,421,1,0,0,0,422,423,1,0,0,0,423,
        425,1,0,0,0,424,426,3,74,37,0,425,424,1,0,0,0,425,426,1,0,0,0,426,
        427,1,0,0,0,427,429,5,2,0,0,428,411,1,0,0,0,428,429,1,0,0,0,429,
        69,1,0,0,0,430,431,5,40,0,0,431,432,5,11,0,0,432,433,5,84,0,0,433,
        71,1,0,0,0,434,435,5,41,0,0,435,436,5,11,0,0,436,437,5,82,0,0,437,
        73,1,0,0,0,438,439,5,42,0,0,439,440,5,11,0,0,440,441,5,82,0,0,441,
        75,1,0,0,0,442,443,5,43,0,0,443,473,5,82,0,0,444,446,5,1,0,0,445,
        447,3,70,35,0,446,445,1,0,0,0,446,447,1,0,0,0,447,449,1,0,0,0,448,
        450,5,31,0,0,449,448,1,0,0,0,449,450,1,0,0,0,450,452,1,0,0,0,451,
        453,3,78,39,0,452,451,1,0,0,0,452,453,1,0,0,0,453,455,1,0,0,0,454,
        456,5,31,0,0,455,454,1,0,0,0,455,456,1,0,0,0,456,458,1,0,0,0,457,
        459,3,80,40,0,458,457,1,0,0,0,458,459,1,0,0,0,459,461,1,0,0,0,460,
        462,5,31,0,0,461,460,1,0,0,0,461,462,1,0,0,0,462,464,1,0,0,0,463,
        465,3,82,41,0,464,463,1,0,0,0,464,465,1,0,0,0,465,467,1,0,0,0,466,
        468,5,31,0,0,467,466,1,0,0,0,467,468,1,0,0,0,468,470,1,0,0,0,469,
        471,3,74,37,0,470,469,1,0,0,0,470,471,1,0,0,0,471,472,1,0,0,0,472,
        474,5,2,0,0,473,444,1,0,0,0,473,474,1,0,0,0,474,77,1,0,0,0,475,476,
        5,44,0,0,476,477,5,11,0,0,477,478,5,84,0,0,478,79,1,0,0,0,479,480,
        5,45,0,0,480,481,5,11,0,0,481,482,5,84,0,0,482,81,1,0,0,0,483,484,
        5,46,0,0,484,485,5,11,0,0,485,486,5,84,0,0,486,83,1,0,0,0,487,488,
        5,47,0,0,488,489,5,11,0,0,489,496,3,86,43,0,490,492,5,31,0,0,491,
        490,1,0,0,0,491,492,1,0,0,0,492,493,1,0,0,0,493,495,3,86,43,0,494,
        491,1,0,0,0,495,498,1,0,0,0,496,494,1,0,0,0,496,497,1,0,0,0,497,
        85,1,0,0,0,498,496,1,0,0,0,499,500,5,82,0,0,500,515,5,1,0,0,501,
        503,3,88,44,0,502,504,5,31,0,0,503,502,1,0,0,0,503,504,1,0,0,0,504,
        506,1,0,0,0,505,507,3,90,45,0,506,505,1,0,0,0,506,507,1,0,0,0,507,
        516,1,0,0,0,508,510,3,90,45,0,509,511,5,31,0,0,510,509,1,0,0,0,510,
        511,1,0,0,0,511,513,1,0,0,0,512,514,3,88,44,0,513,512,1,0,0,0,513,
        514,1,0,0,0,514,516,1,0,0,0,515,501,1,0,0,0,515,508,1,0,0,0,516,
        517,1,0,0,0,517,518,5,2,0,0,518,87,1,0,0,0,519,520,5,48,0,0,520,
        521,5,11,0,0,521,522,5,82,0,0,522,89,1,0,0,0,523,524,5,49,0,0,524,
        525,5,11,0,0,525,526,5,82,0,0,526,91,1,0,0,0,527,528,5,50,0,0,528,
        529,5,11,0,0,529,534,3,94,47,0,530,531,5,31,0,0,531,533,3,94,47,
        0,532,530,1,0,0,0,533,536,1,0,0,0,534,532,1,0,0,0,534,535,1,0,0,
        0,535,93,1,0,0,0,536,534,1,0,0,0,537,539,5,82,0,0,538,540,3,96,48,
        0,539,538,1,0,0,0,539,540,1,0,0,0,540,95,1,0,0,0,541,542,5,33,0,
        0,542,543,5,82,0,0,543,97,1,0,0,0,544,545,5,51,0,0,545,547,5,11,
        0,0,546,548,3,100,50,0,547,546,1,0,0,0,547,548,1,0,0,0,548,550,1,
        0,0,0,549,551,3,102,51,0,550,549,1,0,0,0,550,551,1,0,0,0,551,553,
        1,0,0,0,552,554,3,112,56,0,553,552,1,0,0,0,553,554,1,0,0,0,554,556,
        1,0,0,0,555,557,3,114,57,0,556,555,1,0,0,0,556,557,1,0,0,0,557,559,
        1,0,0,0,558,560,3,116,58,0,559,558,1,0,0,0,559,560,1,0,0,0,560,562,
        1,0,0,0,561,563,3,118,59,0,562,561,1,0,0,0,562,563,1,0,0,0,563,565,
        1,0,0,0,564,566,3,120,60,0,565,564,1,0,0,0,565,566,1,0,0,0,566,570,
        1,0,0,0,567,569,3,124,62,0,568,567,1,0,0,0,569,572,1,0,0,0,570,568,
        1,0,0,0,570,571,1,0,0,0,571,99,1,0,0,0,572,570,1,0,0,0,573,575,5,
        52,0,0,574,576,3,106,53,0,575,574,1,0,0,0,575,576,1,0,0,0,576,577,
        1,0,0,0,577,584,5,11,0,0,578,585,3,104,52,0,579,585,3,110,55,0,580,
        581,3,104,52,0,581,582,5,31,0,0,582,583,3,110,55,0,583,585,1,0,0,
        0,584,578,1,0,0,0,584,579,1,0,0,0,584,580,1,0,0,0,585,101,1,0,0,
        0,586,588,5,53,0,0,587,589,5,82,0,0,588,587,1,0,0,0,588,589,1,0,
        0,0,589,590,1,0,0,0,590,597,5,11,0,0,591,598,3,104,52,0,592,598,
        3,110,55,0,593,594,3,104,52,0,594,595,5,31,0,0,595,596,3,110,55,
        0,596,598,1,0,0,0,597,591,1,0,0,0,597,592,1,0,0,0,597,593,1,0,0,
        0,598,103,1,0,0,0,599,600,5,83,0,0,600,601,3,108,54,0,601,105,1,
        0,0,0,602,603,5,82,0,0,603,107,1,0,0,0,604,605,7,4,0,0,605,109,1,
        0,0,0,606,607,5,83,0,0,607,608,5,17,0,0,608,609,5,83,0,0,609,610,
        5,17,0,0,610,611,5,83,0,0,611,111,1,0,0,0,612,613,5,58,0,0,613,614,
        5,11,0,0,614,619,5,82,0,0,615,616,5,31,0,0,616,618,5,82,0,0,617,
        615,1,0,0,0,618,621,1,0,0,0,619,617,1,0,0,0,619,620,1,0,0,0,620,
        113,1,0,0,0,621,619,1,0,0,0,622,623,5,59,0,0,623,624,5,11,0,0,624,
        625,5,83,0,0,625,115,1,0,0,0,626,627,5,60,0,0,627,628,5,11,0,0,628,
        633,5,82,0,0,629,630,5,31,0,0,630,632,5,82,0,0,631,629,1,0,0,0,632,
        635,1,0,0,0,633,631,1,0,0,0,633,634,1,0,0,0,634,117,1,0,0,0,635,
        633,1,0,0,0,636,637,5,61,0,0,637,638,5,11,0,0,638,643,5,82,0,0,639,
        640,5,31,0,0,640,642,5,82,0,0,641,639,1,0,0,0,642,645,1,0,0,0,643,
        641,1,0,0,0,643,644,1,0,0,0,644,119,1,0,0,0,645,643,1,0,0,0,646,
        648,5,62,0,0,647,649,3,122,61,0,648,647,1,0,0,0,648,649,1,0,0,0,
        649,650,1,0,0,0,650,651,5,11,0,0,651,652,3,150,75,0,652,121,1,0,
        0,0,653,654,7,5,0,0,654,123,1,0,0,0,655,657,5,66,0,0,656,658,3,122,
        61,0,657,656,1,0,0,0,657,658,1,0,0,0,658,660,1,0,0,0,659,661,3,126,
        63,0,660,659,1,0,0,0,660,661,1,0,0,0,661,662,1,0,0,0,662,663,5,11,
        0,0,663,668,5,82,0,0,664,665,5,31,0,0,665,667,5,82,0,0,666,664,1,
        0,0,0,667,670,1,0,0,0,668,666,1,0,0,0,668,669,1,0,0,0,669,125,1,
        0,0,0,670,668,1,0,0,0,671,672,7,6,0,0,672,127,1,0,0,0,673,674,5,
        69,0,0,674,678,5,11,0,0,675,679,3,130,65,0,676,679,3,134,67,0,677,
        679,3,136,68,0,678,675,1,0,0,0,678,676,1,0,0,0,678,677,1,0,0,0,679,
        129,1,0,0,0,680,681,3,132,66,0,681,131,1,0,0,0,682,683,5,70,0,0,
        683,684,5,11,0,0,684,685,5,84,0,0,685,133,1,0,0,0,686,687,5,71,0,
        0,687,690,5,11,0,0,688,691,3,154,77,0,689,691,3,138,69,0,690,688,
        1,0,0,0,690,689,1,0,0,0,691,135,1,0,0,0,692,693,5,72,0,0,693,696,
        5,11,0,0,694,697,3,154,77,0,695,697,3,138,69,0,696,694,1,0,0,0,696,
        695,1,0,0,0,697,137,1,0,0,0,698,699,5,82,0,0,699,139,1,0,0,0,700,
        701,5,73,0,0,701,702,5,11,0,0,702,703,3,142,71,0,703,705,3,146,73,
        0,704,706,3,148,74,0,705,704,1,0,0,0,705,706,1,0,0,0,706,141,1,0,
        0,0,707,708,5,74,0,0,708,709,5,11,0,0,709,710,3,144,72,0,710,143,
        1,0,0,0,711,712,7,7,0,0,712,145,1,0,0,0,713,714,5,77,0,0,714,715,
        5,11,0,0,715,716,3,150,75,0,716,147,1,0,0,0,717,718,5,78,0,0,718,
        719,5,11,0,0,719,720,3,150,75,0,720,149,1,0,0,0,721,722,7,8,0,0,
        722,151,1,0,0,0,723,724,5,81,0,0,724,726,5,1,0,0,725,727,3,154,77,
        0,726,725,1,0,0,0,727,728,1,0,0,0,728,726,1,0,0,0,728,729,1,0,0,
        0,729,730,1,0,0,0,730,731,5,2,0,0,731,153,1,0,0,0,732,735,3,8,4,
        0,733,735,3,10,5,0,734,732,1,0,0,0,734,733,1,0,0,0,735,155,1,0,0,
        0,86,161,167,175,178,181,190,200,203,206,214,226,228,239,247,255,
        259,266,273,282,286,293,298,304,311,335,343,354,364,372,374,383,
        389,392,398,403,408,413,416,419,422,425,428,446,449,452,455,458,
        461,464,467,470,473,491,496,503,506,510,513,515,534,539,547,550,
        553,556,559,562,565,570,575,584,588,597,619,633,643,648,657,660,
        668,678,690,696,705,728,734
    ]

class govdslParser ( Parser ):

    grammarFileName = "govdsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'ComposedPolicy'", "'MajorityPolicy'", 
                     "'LeaderDrivenPolicy'", "'AbsoluteMajorityPolicy'", 
                     "'ConsensusPolicy'", "'LazyConsensusPolicy'", "'VotingPolicy'", 
                     "'Scopes'", "':'", "'Scope'", "'Projects'", "'from'", 
                     "'Activities'", "'GitHub'", "'/'", "'Tasks'", "'Issue'", 
                     "'Pull request'", "'All'", "'Status'", "'completed'", 
                     "'accepted'", "'partial'", "'Action'", "'merge'", "'review'", 
                     "'release'", "'Labels'", "','", "'DecisionType'", "'as'", 
                     "'BooleanDecision'", "'StringList'", "'ElementList'", 
                     "'Participants'", "'Roles'", "'Individuals'", "'vote value'", 
                     "'profile'", "'role'", "'(Agent)'", "'confidence'", 
                     "'autonomy level'", "'explainability'", "'Profiles'", 
                     "'gender'", "'race'", "'Participant list'", "'Conditions'", 
                     "'Deadline'", "'MinDecisionTime'", "'days'", "'weeks'", 
                     "'months'", "'years'", "'ParticipantExclusion'", "'MinParticipants'", 
                     "'VetoRight'", "'AppealRight'", "'PassedTests'", "'pre'", 
                     "'post'", "'concurrent'", "'LabelCondition'", "'include'", 
                     "'not'", "'Parameters'", "'ratio'", "'default'", "'fallback'", 
                     "'Order'", "'Execution'", "'sequential'", "'parallel'", 
                     "'RequireAll'", "'CarryOver'", "'true'", "'false'", 
                     "'Phases'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "ID", "SIGNED_INT", "FLOAT", 
                      "WS" ]

    RULE_governance = 0
    RULE_policy = 1
    RULE_topLevelSinglePolicy = 2
    RULE_topLevelComposedPolicy = 3
    RULE_nestedSinglePolicy = 4
    RULE_nestedComposedPolicy = 5
    RULE_policyType = 6
    RULE_scopes = 7
    RULE_scope = 8
    RULE_projects = 9
    RULE_project = 10
    RULE_platform = 11
    RULE_repoID = 12
    RULE_activities = 13
    RULE_activity = 14
    RULE_tasks = 15
    RULE_task = 16
    RULE_taskType = 17
    RULE_taskContent = 18
    RULE_actionWithLabels = 19
    RULE_status = 20
    RULE_statusEnum = 21
    RULE_action = 22
    RULE_actionEnum = 23
    RULE_labels = 24
    RULE_decisionType = 25
    RULE_booleanDecision = 26
    RULE_stringList = 27
    RULE_elementList = 28
    RULE_participants = 29
    RULE_roles = 30
    RULE_role = 31
    RULE_individuals = 32
    RULE_individualEntry = 33
    RULE_individual = 34
    RULE_voteValue = 35
    RULE_withProfile = 36
    RULE_withRole = 37
    RULE_agent = 38
    RULE_confidence = 39
    RULE_autonomyLevel = 40
    RULE_explainability = 41
    RULE_profiles = 42
    RULE_profile = 43
    RULE_gender = 44
    RULE_race = 45
    RULE_policyParticipants = 46
    RULE_partID = 47
    RULE_hasRole = 48
    RULE_conditions = 49
    RULE_deadline = 50
    RULE_minDecisionTime = 51
    RULE_offset = 52
    RULE_deadlineID = 53
    RULE_timeUnit = 54
    RULE_date = 55
    RULE_participantExclusion = 56
    RULE_minParticipant = 57
    RULE_vetoRight = 58
    RULE_appealRight = 59
    RULE_passedTests = 60
    RULE_evaluationMode = 61
    RULE_labelsCondition = 62
    RULE_include = 63
    RULE_parameters = 64
    RULE_votParams = 65
    RULE_ratio = 66
    RULE_default = 67
    RULE_fallback = 68
    RULE_policyReference = 69
    RULE_order = 70
    RULE_orderType = 71
    RULE_orderTypeValue = 72
    RULE_orderMode = 73
    RULE_carryOver = 74
    RULE_booleanValue = 75
    RULE_phases = 76
    RULE_nestedPolicy = 77

    ruleNames =  [ "governance", "policy", "topLevelSinglePolicy", "topLevelComposedPolicy", 
                   "nestedSinglePolicy", "nestedComposedPolicy", "policyType", 
                   "scopes", "scope", "projects", "project", "platform", 
                   "repoID", "activities", "activity", "tasks", "task", 
                   "taskType", "taskContent", "actionWithLabels", "status", 
                   "statusEnum", "action", "actionEnum", "labels", "decisionType", 
                   "booleanDecision", "stringList", "elementList", "participants", 
                   "roles", "role", "individuals", "individualEntry", "individual", 
                   "voteValue", "withProfile", "withRole", "agent", "confidence", 
                   "autonomyLevel", "explainability", "profiles", "profile", 
                   "gender", "race", "policyParticipants", "partID", "hasRole", 
                   "conditions", "deadline", "minDecisionTime", "offset", 
                   "deadlineID", "timeUnit", "date", "participantExclusion", 
                   "minParticipant", "vetoRight", "appealRight", "passedTests", 
                   "evaluationMode", "labelsCondition", "include", "parameters", 
                   "votParams", "ratio", "default", "fallback", "policyReference", 
                   "order", "orderType", "orderTypeValue", "orderMode", 
                   "carryOver", "booleanValue", "phases", "nestedPolicy" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    ID=82
    SIGNED_INT=83
    FLOAT=84
    WS=85

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class GovernanceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(govdslParser.EOF, 0)

        def scopes(self):
            return self.getTypedRuleContext(govdslParser.ScopesContext,0)


        def participants(self):
            return self.getTypedRuleContext(govdslParser.ParticipantsContext,0)


        def policy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.PolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_governance

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGovernance" ):
                listener.enterGovernance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGovernance" ):
                listener.exitGovernance(self)




    def governance(self):

        localctx = govdslParser.GovernanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_governance)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 156
            self.scopes()
            self.state = 157
            self.participants()
            self.state = 159 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 158
                self.policy()
                self.state = 161 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 163
            self.match(govdslParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def topLevelSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelSinglePolicyContext,0)


        def topLevelComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.TopLevelComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_policy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicy" ):
                listener.enterPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicy" ):
                listener.exitPolicy(self)




    def policy(self):

        localctx = govdslParser.PolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_policy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.state = 165
                self.topLevelSinglePolicy()
                pass
            elif token in [3]:
                self.state = 166
                self.topLevelComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSinglePolicy" ):
                listener.enterTopLevelSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSinglePolicy" ):
                listener.exitTopLevelSinglePolicy(self)




    def topLevelSinglePolicy(self):

        localctx = govdslParser.TopLevelSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topLevelSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            self.policyType()
            self.state = 170
            self.match(govdslParser.ID)
            self.state = 171
            self.match(govdslParser.T__0)
            self.state = 172
            self.scope()
            self.state = 173
            self.decisionType()
            self.state = 175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==50:
                self.state = 174
                self.policyParticipants()


            self.state = 178
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==51:
                self.state = 177
                self.conditions()


            self.state = 181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==69:
                self.state = 180
                self.parameters()


            self.state = 183
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def scope(self):
            return self.getTypedRuleContext(govdslParser.ScopeContext,0)


        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_topLevelComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelComposedPolicy" ):
                listener.enterTopLevelComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelComposedPolicy" ):
                listener.exitTopLevelComposedPolicy(self)




    def topLevelComposedPolicy(self):

        localctx = govdslParser.TopLevelComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_topLevelComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.match(govdslParser.T__2)
            self.state = 186
            self.match(govdslParser.ID)
            self.state = 187
            self.match(govdslParser.T__0)
            self.state = 188
            self.scope()
            self.state = 190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==73:
                self.state = 189
                self.order()


            self.state = 192
            self.phases()
            self.state = 193
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedSinglePolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def policyType(self):
            return self.getTypedRuleContext(govdslParser.PolicyTypeContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def decisionType(self):
            return self.getTypedRuleContext(govdslParser.DecisionTypeContext,0)


        def policyParticipants(self):
            return self.getTypedRuleContext(govdslParser.PolicyParticipantsContext,0)


        def conditions(self):
            return self.getTypedRuleContext(govdslParser.ConditionsContext,0)


        def parameters(self):
            return self.getTypedRuleContext(govdslParser.ParametersContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedSinglePolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedSinglePolicy" ):
                listener.enterNestedSinglePolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedSinglePolicy" ):
                listener.exitNestedSinglePolicy(self)




    def nestedSinglePolicy(self):

        localctx = govdslParser.NestedSinglePolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_nestedSinglePolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.policyType()
            self.state = 196
            self.match(govdslParser.ID)
            self.state = 197
            self.match(govdslParser.T__0)
            self.state = 198
            self.decisionType()
            self.state = 200
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==50:
                self.state = 199
                self.policyParticipants()


            self.state = 203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==51:
                self.state = 202
                self.conditions()


            self.state = 206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==69:
                self.state = 205
                self.parameters()


            self.state = 208
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedComposedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def phases(self):
            return self.getTypedRuleContext(govdslParser.PhasesContext,0)


        def order(self):
            return self.getTypedRuleContext(govdslParser.OrderContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedComposedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedComposedPolicy" ):
                listener.enterNestedComposedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedComposedPolicy" ):
                listener.exitNestedComposedPolicy(self)




    def nestedComposedPolicy(self):

        localctx = govdslParser.NestedComposedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_nestedComposedPolicy)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self.match(govdslParser.T__2)
            self.state = 211
            self.match(govdslParser.ID)
            self.state = 212
            self.match(govdslParser.T__0)
            self.state = 214
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==73:
                self.state = 213
                self.order()


            self.state = 216
            self.phases()
            self.state = 217
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_policyType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyType" ):
                listener.enterPolicyType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyType" ):
                listener.exitPolicyType(self)




    def policyType(self):

        localctx = govdslParser.PolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_policyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1008) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def projects(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProjectsContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProjectsContext,i)


        def activities(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivitiesContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivitiesContext,i)


        def tasks(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TasksContext)
            else:
                return self.getTypedRuleContext(govdslParser.TasksContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_scopes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopes" ):
                listener.enterScopes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopes" ):
                listener.exitScopes(self)




    def scopes(self):

        localctx = govdslParser.ScopesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_scopes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self.match(govdslParser.T__9)
            self.state = 222
            self.match(govdslParser.T__10)
            self.state = 226 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 226
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13]:
                    self.state = 223
                    self.projects()
                    pass
                elif token in [15]:
                    self.state = 224
                    self.activities()
                    pass
                elif token in [18]:
                    self.state = 225
                    self.tasks()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 228 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 303104) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScope" ):
                listener.enterScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScope" ):
                listener.exitScope(self)




    def scope(self):

        localctx = govdslParser.ScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_scope)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(govdslParser.T__11)
            self.state = 231
            self.match(govdslParser.T__10)
            self.state = 232
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProjectContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProjectContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_projects

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProjects" ):
                listener.enterProjects(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProjects" ):
                listener.exitProjects(self)




    def projects(self):

        localctx = govdslParser.ProjectsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_projects)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.match(govdslParser.T__12)
            self.state = 235
            self.match(govdslParser.T__10)
            self.state = 237 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 236
                self.project()
                self.state = 239 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==82):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def platform(self):
            return self.getTypedRuleContext(govdslParser.PlatformContext,0)


        def repoID(self):
            return self.getTypedRuleContext(govdslParser.RepoIDContext,0)


        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)




    def project(self):

        localctx = govdslParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.match(govdslParser.ID)
            self.state = 247
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 242
                self.match(govdslParser.T__13)
                self.state = 243
                self.platform()
                self.state = 244
                self.match(govdslParser.T__10)
                self.state = 245
                self.repoID()


            self.state = 259
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 249
                self.match(govdslParser.T__0)
                self.state = 250
                self.match(govdslParser.T__14)
                self.state = 251
                self.match(govdslParser.T__10)
                self.state = 253 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 252
                    self.activity()
                    self.state = 255 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==82):
                        break

                self.state = 257
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlatformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_platform

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlatform" ):
                listener.enterPlatform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlatform" ):
                listener.exitPlatform(self)




    def platform(self):

        localctx = govdslParser.PlatformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_platform)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.match(govdslParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepoIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_repoID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepoID" ):
                listener.enterRepoID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepoID" ):
                listener.exitRepoID(self)




    def repoID(self):

        localctx = govdslParser.RepoIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_repoID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.match(govdslParser.ID)
            self.state = 266
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 264
                self.match(govdslParser.T__16)
                self.state = 265
                self.match(govdslParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivitiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def activity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ActivityContext)
            else:
                return self.getTypedRuleContext(govdslParser.ActivityContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_activities

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivities" ):
                listener.enterActivities(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivities" ):
                listener.exitActivities(self)




    def activities(self):

        localctx = govdslParser.ActivitiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_activities)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268
            self.match(govdslParser.T__14)
            self.state = 269
            self.match(govdslParser.T__10)
            self.state = 271 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 270
                self.activity()
                self.state = 273 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==82):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActivityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_activity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActivity" ):
                listener.enterActivity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActivity" ):
                listener.exitActivity(self)




    def activity(self):

        localctx = govdslParser.ActivityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_activity)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self.match(govdslParser.ID)
            self.state = 286
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 276
                self.match(govdslParser.T__0)
                self.state = 277
                self.match(govdslParser.T__17)
                self.state = 278
                self.match(govdslParser.T__10)
                self.state = 280 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 279
                    self.task()
                    self.state = 282 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==82):
                        break

                self.state = 284
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TasksContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def task(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.TaskContext)
            else:
                return self.getTypedRuleContext(govdslParser.TaskContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_tasks

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTasks" ):
                listener.enterTasks(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTasks" ):
                listener.exitTasks(self)




    def tasks(self):

        localctx = govdslParser.TasksContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_tasks)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.match(govdslParser.T__17)
            self.state = 289
            self.match(govdslParser.T__10)
            self.state = 291 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 290
                self.task()
                self.state = 293 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==82):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def taskType(self):
            return self.getTypedRuleContext(govdslParser.TaskTypeContext,0)


        def taskContent(self):
            return self.getTypedRuleContext(govdslParser.TaskContentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_task

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTask" ):
                listener.enterTask(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTask" ):
                listener.exitTask(self)




    def task(self):

        localctx = govdslParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_task)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self.match(govdslParser.ID)
            self.state = 298
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 296
                self.match(govdslParser.T__10)
                self.state = 297
                self.taskType()


            self.state = 304
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 300
                self.match(govdslParser.T__0)
                self.state = 301
                self.taskContent()
                self.state = 302
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_taskType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskType" ):
                listener.enterTaskType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskType" ):
                listener.exitTaskType(self)




    def taskType(self):

        localctx = govdslParser.TaskTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_taskType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3670016) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(govdslParser.StatusContext,0)


        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def actionWithLabels(self):
            return self.getTypedRuleContext(govdslParser.ActionWithLabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_taskContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskContent" ):
                listener.enterTaskContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskContent" ):
                listener.exitTaskContent(self)




    def taskContent(self):

        localctx = govdslParser.TaskContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_taskContent)
        try:
            self.state = 311
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 308
                self.status()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 309
                self.action()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 310
                self.actionWithLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionWithLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(govdslParser.ActionContext,0)


        def labels(self):
            return self.getTypedRuleContext(govdslParser.LabelsContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_actionWithLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionWithLabels" ):
                listener.enterActionWithLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionWithLabels" ):
                listener.exitActionWithLabels(self)




    def actionWithLabels(self):

        localctx = govdslParser.ActionWithLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_actionWithLabels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 313
            self.action()
            self.state = 314
            self.labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statusEnum(self):
            return self.getTypedRuleContext(govdslParser.StatusEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = govdslParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_status)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            self.match(govdslParser.T__21)
            self.state = 317
            self.match(govdslParser.T__10)
            self.state = 318
            self.statusEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_statusEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusEnum" ):
                listener.enterStatusEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusEnum" ):
                listener.exitStatusEnum(self)




    def statusEnum(self):

        localctx = govdslParser.StatusEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_statusEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 58720256) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionEnum(self):
            return self.getTypedRuleContext(govdslParser.ActionEnumContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = govdslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            self.match(govdslParser.T__25)
            self.state = 323
            self.match(govdslParser.T__10)
            self.state = 324
            self.actionEnum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionEnumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_actionEnum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionEnum" ):
                listener.enterActionEnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionEnum" ):
                listener.exitActionEnum(self)




    def actionEnum(self):

        localctx = govdslParser.ActionEnumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_actionEnum)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 326
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 939524096) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabels" ):
                listener.enterLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabels" ):
                listener.exitLabels(self)




    def labels(self):

        localctx = govdslParser.LabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.match(govdslParser.T__29)
            self.state = 329
            self.match(govdslParser.T__10)
            self.state = 330
            self.match(govdslParser.ID)
            self.state = 335
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 331
                self.match(govdslParser.T__30)
                self.state = 332
                self.match(govdslParser.ID)
                self.state = 337
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecisionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanDecision(self):
            return self.getTypedRuleContext(govdslParser.BooleanDecisionContext,0)


        def stringList(self):
            return self.getTypedRuleContext(govdslParser.StringListContext,0)


        def elementList(self):
            return self.getTypedRuleContext(govdslParser.ElementListContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_decisionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecisionType" ):
                listener.enterDecisionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecisionType" ):
                listener.exitDecisionType(self)




    def decisionType(self):

        localctx = govdslParser.DecisionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_decisionType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(govdslParser.T__31)
            self.state = 339
            self.match(govdslParser.T__32)
            self.state = 343
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 340
                self.booleanDecision()
                pass
            elif token in [35]:
                self.state = 341
                self.stringList()
                pass
            elif token in [36]:
                self.state = 342
                self.elementList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDecisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanDecision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDecision" ):
                listener.enterBooleanDecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDecision" ):
                listener.exitBooleanDecision(self)




    def booleanDecision(self):

        localctx = govdslParser.BooleanDecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_booleanDecision)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 345
            self.match(govdslParser.T__33)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_stringList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringList" ):
                listener.enterStringList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringList" ):
                listener.exitStringList(self)




    def stringList(self):

        localctx = govdslParser.StringListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_stringList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 347
            self.match(govdslParser.T__34)
            self.state = 348
            self.match(govdslParser.T__10)
            self.state = 349
            self.match(govdslParser.ID)
            self.state = 354
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 350
                self.match(govdslParser.T__30)
                self.state = 351
                self.match(govdslParser.ID)
                self.state = 356
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_elementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementList" ):
                listener.enterElementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementList" ):
                listener.exitElementList(self)




    def elementList(self):

        localctx = govdslParser.ElementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_elementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 357
            self.match(govdslParser.T__35)
            self.state = 358
            self.match(govdslParser.T__10)
            self.state = 359
            self.match(govdslParser.ID)
            self.state = 364
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 360
                self.match(govdslParser.T__30)
                self.state = 361
                self.match(govdslParser.ID)
                self.state = 366
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def roles(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.RolesContext)
            else:
                return self.getTypedRuleContext(govdslParser.RolesContext,i)


        def individuals(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualsContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualsContext,i)


        def profiles(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProfilesContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProfilesContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = govdslParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_participants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 367
            self.match(govdslParser.T__36)
            self.state = 368
            self.match(govdslParser.T__10)
            self.state = 372 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 372
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [38]:
                    self.state = 369
                    self.roles()
                    pass
                elif token in [39]:
                    self.state = 370
                    self.individuals()
                    pass
                elif token in [47]:
                    self.state = 371
                    self.profiles()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 374 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 141562122076160) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.RoleContext)
            else:
                return self.getTypedRuleContext(govdslParser.RoleContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_roles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles" ):
                listener.enterRoles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles" ):
                listener.exitRoles(self)




    def roles(self):

        localctx = govdslParser.RolesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_roles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(govdslParser.T__37)
            self.state = 377
            self.match(govdslParser.T__10)
            self.state = 378
            self.role()
            self.state = 383
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 379
                self.match(govdslParser.T__30)
                self.state = 380
                self.role()
                self.state = 385
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)




    def role(self):

        localctx = govdslParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_role)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 386
            self.match(govdslParser.ID)
            self.state = 392
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 387
                self.match(govdslParser.T__0)
                self.state = 389
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==40:
                    self.state = 388
                    self.voteValue()


                self.state = 391
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individualEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.IndividualEntryContext)
            else:
                return self.getTypedRuleContext(govdslParser.IndividualEntryContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_individuals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividuals" ):
                listener.enterIndividuals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividuals" ):
                listener.exitIndividuals(self)




    def individuals(self):

        localctx = govdslParser.IndividualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_individuals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 394
            self.match(govdslParser.T__38)
            self.state = 395
            self.match(govdslParser.T__10)
            self.state = 396
            self.individualEntry()
            self.state = 403
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 31)) & ~0x3f) == 0 and ((1 << (_la - 31)) & 2251799813689345) != 0):
                self.state = 398
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 397
                    self.match(govdslParser.T__30)


                self.state = 400
                self.individualEntry()
                self.state = 405
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def individual(self):
            return self.getTypedRuleContext(govdslParser.IndividualContext,0)


        def agent(self):
            return self.getTypedRuleContext(govdslParser.AgentContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individualEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividualEntry" ):
                listener.enterIndividualEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividualEntry" ):
                listener.exitIndividualEntry(self)




    def individualEntry(self):

        localctx = govdslParser.IndividualEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_individualEntry)
        try:
            self.state = 408
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [82]:
                self.enterOuterAlt(localctx, 1)
                self.state = 406
                self.individual()
                pass
            elif token in [43]:
                self.enterOuterAlt(localctx, 2)
                self.state = 407
                self.agent()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndividualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def withProfile(self):
            return self.getTypedRuleContext(govdslParser.WithProfileContext,0)


        def withRole(self):
            return self.getTypedRuleContext(govdslParser.WithRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_individual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndividual" ):
                listener.enterIndividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndividual" ):
                listener.exitIndividual(self)




    def individual(self):

        localctx = govdslParser.IndividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_individual)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.match(govdslParser.ID)
            self.state = 428
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 411
                self.match(govdslParser.T__0)
                self.state = 413
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==40:
                    self.state = 412
                    self.voteValue()


                self.state = 416
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
                if la_ == 1:
                    self.state = 415
                    self.match(govdslParser.T__30)


                self.state = 419
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==41:
                    self.state = 418
                    self.withProfile()


                self.state = 422
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 421
                    self.match(govdslParser.T__30)


                self.state = 425
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==42:
                    self.state = 424
                    self.withRole()


                self.state = 427
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoteValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_voteValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoteValue" ):
                listener.enterVoteValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoteValue" ):
                listener.exitVoteValue(self)




    def voteValue(self):

        localctx = govdslParser.VoteValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_voteValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            self.match(govdslParser.T__39)
            self.state = 431
            self.match(govdslParser.T__10)
            self.state = 432
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithProfileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_withProfile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithProfile" ):
                listener.enterWithProfile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithProfile" ):
                listener.exitWithProfile(self)




    def withProfile(self):

        localctx = govdslParser.WithProfileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_withProfile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 434
            self.match(govdslParser.T__40)
            self.state = 435
            self.match(govdslParser.T__10)
            self.state = 436
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_withRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithRole" ):
                listener.enterWithRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithRole" ):
                listener.exitWithRole(self)




    def withRole(self):

        localctx = govdslParser.WithRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_withRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 438
            self.match(govdslParser.T__41)
            self.state = 439
            self.match(govdslParser.T__10)
            self.state = 440
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AgentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def voteValue(self):
            return self.getTypedRuleContext(govdslParser.VoteValueContext,0)


        def confidence(self):
            return self.getTypedRuleContext(govdslParser.ConfidenceContext,0)


        def autonomyLevel(self):
            return self.getTypedRuleContext(govdslParser.AutonomyLevelContext,0)


        def explainability(self):
            return self.getTypedRuleContext(govdslParser.ExplainabilityContext,0)


        def withRole(self):
            return self.getTypedRuleContext(govdslParser.WithRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_agent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent" ):
                listener.enterAgent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent" ):
                listener.exitAgent(self)




    def agent(self):

        localctx = govdslParser.AgentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_agent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 442
            self.match(govdslParser.T__42)
            self.state = 443
            self.match(govdslParser.ID)
            self.state = 473
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 444
                self.match(govdslParser.T__0)
                self.state = 446
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==40:
                    self.state = 445
                    self.voteValue()


                self.state = 449
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
                if la_ == 1:
                    self.state = 448
                    self.match(govdslParser.T__30)


                self.state = 452
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==44:
                    self.state = 451
                    self.confidence()


                self.state = 455
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                if la_ == 1:
                    self.state = 454
                    self.match(govdslParser.T__30)


                self.state = 458
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==45:
                    self.state = 457
                    self.autonomyLevel()


                self.state = 461
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                if la_ == 1:
                    self.state = 460
                    self.match(govdslParser.T__30)


                self.state = 464
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==46:
                    self.state = 463
                    self.explainability()


                self.state = 467
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 466
                    self.match(govdslParser.T__30)


                self.state = 470
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==42:
                    self.state = 469
                    self.withRole()


                self.state = 472
                self.match(govdslParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfidenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_confidence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfidence" ):
                listener.enterConfidence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfidence" ):
                listener.exitConfidence(self)




    def confidence(self):

        localctx = govdslParser.ConfidenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_confidence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            self.match(govdslParser.T__43)
            self.state = 476
            self.match(govdslParser.T__10)
            self.state = 477
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutonomyLevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_autonomyLevel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutonomyLevel" ):
                listener.enterAutonomyLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutonomyLevel" ):
                listener.exitAutonomyLevel(self)




    def autonomyLevel(self):

        localctx = govdslParser.AutonomyLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_autonomyLevel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            self.match(govdslParser.T__44)
            self.state = 480
            self.match(govdslParser.T__10)
            self.state = 481
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExplainabilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_explainability

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplainability" ):
                listener.enterExplainability(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplainability" ):
                listener.exitExplainability(self)




    def explainability(self):

        localctx = govdslParser.ExplainabilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_explainability)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 483
            self.match(govdslParser.T__45)
            self.state = 484
            self.match(govdslParser.T__10)
            self.state = 485
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProfilesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def profile(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.ProfileContext)
            else:
                return self.getTypedRuleContext(govdslParser.ProfileContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_profiles

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProfiles" ):
                listener.enterProfiles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProfiles" ):
                listener.exitProfiles(self)




    def profiles(self):

        localctx = govdslParser.ProfilesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_profiles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 487
            self.match(govdslParser.T__46)
            self.state = 488
            self.match(govdslParser.T__10)
            self.state = 489
            self.profile()
            self.state = 496
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31 or _la==82:
                self.state = 491
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 490
                    self.match(govdslParser.T__30)


                self.state = 493
                self.profile()
                self.state = 498
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProfileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def gender(self):
            return self.getTypedRuleContext(govdslParser.GenderContext,0)


        def race(self):
            return self.getTypedRuleContext(govdslParser.RaceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_profile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProfile" ):
                listener.enterProfile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProfile" ):
                listener.exitProfile(self)




    def profile(self):

        localctx = govdslParser.ProfileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_profile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 499
            self.match(govdslParser.ID)
            self.state = 500
            self.match(govdslParser.T__0)
            self.state = 515
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48]:
                self.state = 501
                self.gender()
                self.state = 503
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 502
                    self.match(govdslParser.T__30)


                self.state = 506
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==49:
                    self.state = 505
                    self.race()


                pass
            elif token in [49]:
                self.state = 508
                self.race()
                self.state = 510
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 509
                    self.match(govdslParser.T__30)


                self.state = 513
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==48:
                    self.state = 512
                    self.gender()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 517
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_gender

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGender" ):
                listener.enterGender(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGender" ):
                listener.exitGender(self)




    def gender(self):

        localctx = govdslParser.GenderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_gender)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 519
            self.match(govdslParser.T__47)
            self.state = 520
            self.match(govdslParser.T__10)
            self.state = 521
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_race

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRace" ):
                listener.enterRace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRace" ):
                listener.exitRace(self)




    def race(self):

        localctx = govdslParser.RaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_race)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 523
            self.match(govdslParser.T__48)
            self.state = 524
            self.match(govdslParser.T__10)
            self.state = 525
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def partID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.PartIDContext)
            else:
                return self.getTypedRuleContext(govdslParser.PartIDContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_policyParticipants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyParticipants" ):
                listener.enterPolicyParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyParticipants" ):
                listener.exitPolicyParticipants(self)




    def policyParticipants(self):

        localctx = govdslParser.PolicyParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_policyParticipants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 527
            self.match(govdslParser.T__49)
            self.state = 528
            self.match(govdslParser.T__10)
            self.state = 529
            self.partID()
            self.state = 534
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 530
                self.match(govdslParser.T__30)
                self.state = 531
                self.partID()
                self.state = 536
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def hasRole(self):
            return self.getTypedRuleContext(govdslParser.HasRoleContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_partID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartID" ):
                listener.enterPartID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartID" ):
                listener.exitPartID(self)




    def partID(self):

        localctx = govdslParser.PartIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_partID)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 537
            self.match(govdslParser.ID)
            self.state = 539
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 538
                self.hasRole()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasRoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_hasRole

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasRole" ):
                listener.enterHasRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasRole" ):
                listener.exitHasRole(self)




    def hasRole(self):

        localctx = govdslParser.HasRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_hasRole)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 541
            self.match(govdslParser.T__32)
            self.state = 542
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def deadline(self):
            return self.getTypedRuleContext(govdslParser.DeadlineContext,0)


        def minDecisionTime(self):
            return self.getTypedRuleContext(govdslParser.MinDecisionTimeContext,0)


        def participantExclusion(self):
            return self.getTypedRuleContext(govdslParser.ParticipantExclusionContext,0)


        def minParticipant(self):
            return self.getTypedRuleContext(govdslParser.MinParticipantContext,0)


        def vetoRight(self):
            return self.getTypedRuleContext(govdslParser.VetoRightContext,0)


        def appealRight(self):
            return self.getTypedRuleContext(govdslParser.AppealRightContext,0)


        def passedTests(self):
            return self.getTypedRuleContext(govdslParser.PassedTestsContext,0)


        def labelsCondition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.LabelsConditionContext)
            else:
                return self.getTypedRuleContext(govdslParser.LabelsConditionContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_conditions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditions" ):
                listener.enterConditions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditions" ):
                listener.exitConditions(self)




    def conditions(self):

        localctx = govdslParser.ConditionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_conditions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 544
            self.match(govdslParser.T__50)
            self.state = 545
            self.match(govdslParser.T__10)
            self.state = 547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 546
                self.deadline()


            self.state = 550
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==53:
                self.state = 549
                self.minDecisionTime()


            self.state = 553
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==58:
                self.state = 552
                self.participantExclusion()


            self.state = 556
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==59:
                self.state = 555
                self.minParticipant()


            self.state = 559
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==60:
                self.state = 558
                self.vetoRight()


            self.state = 562
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==61:
                self.state = 561
                self.appealRight()


            self.state = 565
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==62:
                self.state = 564
                self.passedTests()


            self.state = 570
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==66:
                self.state = 567
                self.labelsCondition()
                self.state = 572
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def deadlineID(self):
            return self.getTypedRuleContext(govdslParser.DeadlineIDContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_deadline

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadline" ):
                listener.enterDeadline(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadline" ):
                listener.exitDeadline(self)




    def deadline(self):

        localctx = govdslParser.DeadlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_deadline)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 573
            self.match(govdslParser.T__51)
            self.state = 575
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==82:
                self.state = 574
                self.deadlineID()


            self.state = 577
            self.match(govdslParser.T__10)
            self.state = 584
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 578
                self.offset()
                pass

            elif la_ == 2:
                self.state = 579
                self.date()
                pass

            elif la_ == 3:
                self.state = 580
                self.offset()
                self.state = 581
                self.match(govdslParser.T__30)
                self.state = 582
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinDecisionTimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def offset(self):
            return self.getTypedRuleContext(govdslParser.OffsetContext,0)


        def date(self):
            return self.getTypedRuleContext(govdslParser.DateContext,0)


        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minDecisionTime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinDecisionTime" ):
                listener.enterMinDecisionTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinDecisionTime" ):
                listener.exitMinDecisionTime(self)




    def minDecisionTime(self):

        localctx = govdslParser.MinDecisionTimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_minDecisionTime)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 586
            self.match(govdslParser.T__52)
            self.state = 588
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==82:
                self.state = 587
                self.match(govdslParser.ID)


            self.state = 590
            self.match(govdslParser.T__10)
            self.state = 597
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 591
                self.offset()
                pass

            elif la_ == 2:
                self.state = 592
                self.date()
                pass

            elif la_ == 3:
                self.state = 593
                self.offset()
                self.state = 594
                self.match(govdslParser.T__30)
                self.state = 595
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def timeUnit(self):
            return self.getTypedRuleContext(govdslParser.TimeUnitContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = govdslParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 599
            self.match(govdslParser.SIGNED_INT)
            self.state = 600
            self.timeUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeadlineIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_deadlineID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeadlineID" ):
                listener.enterDeadlineID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeadlineID" ):
                listener.exitDeadlineID(self)




    def deadlineID(self):

        localctx = govdslParser.DeadlineIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_deadlineID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 602
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)




    def timeUnit(self):

        localctx = govdslParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 604
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 270215977642229760) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.SIGNED_INT)
            else:
                return self.getToken(govdslParser.SIGNED_INT, i)

        def getRuleIndex(self):
            return govdslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = govdslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 606
            self.match(govdslParser.SIGNED_INT)
            self.state = 607
            self.match(govdslParser.T__16)
            self.state = 608
            self.match(govdslParser.SIGNED_INT)
            self.state = 609
            self.match(govdslParser.T__16)
            self.state = 610
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantExclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_participantExclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipantExclusion" ):
                listener.enterParticipantExclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipantExclusion" ):
                listener.exitParticipantExclusion(self)




    def participantExclusion(self):

        localctx = govdslParser.ParticipantExclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_participantExclusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 612
            self.match(govdslParser.T__57)
            self.state = 613
            self.match(govdslParser.T__10)
            self.state = 614
            self.match(govdslParser.ID)
            self.state = 619
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 615
                self.match(govdslParser.T__30)
                self.state = 616
                self.match(govdslParser.ID)
                self.state = 621
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinParticipantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGNED_INT(self):
            return self.getToken(govdslParser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_minParticipant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinParticipant" ):
                listener.enterMinParticipant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinParticipant" ):
                listener.exitMinParticipant(self)




    def minParticipant(self):

        localctx = govdslParser.MinParticipantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_minParticipant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 622
            self.match(govdslParser.T__58)
            self.state = 623
            self.match(govdslParser.T__10)
            self.state = 624
            self.match(govdslParser.SIGNED_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VetoRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_vetoRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVetoRight" ):
                listener.enterVetoRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVetoRight" ):
                listener.exitVetoRight(self)




    def vetoRight(self):

        localctx = govdslParser.VetoRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_vetoRight)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 626
            self.match(govdslParser.T__59)
            self.state = 627
            self.match(govdslParser.T__10)
            self.state = 628
            self.match(govdslParser.ID)
            self.state = 633
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 629
                self.match(govdslParser.T__30)
                self.state = 630
                self.match(govdslParser.ID)
                self.state = 635
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AppealRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def getRuleIndex(self):
            return govdslParser.RULE_appealRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppealRight" ):
                listener.enterAppealRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppealRight" ):
                listener.exitAppealRight(self)




    def appealRight(self):

        localctx = govdslParser.AppealRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_appealRight)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 636
            self.match(govdslParser.T__60)
            self.state = 637
            self.match(govdslParser.T__10)
            self.state = 638
            self.match(govdslParser.ID)
            self.state = 643
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 639
                self.match(govdslParser.T__30)
                self.state = 640
                self.match(govdslParser.ID)
                self.state = 645
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PassedTestsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_passedTests

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPassedTests" ):
                listener.enterPassedTests(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPassedTests" ):
                listener.exitPassedTests(self)




    def passedTests(self):

        localctx = govdslParser.PassedTestsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_passedTests)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 646
            self.match(govdslParser.T__61)
            self.state = 648
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & 7) != 0):
                self.state = 647
                self.evaluationMode()


            self.state = 650
            self.match(govdslParser.T__10)
            self.state = 651
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EvaluationModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_evaluationMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvaluationMode" ):
                listener.enterEvaluationMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvaluationMode" ):
                listener.exitEvaluationMode(self)




    def evaluationMode(self):

        localctx = govdslParser.EvaluationModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_evaluationMode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 653
            _la = self._input.LA(1)
            if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelsConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(govdslParser.ID)
            else:
                return self.getToken(govdslParser.ID, i)

        def evaluationMode(self):
            return self.getTypedRuleContext(govdslParser.EvaluationModeContext,0)


        def include(self):
            return self.getTypedRuleContext(govdslParser.IncludeContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_labelsCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelsCondition" ):
                listener.enterLabelsCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelsCondition" ):
                listener.exitLabelsCondition(self)




    def labelsCondition(self):

        localctx = govdslParser.LabelsConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_labelsCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 655
            self.match(govdslParser.T__65)
            self.state = 657
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & 7) != 0):
                self.state = 656
                self.evaluationMode()


            self.state = 660
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67 or _la==68:
                self.state = 659
                self.include()


            self.state = 662
            self.match(govdslParser.T__10)
            self.state = 663
            self.match(govdslParser.ID)
            self.state = 668
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31:
                self.state = 664
                self.match(govdslParser.T__30)
                self.state = 665
                self.match(govdslParser.ID)
                self.state = 670
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_include

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude" ):
                listener.enterInclude(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude" ):
                listener.exitInclude(self)




    def include(self):

        localctx = govdslParser.IncludeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_include)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 671
            _la = self._input.LA(1)
            if not(_la==67 or _la==68):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def votParams(self):
            return self.getTypedRuleContext(govdslParser.VotParamsContext,0)


        def default(self):
            return self.getTypedRuleContext(govdslParser.DefaultContext,0)


        def fallback(self):
            return self.getTypedRuleContext(govdslParser.FallbackContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = govdslParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 673
            self.match(govdslParser.T__68)
            self.state = 674
            self.match(govdslParser.T__10)
            self.state = 678
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [70]:
                self.state = 675
                self.votParams()
                pass
            elif token in [71]:
                self.state = 676
                self.default()
                pass
            elif token in [72]:
                self.state = 677
                self.fallback()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VotParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ratio(self):
            return self.getTypedRuleContext(govdslParser.RatioContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_votParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVotParams" ):
                listener.enterVotParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVotParams" ):
                listener.exitVotParams(self)




    def votParams(self):

        localctx = govdslParser.VotParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_votParams)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 680
            self.ratio()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(govdslParser.FLOAT, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_ratio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatio" ):
                listener.enterRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatio" ):
                listener.exitRatio(self)




    def ratio(self):

        localctx = govdslParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_ratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 682
            self.match(govdslParser.T__69)
            self.state = 683
            self.match(govdslParser.T__10)
            self.state = 684
            self.match(govdslParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def policyReference(self):
            return self.getTypedRuleContext(govdslParser.PolicyReferenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)




    def default(self):

        localctx = govdslParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 686
            self.match(govdslParser.T__70)
            self.state = 687
            self.match(govdslParser.T__10)
            self.state = 690
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 6, 7, 8, 9]:
                self.state = 688
                self.nestedPolicy()
                pass
            elif token in [82]:
                self.state = 689
                self.policyReference()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FallbackContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedPolicyContext,0)


        def policyReference(self):
            return self.getTypedRuleContext(govdslParser.PolicyReferenceContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_fallback

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFallback" ):
                listener.enterFallback(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFallback" ):
                listener.exitFallback(self)




    def fallback(self):

        localctx = govdslParser.FallbackContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_fallback)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self.match(govdslParser.T__71)
            self.state = 693
            self.match(govdslParser.T__10)
            self.state = 696
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4, 5, 6, 7, 8, 9]:
                self.state = 694
                self.nestedPolicy()
                pass
            elif token in [82]:
                self.state = 695
                self.policyReference()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolicyReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(govdslParser.ID, 0)

        def getRuleIndex(self):
            return govdslParser.RULE_policyReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolicyReference" ):
                listener.enterPolicyReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolicyReference" ):
                listener.exitPolicyReference(self)




    def policyReference(self):

        localctx = govdslParser.PolicyReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_policyReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 698
            self.match(govdslParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderType(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeContext,0)


        def orderMode(self):
            return self.getTypedRuleContext(govdslParser.OrderModeContext,0)


        def carryOver(self):
            return self.getTypedRuleContext(govdslParser.CarryOverContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = govdslParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 700
            self.match(govdslParser.T__72)
            self.state = 701
            self.match(govdslParser.T__10)

            self.state = 702
            self.orderType()
            self.state = 703
            self.orderMode()
            self.state = 705
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==78:
                self.state = 704
                self.carryOver()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderTypeValue(self):
            return self.getTypedRuleContext(govdslParser.OrderTypeValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderType" ):
                listener.enterOrderType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderType" ):
                listener.exitOrderType(self)




    def orderType(self):

        localctx = govdslParser.OrderTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_orderType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 707
            self.match(govdslParser.T__73)
            self.state = 708
            self.match(govdslParser.T__10)
            self.state = 709
            self.orderTypeValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderTypeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_orderTypeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderTypeValue" ):
                listener.enterOrderTypeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderTypeValue" ):
                listener.exitOrderTypeValue(self)




    def orderTypeValue(self):

        localctx = govdslParser.OrderTypeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_orderTypeValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 711
            _la = self._input.LA(1)
            if not(_la==75 or _la==76):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderModeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_orderMode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderMode" ):
                listener.enterOrderMode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderMode" ):
                listener.exitOrderMode(self)




    def orderMode(self):

        localctx = govdslParser.OrderModeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_orderMode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 713
            self.match(govdslParser.T__76)
            self.state = 714
            self.match(govdslParser.T__10)
            self.state = 715
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CarryOverContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanValue(self):
            return self.getTypedRuleContext(govdslParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_carryOver

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCarryOver" ):
                listener.enterCarryOver(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCarryOver" ):
                listener.exitCarryOver(self)




    def carryOver(self):

        localctx = govdslParser.CarryOverContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_carryOver)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 717
            self.match(govdslParser.T__77)
            self.state = 718
            self.match(govdslParser.T__10)
            self.state = 719
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return govdslParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = govdslParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 721
            _la = self._input.LA(1)
            if not(_la==79 or _la==80):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedPolicy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(govdslParser.NestedPolicyContext)
            else:
                return self.getTypedRuleContext(govdslParser.NestedPolicyContext,i)


        def getRuleIndex(self):
            return govdslParser.RULE_phases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhases" ):
                listener.enterPhases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhases" ):
                listener.exitPhases(self)




    def phases(self):

        localctx = govdslParser.PhasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_phases)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 723
            self.match(govdslParser.T__80)
            self.state = 724
            self.match(govdslParser.T__0)
            self.state = 726 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 725
                self.nestedPolicy()
                self.state = 728 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1016) != 0)):
                    break

            self.state = 730
            self.match(govdslParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedPolicyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedSinglePolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedSinglePolicyContext,0)


        def nestedComposedPolicy(self):
            return self.getTypedRuleContext(govdslParser.NestedComposedPolicyContext,0)


        def getRuleIndex(self):
            return govdslParser.RULE_nestedPolicy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedPolicy" ):
                listener.enterNestedPolicy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedPolicy" ):
                listener.exitNestedPolicy(self)




    def nestedPolicy(self):

        localctx = govdslParser.NestedPolicyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_nestedPolicy)
        try:
            self.state = 734
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 7, 8, 9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 732
                self.nestedSinglePolicy()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 733
                self.nestedComposedPolicy()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





